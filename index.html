<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.liwuxuanplus.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MySite">
<meta property="og:url" content="https://www.liwuxuanplus.com/index.html">
<meta property="og:site_name" content="MySite">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="liwuxuan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.liwuxuanplus.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MySite</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MySite</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">There is MySite</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.liwuxuanplus.com/2024/03/23/yun-ji-suan-shi-yan-bao-gao-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liwuxuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MySite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/23/yun-ji-suan-shi-yan-bao-gao-3/" class="post-title-link" itemprop="url">云计算实验报告3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-23 14:09:23 / 修改时间：14:50:49" itemprop="dateCreated datePublished" datetime="2024-03-23T14:09:23+08:00">2024-03-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>个人博客域名：<a href="https://www.liwuxuanplus.com/">MySite (liwuxuanplus.com)</a></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/6cOV0JXWdY0?si=ckgNMzj2zlul5U1l" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay=1; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.liwuxuanplus.com/2023/11/01/suan-fa-dao-lun-di-22-zhang-he-di-23-zhang-da-an/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liwuxuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MySite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/01/suan-fa-dao-lun-di-22-zhang-he-di-23-zhang-da-an/" class="post-title-link" itemprop="url">算法导论第22章和第23章答案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-01 22:25:20 / 修改时间：22:26:02" itemprop="dateCreated datePublished" datetime="2023-11-01T22:25:20+08:00">2023-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>深度优先森林将图的边分为树边、向后边、向前边和交叉边。宽度优先树还可以用于将从搜索源可到达的边分类为相同的四个类别。</p>
<p>**A.**证明在无向图的广度优先搜索中，以下性质成立：</p>
<ol>
<li>没有后边缘也没有前边缘。</li>
<li>对于每个树边$(u, v)$，我们有$v.d = u.d + 1$。</li>
<li>对于每个交叉边$(u, v)$，我们有$v.d = u.d$或$v.d = u.d + 1$。</li>
</ol>
<p><strong>乙。</strong>证明在有向图的广度优先搜索中，以下性质成立：</p>
<ol>
<li>没有向前的边。</li>
<li>对于每个树边$(u, v)$，我们有$v.d = u.d + 1$。</li>
<li>对于每个交叉边缘$(u, v)$，我们有$v.d \le u.d + 1$。</li>
<li>对于每个后沿$(u, v)$，我们有$0 \le v.d \le u.d$。</li>
</ol>
</blockquote>
<p><strong>A.</strong></p>
<ol>
<li><p>如果我们找到一条后边，这意味着有两个顶点，一个是另一个的后代，但已经有一条从祖先到子代的路径，这条路径不涉及在树中向上移动。这是一个矛盾，因为 BFS 树中唯一的子节点是那些只有一条边的子节点，这意味着不可能有任何其他路径到达该子节点，因为这将使其超过一条边。为了看到没有前沿，我们做了一个类似的过程。向前的边意味着从一个给定的顶点，我们注意到它有一个已经被处理过的子节点，但这不可能发生，因为所有的子节点都只有一条边的距离，并且对于已经被处理过的顶点，它需要先经过其他一些顶点。</p>
</li>
<li><p>如果边到达尚未考虑的顶点，则将其放置在要处理的列表上。这意味着从该顶点到根的路径必须至少等于到当前顶点的距离加上$1$。最多也是这样，因为我们可以只取一条路径，这条路径包括到当前顶点并取其到根的路径。</p>
</li>
<li><p>我们知道，交叉边不能深入到小于 1 的深度，否则在处理前面的元素时，它将被用作树边。它也不能去一个深度超过一个的顶点，因为我们不会已经处理了一个离根很远的顶点。由于交叉边中顶点的深度不能超过一个，因此可以通过交换和$v$的$u$角色来得出结论，我们可以这样做，因为边是无序的。</p>
</li>
</ol>
<p><strong>乙。</strong></p>
<ol>
<li><p>要获得前向边，我们需要已经使用多条边处理了一个顶点，即使存在使用一条边到达该顶点的路径。由于广度优先搜索总是首先考虑较短的路径，因此这是不可能的。</p>
</li>
<li><p>假设这$(u, v)$是一条树边。那么，这意味着存在一条长度$u.d + 1$为的从根到$v$的路径，只需将其附加$(u, v)$到从根到$u$的路径即可。为了看到没有更短的路径，我们只是注意到我们会更快地处理$v$，所以如果有的话，目前不会有树边。</p>
</li>
<li><p>要看到这一点，我们所需要做的就是注意到有一些从根到$v$的路径，其长度$u.d + 1$是通过附加$(u, v)$到$v.d$而获得的。由于存在该长度的路径，因此它用作从根到$v$的所有此类路径的最小长度的上限。</p>
</li>
<li><p>这是微不足道的$0 \le v.d$，因为不可能有一条从根到$v$负长度的路径。更有趣的不平等是$v.d \le u.d$。我们知道有一条从$v$到$u$的路径，由树的边组成，这是后沿的$(u, v)$定义属性。这意味着它$v, v_1, v_2, \dots, v_k, u$是这条路径（它是唯一的，因为树边形成了一棵树）。那么，我们有那个$u.d = v_k.d + 1 = v_{k − 1}.d + 2 = \cdots = v_1.d + k = v.d + k + 1$。所以，我们有那个$u.d &gt; v.d$。事实上，我们刚刚展示了我们有更有力的结论，那就是$0 \le v.d &lt; u.d$。</p>
</li>
</ol>
<blockquote>
<p>设$G = (V, E)$是一个连通的无向图。OF**<em>关节点</em><strong>$G$是其移除断开$G$的顶点。</strong><em>桥</em><strong>的$G$是其移除断开$G$的边。A</strong><em>双连接组件</em>**OF$G$是一个极大边集，使得集合中的任意两条边都位于一个公共的简单圈上。图 22.10 说明了这些定义。我们可以使用深度优先搜索来确定关节点、桥和双连接组件。设$G_\pi = (V, E_\pi)$是的$G$深度优先树。</p>
<p>**A.**证明的根$G_\pi$是的$G$关节点当且仅当它在中$G_\pi$至少有两个子根。</p>
<p><strong>乙。</strong>设$v$是的$G_\pi$非根顶点。证明$v$是的关节点$G$，当且仅当$v$有一个子节点$s$，使得没有从$s$的后沿或到的$v$正确祖先的$s$任何后代。</p>
<p>**C.**让。</p>
<p>$$<br>v.low = \min<br>\begin{cases}<br>v.d, \\<br>w.d:(u,w) \text{ is a back edge for some descendant } u \text{ of } v.<br>\end{cases}<br>$$</p>
<p>演示如何及时计算$v.low$所有顶点$v \in V$$O(E)$。</p>
<p>**D.**演示如何及时计算所有关节点$O(E)$。</p>
<p>**E.**证明的$G$边是桥当且仅当它不位于的$G$任何简单圈上。</p>
<p>**F.**展示如何计算时间的$G$$O(E)$所有桥梁。</p>
<p>**G.**证明的双连通分支$G$划分的$G$非桥边。</p>
<p>**H.**给出一个$O(E)$时间算法，用一个正整数$e.bcc$标记的$G$每条边$e$，使得$e.bcc = e’.bcc$当且仅当$e$和$e’$在同一个双连通分量中。</p>
</blockquote>
<p>**A.**首先假设的$G_\pi$根$r$是一个关节点。则从中$G$删除$r$将导致图形断开连接，因此$r$中$G$至少$2$有个子项。如果$r$中$G_\pi$只有一个子元素$v$，则必须有一条$v$到其他每个子元素的$r$路径。由于删除$r$断开了图，因此必须存在顶点$u$和$w$，以便从$u$到$w$的唯一路径包含$r$。</p>
<p>若要从$u$到达$r$，路径必须首先到达的$r$一个子项。此子项通过不包含$r$的路径连接到$v$。</p>
<p>要到达$w$，路径还必须通过它的一个子级离开$r$，该子级也可以通过$v$到达。这意味着有一条$u$$w$不包含$r$矛盾的路径。</p>
<p>现在假设$r$至少有两个孩子$u$，并且$v$在$G_\pi$。则不存在不经过$r$的从$u$到$v$$G$的路径，否则$u$将是的$v$祖先。因此，移除$r$断开了组件包含$u$和组件包含$v$，因此$r$是一个关节点。</p>
<p><strong>乙。</strong>假设$v$是的$G_\pi$非根顶点，并且$v$有一个子顶点$s$，使得的后代都$s$$s$没有到的正确祖先$v$的后边。设$r$为的$v$祖先，并从$G$其移除$v$。由于我们是在无向的情况下，图中唯一的边是树边或后边，这意味着与$s$关联的每条边都会将我们带到的$s$后代，并且没有后代具有后边，因此在任何时候我们都不能通过取边来向上移动树。因此$r$是不可到达的$s$，所以图形是断开的，并且$v$是一个关节点。</p>
<p>现在假设，对于的$v$每个子代，都存在该子代的一个后代，该后代具有到的正确祖先$v$的后沿。从.中删除$v$$G$。的$v$每个子树都是连通分支。在一个给定的子树中，找到一个顶点，该顶点有一条到的正确祖先$v$的后边。因为不是的$v$后代的顶点的集合$T$形成了一个连通分量，所以的每个子树$v$都是连通$T$的。因此，在删除 So$v$后，图形仍保持连接，$v$不是关节点。</p>
<p>**C.**由于$v$在其所有后代之前被发现，因此唯一可能影响$v.low$的后边缘是从的$v$后代到的正确祖先$v$的后边缘。如果我们知道$u.low$的$v$每个孩子$u$，那么我们就可以很容易地计算$v.low$，因为所有的信息都被编码在它的后代中。</p>
<p>因此，我们可以递归地写出算法：如果$v$是中的$G_\pi$叶子，则$v.low$是的最小值，$v.d$$w.d$其中$(v, w)$是后沿。如果$v$不是叶，$v$则是的最小值$v.d$，$w.d$其中$(v, w)$是后边缘，并且$u.low$，其中$u$是的$v$子级。计算$v.low$顶点的次数是线性的。顶点度数之和是边数的两倍，因此总运行时间为$O(E)$。</p>
<p>**D.**首先应用部分（C）$O(E)$的算法来计算$v.low$所有$v \in V$。如果$v.low$=$v.d$当且仅当的$v$后代都不具有的正确祖先$v$的后边缘时，当且仅当$v$不是关节点时。</p>
<p>因此，我们只需要检查$v.low$与$v.d$在恒定时间内决定是否$v$是一个关节点，所以运行时是$O(E)$。</p>
<p>**E.**一条边$(u, v)$位于一个简单圈上，当且仅当至少存在一条从$u$到$v$的路径不包含该边$(u, v)$，当且仅当移除$(u, v)$不会断开图，当且只当$(u, v)$不是桥。</p>
<p>**F.**一条边$(u, v)$位于无向图中的一个简单圈上，当且仅当它的两个端点都是关节点，或者它的一个端点是关节点，另一个端点是度$1$顶点。还有一种特殊情况，即只有一条边的关联顶点都是度$1$。我们可以在恒定时间内检查这种情况。由于我们可以计算中的$O(E)$所有关节点，并且我们可以在常数时间内确定顶点是否具有度数$1$，因此我们可以运行部分（d）中的算法，然后在常数时间内确定每条边是否是桥，这样我们就可以及时找到所有的$O(E)$桥。</p>
<p>**G.**很明显，每个非桥边都在某个双连通分量中，因此我们需要证明如果$C_1$和$C_2$是不同的双连通分量，则它们不包含公共边。相反，假设$(u, v)$在$C_1$和$C_2$中都有。</p>
<p>设$(a, b)$为中的$C_1$任意边，且$(c, d)$为中的$C_2$任意边。</p>
<p>然后$(a, b)$位于一个简单的循环$(u, v)$上，由路径组成</p>
<p>$$a, b, p_1, \ldots, p_k, u, v, p_{k + 1}, \ldots, p_n, a.$$</p>
<p>Similarly, $(c, d)$ lies on a simple cycle with $(u, v)$ consisting of the path</p>
<p>$$C，d，Q_1，\ldots，Q_m，u，V，Q_{m+1}，\ldots，Q_l，C.$$</p>
<p>这意味着</p>
<p>$$a, b, p_1, \ldots, p_k, u, q_m, \ldots, q_1, d, c, q_l , \ldots, q_{m + 1}, v, p_{k + 1}, \ldots, p_n,$$</p>
<p>是一个包含$(a, b)$和$(c, d)$的简单循环，是一个矛盾。因此，双连接组件形成了一个分区。</p>
<p>使用部分（f）中描述的算法及时**H.**定位所有桥边缘$O(E)$。从中$E$删除每个网桥。双连通组件现在只是连通组件中的边。假设已经这样做了，运行下面的算法，该算法显然在中$O(|E|)$运行，其中$|E|$是最初在中$G$的边数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VISIT-<span class="built_in">BCC</span>(G, u, k)</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">for</span> each v ∈ G.Adj[u]</span><br><span class="line">        (u, v).bcc = k</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            VISIT-<span class="built_in">BCC</span>(G, v, k)</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>强连通有向图$G = (V, E)$**<em>欧拉之旅</em>**中的圈是恰好遍历每个边一次的$G$圈，尽管它可能不止一次访问一个顶点。</p>
<p>当且仅当$\text{in-degree}(v) = \text{out-degree}(v)$对于每个顶点$v \in V$，**A.**显示$G$具有 Euler 环游。</p>
<p><strong>乙。</strong>描述一个$O(E)$时间算法来查找 Euler 路径$G$（如果存在）。（$\textit{提示：}$merge edge-disjoint cycles.）</p>
</blockquote>
<p>**A.**首先，我们将证明每个顶点的入度必须等于出度。假设有一个顶点 V，这两个顶点不相等，假设$\text{in-degree}(v) - \text{out-degree}(v)$。请注意，我们可以假设 In 度更大，否则我们只需查看向后遍历循环的转置图。如果$v$是列出的循环的开始，只需将开始和结束顶点移动到循环上的任何其他顶点。然后，在我们进行$v$的任何循环中，我们必须通过$v$一定的次数，特别是，在我们通过一次之后，未使用的边的数量$v$为零，然而，仍然有未使用的边需要使用。这意味着没有希望使用这些，而仍然是一个旅游，因为我们将永远无法逃脱$v$，并回到旅游开始的顶点。现在，我们证明了每个顶点的入度和出度相等就足够了。为了做到这一点，我们将把问题稍微一般化，以便它更适合于归纳方法。也就是说，我们将证明，对于每个有两个顶点$v$的图$G$，并且$u$所有顶点都有相同的入度和出度，除了入度比出度大$u$一，$v$那么就有一条从$v$到$u$的欧拉路径。如果我们选择$u = v$图中的任何顶点，这显然与原始语句一致。我们现在对边的数量进行归纳。如果只有一条边，那么只取这条边就是欧拉之旅。然后，假设我们从$v$它开始，并取它的任何边。考虑通过移除该边而获得的图，它归纳地包含一个欧拉路径，我们可以将其后挂到我们要离开$v$的边。</p>
<p><strong>乙。</strong>为了真正得到欧拉回路，我们可以任意走任何我们想走的路，只要我们不重复一条边，我们就一定会得到一个有效的欧拉回路。这是在下面的算法中实现的，$\text{EULER-TOUR}(G)$这需要时间$O(|E|)$。它之所以有这样的运行时间，是因为 for 循环将为每条边运行，并且需要恒定的时间量。此外，初始化每个边的颜色的过程将花费与边的数量成比例的时间。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EULER-<span class="built_in">TOUR</span>(G)</span><br><span class="line">    <span class="function">color all edges WHITE</span></span><br><span class="line"><span class="function">    <span class="title">let</span> <span class="params">(v, u)</span> be any edge</span></span><br><span class="line"><span class="function">    let L be a list containing v</span></span><br><span class="line"><span class="function">    <span class="keyword">while</span> there is some WHITE <span class="title">edge</span> <span class="params">(v, w)</span> coming out of v</span></span><br><span class="line"><span class="function">        <span class="title">color</span> <span class="params">(v, w)</span> BLACK</span></span><br><span class="line"><span class="function">        v </span>= w</span><br><span class="line">        append v to L</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>设$G = (V, E)$是一个有向图，其中每个顶点$u \in V$都标有集合$\{1, 2, \ldots, |V|\}$中的唯一整数$L(U)$。对于每个顶点$u \in V$，设$R(u) = \{v \in V: u \leadsto v \}$为可到达$u$的顶点的集合。定义$\min(u)$为标签最小的顶点$R(u)$，即，$\min(u)$是满足以下条件$L(v) = \min \{L(w): w \in R(u) \}$的顶点$v$。给出$O(V + E)$计算$\min(u)$所有顶点$u \in V$的时间算法。</p>
</blockquote>
<p>**1.**计算分量图$G^{\text{SCC}}$（以便从图$G$中删除简单圈），并用其中$G^{\text{SCC}}$顶点的最小标签标记中的$G^{\text{SCC}}$每个顶点。根据第 22.5 章，该过程的时间复杂度为$O(V + E)$。</p>
<p>**2.**在上$G^{\text{SCC}}$，执行以下算法。请注意，如果我们记住这个函数，它将在大多数$V + E$情况下被调用。其时间复杂度也$O(V + E)$是。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">REACHABILITY</span>(u)</span><br><span class="line">    u.min = u.label</span><br><span class="line">    <span class="keyword">for</span> each v ∈ Adj[u]</span><br><span class="line">        u.min = <span class="built_in">min</span>(u.min, <span class="built_in">REACHABILITY</span>(v))</span><br><span class="line">    <span class="keyword">return</span> u.min</span><br></pre></td></tr></tbody></table></figure>

<p>**3.**回到 Graph$G$，On Graph$G$的$\min(u)$值是 On Graph$G^{\text{SCC}}$的$\min(u.scc)$值。</p>
<p><strong>替代解决方案：</strong>转置图形。调用$\text{DFS}$，但在的$\text{DFS}$主循环中，按顶点的标签顺序考虑顶点。$\text{DFS-VISIT}$在子例程中，在发现新节点时，我们将其$\text{min}$设置为其根的标签。</p>
<h2 id="22-1-1"><a href="#22-1-1" class="headerlink" title="22.1-1"></a>22.1-1</h2><blockquote>
<p>给定一个有向图的邻接表表示，计算每个顶点的$\text{out-degree}$需要多长时间？计算$\text{in-degree}$S 需要多长时间？</p>
</blockquote>
<ul>
<li><p>计算每个顶点的$\text{out-degree}$时间为</p>
<p>  $$\sum_{v \in V}O(\text{out-degree}(v)) = O(|E| + |V|),$$</p>
<p>  这很显然</p>
</li>
<li><p>至于$\text{in-degree}$,我们必须扫描所有邻接表，并记录每个顶点被指向的次数。因此，时间复杂度也是 $O(|E|+|V|)$，因为我们要访问所有节点和边。</p>
</li>
</ul>
<h2 id="22-1-2"><a href="#22-1-2" class="headerlink" title="22.1-2"></a>22.1-2</h2><blockquote>
<p>给出一棵顶点为 $7$ 的完整二叉树的邻接表。给出等价的邻接矩阵表示法。假设顶点的编号从$1$到$7$，就像二叉堆一样。</p>
</blockquote>
<ul>
<li><p><strong>Adjacency-list representation</strong></p>
<p>  $$<br>  \begin{aligned}<br>  1 &amp; \to 2 \to 3 \\<br>  2 &amp; \to 1 \to 4 \to 5 \\<br>  3 &amp; \to 1 \to 6 \to 7 \\<br>  4 &amp; \to 2 \\<br>  5 &amp; \to 2 \\<br>  6 &amp; \to 3 \\<br>  7 &amp; \to 3<br>  \end{aligned}<br>  $$</p>
</li>
<li><p><strong>Adjacency-matrix representation</strong></p>
<p>  $$<br>  \begin{array}{c|ccccccc|}<br>&amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 \\<br>  \hline<br>  1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  2 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\<br>  3 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\<br>  4 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  5 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  6 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  7 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  \hline<br>  \end{array}<br>  $$</p>
</li>
</ul>
<h2 id="22-1-3"><a href="#22-1-3" class="headerlink" title="22.1-3"></a>22.1-3</h2><blockquote>
<p>有向图$G = (V, E)$的**<em>转置</em>**是图$G^\text T = (V, E^\text T)$，其中$E^\text T = \{(v, u) \in V \times V: (u, v) \in E \}$。因此，$G^\text T$它$G$的所有边都颠倒了。描述从$G$计算$G^\text T$的有效算法，用于的$G$邻接表和邻接矩阵表示。分析算法的运行时间。</p>
</blockquote>
<ul>
<li><p><strong>邻接表表示</strong></p>
<p>  假设原始邻接表为$Adj$。</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let Adj<span class="number">'</span>[<span class="number">1.</span>.|V|] be a <span class="keyword">new</span> adjacency list of the transposed G^T</span><br><span class="line"><span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ Adj[u]</span><br><span class="line">        <span class="built_in">INSERT</span>(Adj<span class="number">'</span>[v], u)</span><br></pre></td></tr></tbody></table></figure>

<p>  时间复杂度：$O(|E| + |V|)$。</p>
</li>
<li><p><strong>邻接矩阵表示</strong></p>
<p>  通过查看对角线上方的每个条目，并将其与对角线下方出现的条目交换，来转置原始矩阵。</p>
<p>  时间复杂度：$O(|V|^2)$。</p>
</li>
</ul>
<h2 id="22-1-4"><a href="#22-1-4" class="headerlink" title="22.1-4"></a>22.1-4</h2><blockquote>
<p>给定多重图$G = (V, E)$的邻接表表示，描述$O(V + E)$计算“等价”无向图的邻接表表示的时间算法$G’ = (V, E’)$，其中$E’$由两个顶点之间的所有多条边替换为一条边并删除所有自环的边$E$组成。</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EQUIVALENT-UNDIRECTED-GRAPH</span><br><span class="line">    let Adj<span class="number">'</span>[<span class="number">1.</span>.|V|] be a <span class="keyword">new</span> adjacency list</span><br><span class="line">    let A be a <span class="number">0</span>-initialized array of size |V|</span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        <span class="keyword">for</span> each v ∈ Adj[u]</span><br><span class="line">            <span class="keyword">if</span> v != u &amp;&amp; A[v] != u</span><br><span class="line">                A[v] = u</span><br><span class="line">                <span class="built_in">INSERT</span>(Adj<span class="number">'</span>[u], v)</span><br></pre></td></tr></tbody></table></figure>

<p>请注意$A$，在内部 for 循环的每次迭代之前，不包含任何具有值$u$的元素。这就是为什么我们使用$A[v] = u$在内部 for 循环中标记边$(u, v)$的存在。因为我们在邻接表$Adj$$|V| + |E|$中查找时间，所以时间复杂度是$O(|V| + |E|)$。</p>
<h2 id="22-1-5"><a href="#22-1-5" class="headerlink" title="22.1-5"></a>22.1-5</h2><blockquote>
<p>有向图$G = (V, E)$的**<em>正方形</em>**是使得$(u, v) \in E^2$当且仅当$G$包含一条在和$v$之间最多有两条边$u$的路的图$G^2 = (V, E^2)$。描述计算$G^2$$G$的邻接表和邻接矩阵表示的$G$有效算法。分析算法的运行时间。</p>
</blockquote>
<ul>
<li><p><strong>邻接表表示</strong></p>
<p>  为了从的$G$邻接表表示$Adj$进行计算$G^2$，我们对每个$Adj[u]$执行以下操作：</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each v ∈ Adj[u]</span><br><span class="line">    <span class="built_in">INSERT</span>(Adj2[u], v)</span><br><span class="line">    <span class="keyword">for</span> each w ∈ Adj[v]</span><br><span class="line">        <span class="comment">// edge(u, w) ∈ E^2</span></span><br><span class="line">        <span class="built_in">INSERT</span>(Adj2[u], w)</span><br></pre></td></tr></tbody></table></figure>

<p>  其中$Adj2$是的$G^2$邻接表表示。对于我们扫描的最多$|V|$顶点中的$Adj$每条边，我们及时$O(|V||E|)$计算$Adj2$。</p>
<p>  在我们计算$Adj2$之后，我们必须从列表中删除重复的边。删除重复的边是在中完成$O(V + E’)$的，其中$E’ = O(VE)$是中$Adj2$的边数，如练习 22.1-4 所示。因此，总运行时间为</p>
<p>  $$O（VE）+O（V+VE）=O（VE）。$$</p>
<p>  但是，如果原始图$G$包含自环，我们应该修改算法，以便不删除自环。</p>
</li>
<li><p><strong>邻接矩阵表示</strong></p>
<p>  设$A$表示的$G$邻接矩阵表示。的邻接矩阵表示$G^2$是的$A$平方。计算$A^2$可以及时$O(V^3)$完成（理论上甚至更快；例如，Strassen 的算法将在中$O(V^{\lg 7})$计算$A^2$。</p>
</li>
</ul>
<h2 id="22-1-6"><a href="#22-1-6" class="headerlink" title="22.1-6"></a>22.1-6</h2><blockquote>
<p>大多数将邻接矩阵表示作为输入的图算法都需要时间$\Omega(V^2)$，但也有一些例外。展示如何确定一个有向图$G$是否包含**<em>通用水槽</em>**$-$一个在时间上$O(V)$具有$\text{in-degree}$$|V| - 1$和$\text{out-degree}$$0$$-$的顶点，给定一个邻接矩阵$G$。</p>
</blockquote>
<p>从检查邻接矩阵中的位置$(1, 1)$开始。当检查位置$(i, j)$时，</p>
<ul>
<li>如果遇到 A$1$，则检查位置$(i + 1, j)$，并</li>
<li>如果$0$遇到，请检查位置$(i, j + 1)$。</li>
</ul>
<p>一旦或$i$$j$等于$|V|$，则终止。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IS-CONTAIN-UNIVERSAL-<span class="built_in">SINK</span>(M)</span><br><span class="line">    i = j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; |V| <span class="keyword">and</span> j &lt; |V|</span><br><span class="line">        <span class="comment">// There's an out-going edge, so examine the next row</span></span><br><span class="line">        <span class="keyword">if</span> M[i, j] == <span class="number">1</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="comment">// There's no out-going edge, so see if we could reach the last column of current row</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> M[i, j] == <span class="number">0</span></span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">    check <span class="keyword">if</span> vertex i is a universal sink</span><br></pre></td></tr></tbody></table></figure>

<p>如果一个图包含一个通用汇点，那么它一定在顶点$i$。</p>
<p>为了看到这一点，假设顶点$k$是一个通用汇点。因为$k$是一个通用接收器，所以行$k$将用$0$“S ”填充，列$k$将用$1$“S ”填充，除了用“A$0$”填充的$M[k, k]$。最后，一旦行$k$被命中，算法将继续增加列$j$，直到$j = |V|$。</p>
<p>为了确保最终命中行$k$，请注意，一旦到达列$k$，算法将继续递增$i$，直到到达为止$k$。</p>
<p>该算法在中$O(V)$运行，并在中$O(V)$检查顶点$i$是否为通用接收器。因此，总运行时间为$O(V) + O(V) = O(V)$。</p>
<h2 id="22-1-7"><a href="#22-1-7" class="headerlink" title="22.1-7"></a>22.1-7</h2><blockquote>
<p>没有自环的有向图$G = (V, E)$的**<em>关联矩阵</em>**是一个$|V| \times |E|$矩阵$B = (b_{ij})$，使得</p>
<p>$$<br>b_{ij} =<br>\begin{cases}<br>-1 &amp; \text{if edge $j$ leaves vertex $i$}, \\<br> 1 &amp; \text{if edge $j$ enters vertex $i$}, \\<br> 0 &amp; \text{otherwise}.<br>\end{cases}<br>$$</p>
<p>描述矩阵乘积$BB^\text T$的元素表示什么，其中$B^\text T$是的$B$转置。</p>
</blockquote>
<p>$$BB^\text T(i, j) = \sum\limits_{e \in E}b_{ie} b_{ej}^\text T = \sum\limits_{e \in E} b_{ie}b_{je}.$$</p>
<ul>
<li>If $i = j$, then $b_{ie} b_{je} = 1$ (it is $1 \cdot 1$ or $(-1) \cdot (-1)$) whenever $e$ enters or leaves vertex $i$, and $0$ otherwise.</li>
<li>If $i \ne j$, then $b_{ie} b_{je} = -1$ when $e = (i, j)$ or $e = (j, i)$, and $0$ otherwise.</li>
</ul>
<p>Thus,</p>
<p>$$<br>BB^\text{T}(i, j) =<br>\begin{cases}<br>\text{degree of } i = \text{in-degree} + \text{out-degree} &amp; \text{if } i = j, \\<br>-\text{(number of edges connecting } i \text{ and } j) &amp; \text{if } i \ne j.<br>\end{cases}<br>$$</p>
<h2 id="22-1-8"><a href="#22-1-8" class="headerlink" title="22.1-8"></a>22.1-8</h2><blockquote>
<p>假设每个数组条目$Adj[u]$不是链表，而是包含顶点$v$的哈希表$(u, v) \in E$。如果所有边查找的可能性相等，则确定边是否在图中的预期时间是多少？这个方案有什么缺点？为解决这些问题的每个边列表建议一个替代数据结构。与哈希表相比，你的替代方案是否有缺点？</p>
</blockquote>
<p>预期的查找时间为$O(1)$，但在最坏的情况下可能需要$O(|V|)$。</p>
<p>如果我们首先对每个邻接表中的顶点进行排序，则我们可以执行二分搜索，以便最坏情况的查找时间为$O(\lg |V|)$，但这具有更差的预期查找时间的缺点。</p>
<h2 id="22-2-1"><a href="#22-2-1" class="headerlink" title="22.2-1"></a>22.2-1</h2><blockquote>
<p>使用顶点$3$作为源，显示在图 22.2（a）的有向图上运行宽度优先搜索得到的$d$和$\pi$值。</p>
</blockquote>
<p>$$<br>\begin{array}{c|cccccc}<br>\text{vertex} &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\<br>\hline<br>d &amp; \infty &amp; 3 &amp; 0 &amp; 2 &amp; 1 &amp; 1 \\<br>\pi &amp; \text{NIL} &amp; 4 &amp; \text{NIL} &amp; 5 &amp; 3 &amp; 3<br>\end{array}<br>$$</p>
<h2 id="22-2-2"><a href="#22-2-2" class="headerlink" title="22.2-2"></a>22.2-2</h2><blockquote>
<p>使用顶点$u$作为源，显示在图 22.3 的无向图上运行宽度优先搜索得到的$d$和$\pi$值。</p>
</blockquote>
<p>$$<br>\begin{array}{c|cccccc}<br>\text{vertex} &amp; r &amp; s &amp; t &amp; u &amp; v &amp; w &amp; x &amp; y \\<br>\hline<br>d &amp; 4 &amp; 3 &amp; 1 &amp; 0 &amp; 5 &amp; 2 &amp; 1 &amp; 1 \\<br>\pi &amp; s &amp; w &amp; u &amp; \text{NIL} &amp; r &amp; t &amp; u &amp; u<br>\end{array}<br>$$</p>
<h2 id="22-2-3"><a href="#22-2-3" class="headerlink" title="22.2-3"></a>22.2-3</h2><blockquote>
<p>通过论证如果删除第 5 行和第 14 行，该$\text{BFS}$过程将产生相同的结果，表明使用单个位来存储每个顶点颜色就足够了。</p>
</blockquote>
<p>出于教学目的，教科书引入了$\text{GRAY}$颜色，以区分$\text{GRAY}$节点（入队）和$\text{BLACK}$节点（出队）。</p>
<p>因此，使用单个位来存储每个顶点颜色就足够了。</p>
<h2 id="22-2-4"><a href="#22-2-4" class="headerlink" title="22.2-4"></a>22.2-4</h2><blockquote>
<p>如果我们用邻接矩阵来表示它的输入图，并修改算法来处理这种形式的输入，那么它的运行时间$\text{BFS}$是多少？</p>
</blockquote>
<p>迭代所有边的时间变为$O(V^2)$$O(E)$。因此，运行时间为$O(V + V^2) = O(V^2)$。</p>
<h2 id="22-2-5"><a href="#22-2-5" class="headerlink" title="22.2-5"></a>22.2-5</h2><blockquote>
<p>论证在广度优先搜索中，分配给顶点$u$的值$u.d$与顶点在每个邻接表中出现的顺序无关。以图 22.3 为例，说明由$\text{BFS}$计算的宽度优先树可以依赖于邻接表中的排序。</p>
</blockquote>
<p>首先，我们将展示分配给顶点的值$d$与条目在邻接表中出现的顺序无关。为了证明这一点，我们依赖于定理 22.5，它证明了的$\text{BFS}$正确性。特别地，该定理指出，$v.d = \delta(s, v)$在的$\text{BFS}$终止处。因为$\delta(s, v)$是基础图的属性，所以对于图的任何邻接表表示（包括邻接表的任何重新排序），$\delta(s, v)$都不会改变。由于这些$d$值对于邻接表的任何排序都是相等$\delta(s, v)$的并且$\delta(s, v)$是不变的，$d$因此也不依赖于邻接表的排序。</p>
<p>现在，为了说明这$\pi$确实依赖于邻接表的排序，我们将使用图 22.3 作为指导。</p>
<p>首先，我们注意到，在给定的计算过程中，我们在邻接表$w$中有，$t$在前面$x$。此外，在制定的程序中，我们有$u.\pi = t$。</p>
<p>现在，假设我们在的$w$邻接表中有$x$前导$t$。然后，它将被添加到队列之前$t$，这意味着在我们有机会处理的子代$t$之前，它将$u$作为它的子代。这将意味着$u.\pi = x$在邻接表$w$的这种不同排序中。</p>
<h2 id="22-2-6"><a href="#22-2-6" class="headerlink" title="22.2-6"></a>22.2-6</h2><blockquote>
<p>给出一个有向图$G = (V, E)$的例子，一个源顶点$s \in V$和一组树边$E_\pi \subseteq E$，使得对于每个顶点$v \in V$，图$(V, E_\pi)$中从$s$到$v$的唯一简单路径是中$G$的最短路径，但无论顶点在每个邻接表中如何排序，都不能通过运行$\text{BFS}$$G$产生边$E_\pi$的集合。</p>
</blockquote>
<p>设$G$为第一幅图中所示的图形，$G_\pi = (V, E_\pi)$为第二幅图中所示的图形，$s$为源顶点。</p>
<p>我们可以看到，$E_\pi$在上$G$运行 BFS 将永远不会产生。</p>
<center>
![](../img/22.2-6-2.png) ![](../img/22.2-6-1.png)
</center>

<ul>
<li>如果$y$在中$Adj[s]$位于前面$v$。我们将在之前$v$离开队列$y$，所以$u.\pi$和$x.\pi$都$y$是。然而，事实并非如此。</li>
<li>如果$v$在$Adj[s]$前面$y$。我们将在之前$y$出队$v$，所以$u.\pi$和$x.\pi$都$v$是，这也是不正确的。</li>
</ul>
<p>尽管如此，中$G_\pi$从$s$到任何顶点的唯一简单路径是中的$G$最短路径。</p>
<h2 id="22-2-7"><a href="#22-2-7" class="headerlink" title="22.2-7"></a>22.2-7</h2><blockquote>
<p>职业摔跤手有两种类型：“娃娃脸”（“好人”）和“高跟鞋”（“坏人”）。在任何一对职业摔跤手之间，可能有也可能没有竞争。假设我们有$n$职业摔跤手，我们有一$r$组有竞争关系的摔跤手。给出一个$O(n + r)$时间算法，该算法确定是否可以将一些摔跤手指定为娃娃脸，而将其余的摔跤手指定为脚跟，以便每次比赛都是在娃娃脸和脚跟之间进行。如果有可能执行这样的指定，你的算法应该产生它。</p>
</blockquote>
<p>这个问题基本上只是两种颜色的混淆版本。我们将尝试用“娃娃脸”和“脚跟”这两种颜色来给这张竞争图的顶点着色。没有两个娃娃脸和两个高跟鞋有竞争，就等于说颜色是合适的。对于两种颜色，我们对每个连通分量执行广度优先搜索，以获得每个顶点的$d$值。然后，我们给所有的奇数一个颜色说“脚跟”，所有的偶数 d 值一个不同的颜色。我们知道，在这个着色失败的地方，没有其他着色会成功，因为如果我们给出任何其他着色，我们会得到一个顶点$v$具有相同的颜色，$v.\pi$$v$并且$v.\pi$它们的$d$值必须具有不同的奇偶性。因为我们知道没有更好的着色，所以我们只需要检查每条边，看看这种着色是否有效。如果每条边都能正常工作，则可以找到一个指定，如果单个边失败，则不可能找到指定。由于 BFS$O(n + r)$和检查都需要$O(r)$时间，因此总运行时间为$O(n + r)$。</p>
<h2 id="22-2-8-star"><a href="#22-2-8-star" class="headerlink" title="22.2-8$\star$"></a>22.2-8$\star$</h2><blockquote>
<p>树$T = (V, E)$的**<em>直径</em>**定义为$\max_{u,v \in V} \delta(u, v)$，即，树中所有最短路径距离中的最大值。给出一个计算树直径的有效算法，并分析该算法的运行时间。</p>
</blockquote>
<p>假设 A 和 B 是树中达到直径的路径的端点，并且不失一般性地假设$a$和$b$是达到直径的唯一对。设$s$为中的$T$任意顶点。我们声称，一个单一$\text{BFS}$的结果将返回一个$a$或$b$（或两者）作为距离$s$最大的顶点。</p>
<p>为了看到这一点，假设与此相反，另一个顶点$x$显示为最远$s$。（请注意，$x$不能在从$a$到$b$的路径上，否则我们可以扩展）。那我们有</p>
<p>$$d(s, a) &lt; d(s, x)$$</p>
<p>and</p>
<p>$$d（s，B） &lt;d（s，X）。$$</p>
<p>让$c$表示从$a$到$b$最小化$d(s, c)$的路径上的顶点。既然图实际上是一棵树，我们必须有</p>
<p>$$d(s, a) = d(s, c) + d(c, a)$$</p>
<p>and</p>
<p>$$D（S，B）=D（S，C）+D（C，B）。$$</p>
<p>（如果有另一条路，我们可以形成一个循环）。利用上面提到的三角不等式、不等式和等式，我们必须</p>
<p>$$<br>\begin{aligned}<br>d(a, b) + 2d(s, c) &amp; = d(s, c) + d(c, b) + d(s, c) + d(c, a) \\<br>                   &amp; &lt; d(s, x) + d(s, c) + d(c, b).<br>\end{aligned}<br>$$</p>
<p>我声称$d(x, b) = d(s, x) + d(s, b)$。如果不是，那么根据三角不等式，我们必须有一个严格的小于。换句话说，有一些从$x$到$b$的路径没有经过$c$。这给出了矛盾，因为它意味着存在通过连接这些路径而形成的循环。那我们有</p>
<p>$$d（a，B） &lt;d（a，B）+2D（s，C） &lt;d（X，B）。$$</p>
<p>因为假设$d(a, b)$在所有对中是最大的，所以我们有一个矛盾。因此，由于树有$|V| - 1$边，我们可以运行$\text{BFS}$一次$O(V)$来获得其中一个顶点，该顶点是图中包含的最长简单路径的端点。再次运行$\text{BFS}$将告诉我们另一个在哪里，这样我们就可以解决树$O(V)$的直径问题。</p>
<h2 id="22-2-9"><a href="#22-2-9" class="headerlink" title="22.2-9"></a>22.2-9</h2><blockquote>
<p>设$G = (V, E)$是一个连通的无向图。给出一个$O(V + E)$时间算法来计算一条路径$G$，该路径在每个方向上恰好遍历每条边$E$一次。描述一下，如果给你大量的便士，你如何能找到走出迷宫的路。</p>
</blockquote>
<p>首先，该算法计算图的最小生成树。请注意，这可以使用第 23 章的程序来完成。也可以通过执行广度优先搜索，并限制到和$v.\pi$之间$v$的边缘来完成$v$。为了避免重复计算边，请事先确定顶点的顺序$\le$。然后，我们将通过调用$\text{MAKE-PATH}(s)$构造步骤序列，其中$s$是用于$\text{BFS}$的根。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MAKE-<span class="built_in">PATH</span>(u)</span><br><span class="line">    <span class="keyword">for</span> each v ∈ Adj[u] but <span class="keyword">not</span> in the tree such that u ≤ v</span><br><span class="line">        go to v <span class="keyword">and</span> back to u</span><br><span class="line">    <span class="keyword">for</span> each v ∈ Adj[u] but <span class="keyword">not</span> equal to u.π</span><br><span class="line">        go to v</span><br><span class="line">        perform the path proscribed by MAKE-<span class="built_in">PATH</span>(v)</span><br><span class="line">    go to u.π</span><br></pre></td></tr></tbody></table></figure>

<h2 id="22-3-1"><a href="#22-3-1" class="headerlink" title="22.3-1"></a>22.3-1</h2><blockquote>
<p>使用行和列标签$\text{WHITE}$、$\text{GRAY}$和$\text{BLACK}$制作$3$-by-$3$ 图表。在每个单元$(i, j)$中，指示在有向图的深度优先搜索期间的任何点处，是否可以存在从颜色$i$顶点到颜色$j$顶点的边。对于每个可能的边，指出它可以是什么类型的边。为无向图的深度优先搜索制作第二个这样的图表。</p>
</blockquote>
<p>根据定理 22.7（括号定理），顶点$u$间隔与$v$的关系有 3 种情况：</p>
<ul>
<li>$[u.d, u.f]$并且$[v.d, v.f]$是完全分离的，</li>
<li>$[u.d, u.f] \subset [v.d, v.f]$，以及</li>
<li>$[v.d, v.f] \subset [u.d, u.f]$。</li>
</ul>
<p>我们根据这个定理来判断可能性。</p>
<ul>
<li><p>对于<strong>有向图</strong>，我们可以使用练习 22.3-5 给出的边缘分类来简化问题。</p>
<p>  $$<br>  \begin{array}{c|ccc}<br>  from \diagdown to &amp; \text{WHITE}         &amp; \text{GRAY}                &amp; \text{BLACK} \\<br>  \hline<br>  \text{WHITE}      &amp; \text{All kinds}     &amp; \text{Cross, Back}         &amp; \text{Cross} \\<br>  \text{GRAY}       &amp; \text{Tree, Forward} &amp; \text{Tree, Forward, Back} &amp; \text{Tree, Forward, Cross} \\<br>  \text{BLACK}      &amp; -                    &amp; \text{Back}                &amp; \text{All kinds}<br>  \end{array}<br>  $$</p>
</li>
<li><p>对于<strong>无向图</strong>，从有向图开始，我们移除前向边和交叉边，并且</p>
<ul>
<li>当存在后边缘时，我们添加树边缘；</li>
<li>当一条树边存在时，我们添加一条后边。</li>
</ul>
<p>  这是正确的，原因如下：</p>
<ol>
<li>定理 22.10：在无向图$G$的深度优先搜索中，的$G$每条边要么是树，要么是后边。所以只有树和后沿。</li>
<li>如果$(u, v)$从$u$的角度看是一条树边，$(u, v)$那么从$v$的角度看也是一条后边。</li>
</ol>
<p>  $$<br>  \begin{array}{c|ccc}<br>  from \diagdown to &amp; \text{WHITE}      &amp; \text{GRAY}       &amp; \text{BLACK} \\<br>  \hline<br>  \text{WHITE}      &amp; -                 &amp; \text{Tree, Back} &amp; \text{Tree, Back} \\<br>  \text{GRAY}       &amp; \text{Tree, Back} &amp; \text{Tree, Back} &amp; \text{Tree, Back} \\<br>  \text{BLACK}      &amp; \text{Tree, Back} &amp; \text{Tree, Back} &amp; -<br>  \end{array}<br>  $$</p>
</li>
</ul>
<h2 id="22-3-2"><a href="#22-3-2" class="headerlink" title="22.3-2"></a>22.3-2</h2><blockquote>
<p>在图 22.6 中显示深度优先搜索是如何工作的。假设$\text{DFS}$过程的第 5-7 行的<strong>为了</strong>循环按字母顺序考虑顶点，并假设每个邻接表按字母顺序排序。显示每个顶点的发现和完成时间，并显示每条边的分类。</p>
</blockquote>
<p>下表给出了图中每个 Vetex 的发现时间和完成时间。</p>
<p>请参见<a target="_blank" rel="noopener" href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3.cpp">C++ demo</a>。</p>
<p>$$<br>\begin{array}{ccc}<br>\text{Vertex} &amp; \text{Discovered} &amp; \text{Finished} \\<br>\hline<br>q &amp;  1 &amp; 16 \\<br>r &amp; 17 &amp; 20 \\<br>s &amp;  2 &amp;  7 \\<br>t &amp;  8 &amp; 15 \\<br>u &amp; 18 &amp; 19 \\<br>v &amp;  3 &amp;  6 \\<br>w &amp;  4 &amp;  5 \\<br>x &amp;  9 &amp; 12 \\<br>y &amp; 13 &amp; 14 \\<br>z &amp; 10 &amp; 11<br>\end{array}<br>$$</p>
<ul>
<li><strong>树边缘：</strong> $(q, s)$，，，，，，，。$(s, v)$$(v, w)$$(q, t)$$(t, x)$$(x, z)$$(t, y)$$(r, u)$</li>
<li><strong>后边缘：</strong> $(w, s)$，，。$(z, x)$$(y, q)$</li>
<li><strong>前进边：</strong> $(q, w)$。</li>
<li><strong>交叉边缘：</strong> $(r, y)$，。$(u, y)$</li>
</ul>
<h2 id="22-3-3"><a href="#22-3-3" class="headerlink" title="22.3-3"></a>22.3-3</h2><blockquote>
<p>显示图 22.4 中深度优先搜索的括号结构。</p>
</blockquote>
<p>图 22.4 的深度优先搜索的括号结构是$(u(v(y(xx)y)v)u)(w(zz)w)$。</p>
<h2 id="22-3-4"><a href="#22-3-4" class="headerlink" title="22.3-4"></a>22.3-4</h2><blockquote>
<p>通过论证如果删除的$\text{DFS-VISIT}$第 3 行，该$\text{DFS}$过程将产生相同的结果，表明使用单个位来存储每个顶点颜色就足够了。</p>
</blockquote>
<p>将第 3 行更改为 <code>color = BLACK</code> 并删除第 8 行。然后，算法将产生相同的结果。</p>
<h2 id="22-3-5"><a href="#22-3-5" class="headerlink" title="22.3-5"></a>22.3-5</h2><blockquote>
<p>显示 Edge$(u, v)$为</p>
<p>**A.**树边或前向边当且仅当$u.d &lt; v.d &lt; v.f &lt; u.f$，</p>
<p><strong>乙。</strong>后边缘当且仅当$v.d \le u.d &lt; u.f \le v.f$，且</p>
<p>**C.**交叉边当且仅当$v.d &lt; v.f &lt; u.d &lt; u.f$。</p>
</blockquote>
<p><strong>A.</strong>$u$是的$v$祖先。</p>
<p><strong>乙。</strong>$u$是的$v$后代。</p>
<p>以前$u$<strong>C.</strong>$v$访问过。</p>
<h2 id="22-3-6"><a href="#22-3-6" class="headerlink" title="22.3-6"></a>22.3-6</h2><blockquote>
<p>证明在无向图中，根据在深度优先搜索期间是否$(u, v)$首先遇到或$(v, u)$将边$(u, v)$分类为树边或后边等价于根据分类方案中四种类型的顺序对其进行分类。</p>
</blockquote>
<p>根据定理 22.10，无向图的每条边要么是树边，要么是后边。首先，假设这$v$是通过探索边缘$(u, v)$首先发现的。那么根据定义，$(u, v)$是一条树边。而且，$(u, v)$一定是以前$(v, u)$发现过的，因为一旦$(v, u)$被探索，$v$就一定会被发现。现在假设它$v$不是第一个被发现$(u, v)$的。那么它必须被一些人$r\ne u$发现$(r, v)$。如果$u$还没有被发现，那么如果$(u, v)$首先被探索，它一定是一个后沿，因为$v$它是的$u$祖先。如果$u$已被发现，则$u$是的$v$祖先，因此$(v, u)$是后沿。</p>
<h2 id="22-3-7"><a href="#22-3-7" class="headerlink" title="22.3-7"></a>22.3-7</h2><blockquote>
<p>重写该过程$\text{DFS}$，使用堆栈来消除递归。</p>
</blockquote>
<p>请参见<a target="_blank" rel="noopener" href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-7/22.3-7.cpp">C++ demo</a>。</p>
<p>另外，请参阅本文<a target="_blank" rel="noopener" href="https://github.com/walkccc/CLRS/issues/329">issue</a>中的<a target="_blank" rel="noopener" href="https://github.com/i-to">@i-to</a>讨论。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DFS-<span class="built_in">STACK</span>(G)</span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.π = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE</span><br><span class="line">            DFS-VISIT-<span class="built_in">STACK</span>(G, u)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DFS-VISIT-<span class="built_in">STACK</span>(G, u)</span><br><span class="line">    S = Ø</span><br><span class="line">    <span class="built_in">PUSH</span>(S, u)</span><br><span class="line">    time = time + <span class="number">1</span>             <span class="comment">// white vertex u has just been discovered</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">while</span> !STACK-<span class="built_in">EMPTY</span>(S)</span><br><span class="line">        u = <span class="built_in">TOP</span>(S)</span><br><span class="line">        v = FIRST-WHITE-<span class="built_in">NEIGHBOR</span>(G, u)</span><br><span class="line">        <span class="keyword">if</span> v == NIL</span><br><span class="line">            <span class="comment">// u's adjacency list has been fully explored</span></span><br><span class="line">            <span class="built_in">POP</span>(S)</span><br><span class="line">            time = time + <span class="number">1</span></span><br><span class="line">            u.f = time</span><br><span class="line">            u.color = BLACK     <span class="comment">// blackend u; it is finished</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// u's adjacency list hasn't been fully explored</span></span><br><span class="line">            v.π = u</span><br><span class="line">            time = time + <span class="number">1</span></span><br><span class="line">            v.d = time</span><br><span class="line">            v.color = GRAY</span><br><span class="line">            <span class="built_in">PUSH</span>(S, v)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FIRST-WHITE-<span class="built_in">NEIGHBOR</span>(G, u)</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ G.Adj[u]</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">    <span class="keyword">return</span> NIL</span><br></pre></td></tr></tbody></table></figure>

<h2 id="22-3-8"><a href="#22-3-8" class="headerlink" title="22.3-8"></a>22.3-8</h2><blockquote>
<p>给出一个猜想的反例，如果一个有向图$G$包含一条从$u$到$v$的路径，并且如果$u.d &lt; v.d$在深度优先搜索$G$中，那么$v$在深度优先森林中产生的是的后代$u$。</p>
</blockquote>
<p>考虑一个图，其$3$顶点$u$为、$v$和$w$，边$(w, u)$为、$(u, w)$和$(w, v)$。假设$\text{DFS}$首先探索$w$，并且该$w$邻接表之前$v$有$u$。我们接下来发现$u$。唯一的相邻顶点是$w$，但$w$已经是灰色的，因此$u$完成。因为$v$还不是的后代$u$，并且$u$已经完成，所以$v$永远不能成为的$u$后代。</p>
<h2 id="22-3-9"><a href="#22-3-9" class="headerlink" title="22.3-9"></a>22.3-9</h2><blockquote>
<p>给出一个猜想的反例：如果一个有向图$G$包含一条从$u$到$v$的路径，那么任何深度优先搜索的结果都是$v.d \le u.f$。</p>
</blockquote>
<p>考虑顶点$\{1, 2, 3\}$上的有向图，并且具有边$(1, 2)$，$(1, 3)$$(2, 1)$则存在从$2$到$3$的路径。然而，如果我们在之前$3$开始一个$\text{DFS}$AT$1$和过程$2$，我们将得到$2.f = 3 &lt; 4 = 3.d$一个给定猜想的反例。</p>
<h2 id="22-3-10"><a href="#22-3-10" class="headerlink" title="22.3-10"></a>22.3-10</h2><blockquote>
<p>修改深度优先搜索的伪代码，以便打印出有向图$G$中的每条边及其类型。如果$G$是未定向的，则显示需要进行的修改（如果有）。</p>
</blockquote>
<p>如果$G$是非定向的，我们不需要做任何修改。</p>
<p>请参见<a target="_blank" rel="noopener" href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-10/22.3-10.cpp">C++ demo</a>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DFS-VISIT-<span class="built_in">PRINT</span>(G, u)</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ G.Adj[u]</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            print <span class="string">"(u, v) is a tree edge."</span></span><br><span class="line">            v.π = u</span><br><span class="line">            DFS-VISIT-<span class="built_in">PRINT</span>(G, v)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> v.color == GRAY</span><br><span class="line">            print <span class="string">"(u, v) is a back edge."</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> v.d &gt; u.d</span><br><span class="line">            print <span class="string">"(u, v) is a forward edge."</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            print <span class="string">"(u, v) is a cross edge."</span></span><br><span class="line">    u.color = BLACK</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time</span><br></pre></td></tr></tbody></table></figure>

<h2 id="22-3-11"><a href="#22-3-11" class="headerlink" title="22.3-11"></a>22.3-11</h2><blockquote>
<p>解释有向图的顶点$u$如何在深度优先树中结束，该树只$u$包含，即使$u$在中$G$既有传入边也有传出边。</p>
</blockquote>
<p>假设我们在顶点$\{1, 2, 3\}$上有一个有向图，并且有边$(1, 2)$和$(2, 3)$。然后，$2$具有传入边和传出边。</p>
<p>如果我们选择我们的第一个根$3$，那将是在它自己的$\text{DFS}$树上。然后，我们选择我们的第二个根$2$，因为它指向的唯一东西已经被标记了$\text{BLACK}$，我们不会探索它。然后，选择最后一个根$1$，我们不会破坏树中$\text{DFS}$的事实，$2$即使它既有传入边又有传出边$G$。</p>
<h2 id="22-3-12"><a href="#22-3-12" class="headerlink" title="22.3-12"></a>22.3-12</h2><blockquote>
<p>表明我们可以使用无向图$G$的深度优先搜索来识别的$G$连通分量，并且深度优先森林包含与$G$连通分量一样多的树。更准确地说，展示如何修改深度优先搜索，以便为每个顶点$v$分配一个介于和$k$之间的整数标签$v.cc$$1$，其中$k$是的连通分量$G$的数量，使得$u.cc = v.cc$当且仅当$u$和$v$在同一连通分量中。</p>
</blockquote>
<p>修改工作如下：每次<strong>如果</strong>在中$\text{DFS-CC}$满足第 8 行的-条件时，我们在森林中有一个树的新根，因此我们将其$cc$标签更新为新值$k$。在对$\text{DFS-VISIT-CC}$的递归调用中，我们总是更新后代的连通分量，使其与祖先的连通分量一致。</p>
<p>请参见<a target="_blank" rel="noopener" href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-12/22.3-12.cpp">C++ demo</a>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DFS-<span class="built_in">CC</span>(G)</span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.π = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    cc = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE</span><br><span class="line">            u.cc = cc</span><br><span class="line">            cc = cc + <span class="number">1</span></span><br><span class="line">            DFS-VISIT-<span class="built_in">CC</span>(G, u)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DFS-VISIT-<span class="built_in">CC</span>(G, u)</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ G.Adj[u]</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            v.cc = u.cc</span><br><span class="line">            v.π = u</span><br><span class="line">            DFS-VISIT-<span class="built_in">CC</span>(G, v)</span><br><span class="line">    u.color = BLACK</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time</span><br></pre></td></tr></tbody></table></figure>

<h2 id="22-3-13-star"><a href="#22-3-13-star" class="headerlink" title="22.3-13$\star$"></a>22.3-13$\star$</h2><blockquote>
<p>有向图$G = (V, E)$是指**<em>单连通的</em>**$u \leadsto v$对于所有顶点$u, v \in V$最多$G$包含一条从$u$到$v$的简单路径。给出了一个判定有向图是否单连通的有效算法。</p>
</blockquote>
<p>这是可以及时$O(|V||E|)$完成的。为此，首先执行顶点的拓扑排序。然后，我们将包含每个顶点的祖先$in\text-degree$$0$列表。我们按照从较早的顶点开始的拓扑顺序为每个顶点计算这些列表。</p>
<p>然后，如果我们曾经有一个顶点，在它的两个直接父节点的列表中出现了相同度数$0$的顶点，我们就知道这个图不是单连通的。然而，如果在每一步我们都有，在每一步所有的父节点都有不相交的度点集$0$作为祖先，则图是单连通的。由于对于每个顶点，所需的时间量受顶点数乘以特定顶点的$in\text-degree$限制，因此总运行时间受限制$O(|V||E|)$。</p>
<h2 id="22-4-1"><a href="#22-4-1" class="headerlink" title="22.4-1"></a>22.4-1</h2><blockquote>
<p>在练习 22.3-2 的假设下，显示在图 22.8 的 DAG 上运行时产生$\text{TOPOLOGICAL-SORT}$的顶点排序。</p>
</blockquote>
<p>我们表演的$\text{DFS}$开始和结束时间是</p>
<p>$$<br>\begin{array}{ccc}<br>\text{label} &amp; d &amp; f \\<br>\hline<br>m &amp; 1  &amp; 20 \\<br>q &amp; 2  &amp; 5  \\<br>t &amp; 3  &amp; 4  \\<br>r &amp; 6  &amp; 19 \\<br>u &amp; 7  &amp; 8  \\<br>y &amp; 9  &amp; 18 \\<br>v &amp; 10 &amp; 17 \\<br>w &amp; 11 &amp; 14 \\<br>z &amp; 12 &amp; 13 \\<br>x &amp; 15 &amp; 16 \\<br>n &amp; 21 &amp; 26 \\<br>o &amp; 22 &amp; 25 \\<br>s &amp; 23 &amp; 24 \\<br>p &amp; 27 &amp; 28<br>\end{array}<br>$$</p>
<p>因此，通过按完成时间的降序读取条目，我们得到了序列$p, n, o, s, m, r, y, v, x, w, z, u, q, t$。</p>
<h2 id="22-4-2"><a href="#22-4-2" class="headerlink" title="22.4-2"></a>22.4-2</h2><blockquote>
<p>给出一个线性时间算法，该算法将一个有向无环图$G = (V, E)$和两个顶点$s$和$t$作为输入，并返回中$G$从$s$到$t$的简单路径的数目。例如，图 22.8 的有向无环图恰好包含四条从顶点$p$到顶点$v: pov$的简单路径、$poryv$、$posryv$和$psryv$。（你的算法只需要计算简单路径，而不是列出它们。）</p>
</blockquote>
<p>该算法的工作原理如下。节点$u$的属性$u.paths$告诉从$u$到$v$的简单路径的数量，我们假设$v$在整个过程中是固定的。首先，应进行拓扑排序，并列出之间$u$的顶点，$v$如$\{v[1], v[2], \dots, v[k - 1]\}$。为了计算路径的数量，我们应该从$v$到$u$构造一个解决方案。让我们调用$u$AS$v[0]$和$v$AS$v[k]$，以避免重叠子问题，应该记住和$u$之间$v_k$的路径数量，并将其用作$k$减少到$0$。只有用这种方法我们才能解决这个问题$\Theta(V + E)$。</p>
<p>只有当图使用邻接矩阵时，自底向上的迭代版本才是可能的，因此$u$可以及时确定$O(1)$是否$v$邻接。但是建立一个邻接矩阵是要花钱$\Theta(|V|^2)$的，所以没关系。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-<span class="built_in">PATHS</span>(G, u, v)</span><br><span class="line">    TOPO-<span class="built_in">SORT</span>(G)</span><br><span class="line">    let {v[<span class="number">1</span>], v[<span class="number">2</span>]..v[k - <span class="number">1</span>]} be the vertex between u <span class="keyword">and</span> v</span><br><span class="line">    v[<span class="number">0</span>] = u</span><br><span class="line">    v[k] = v</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">0</span> to k - <span class="number">1</span></span><br><span class="line">        DP[j] = ∞</span><br><span class="line">    DP[k] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> SIMPLE-PATHS-<span class="built_in">AID</span>(G, DP, <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-PATHS-<span class="built_in">AID</span>(G, DP, i)</span><br><span class="line">    <span class="keyword">if</span> i &gt; k</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> DP[i] != ∞</span><br><span class="line">        <span class="keyword">return</span> DP[i]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       DP[i] = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> v[m] in G.adj[v[i]] <span class="keyword">and</span> <span class="number">0</span> &lt; m ≤ k</span><br><span class="line">            DP[i] += SIMPLE-PATHS-<span class="built_in">AID</span>(G, DP, m)</span><br><span class="line">       <span class="keyword">return</span> DP[i]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="22-4-3"><a href="#22-4-3" class="headerlink" title="22.4-3"></a>22.4-3</h2><blockquote>
<p>给出一个确定给定的无向图$G = (V, E)$是否包含圈的算法。你的算法应该及时运行$O(V)$，独立于$|E|$。</p>
</blockquote>
<p>无向图是无环的（即，一个森林）当且仅当DFS不产生后边缘。由于后边是深度优先树中连接顶点u和祖先v的边（u，v），所以没有后边意味着只有树的边，所以没有循环。</p>
<p>所以我们可以简单地运行DFS。如果找到一个后沿，则有一个循环。复杂度是O（V）而不是O（E + V）。既然有后沿，一定要先发现后看|V|明显的边缘这是因为在无环（无向）森林中，|E| ≤ |V|-1</p>
<h2 id="22-4-4"><a href="#22-4-4" class="headerlink" title="22.4-4"></a>22.4-4</h2><blockquote>
<p>证明或反驳：如果一个有向图$G$包含圈，那么$\text{TOPOLOGICAL-SORT}(G)$产生一个顶点排序，使与产生的排序不一致的“坏”边的数量最小化。</p>
</blockquote>
<p>这不是真的。考虑由顶点$a, b, c$和$d$组成的图$G$。假设边为$(a, b)$、$(b, c)$、$(a, d)$、$(d, c)$和$(c, a)$。假设我们从顶点$c$开始$\text{DFS}$$\text{TOPOLOGICAL-SORT}$。假设$b$在的$a$邻接表中出现在之前$d$，则完成时间从最晚到最早的顺序为$c, a, d, b$。</p>
<p>在这种情况下，“坏”边是$(b, c)$和$(d, c)$。然而，如果我们在$a, b, d, c$那时订购它们，唯一不好的边缘将是$(c, a)$。因此$\text{TOPOLOGICAL-SORT}$并不总是最小化“坏”边的数量。</p>
<h2 id="22-4-5"><a href="#22-4-5" class="headerlink" title="22.4-5"></a>22.4-5</h2><blockquote>
<p>在有向无环图$G = (V, E)$上执行拓扑排序的另一种方法是重复查找的$\text{in-degree}$$0$顶点，输出该顶点，并从图中删除该顶点及其所有引出边。解释如何实现这个想法，以便它及时$O(V + E)$运行。如果$G$有循环，这个算法会发生什么？</p>
</blockquote>
<p>首先，运行DFS或BFS来计算O（V+E）时间内每个点的进出，然后在删除边时维护此信息。每次输入为0的一条，点击删除边并保持信息，所以有E条边和V点，所以O（V）输出和O（E）删除。所以总的运行时间是O（V+E）。）</p>
<p>如果图有环，那么有时可能没有度数为零的点。</p>
<h2 id="22-5-1"><a href="#22-5-1" class="headerlink" title="22.5-1"></a>22.5-1</h2><blockquote>
<p>如果添加一条新边，图的强连通分支的数目如何改变？</p>
</blockquote>
<p>它可以保持不变，也可以减少。要了解保持不变的可能性，只需假设向循环添加一些边。为了看到减少是可能的，假设你的原始图在三个顶点上，并且只是一条通过所有顶点的路径，并且添加的边将这条路径完成为一个循环。要看到它不能增加，请注意添加边不能删除以前存在的任何路径。</p>
<p>因此，如果$u$和$v$在原始图中处于相同的连通分量中，则在两个方向上都存在从一个到另一个的路径。添加边不会干扰这两条路径，因此我们知道，$u$$v$添加边后，图中仍将保持不变$\text{SCC}$。由于没有组件可以分开，这意味着它们的数量不能增加，因为它们形成了顶点集合的划分。</p>
<h2 id="22-5-2"><a href="#22-5-2" class="headerlink" title="22.5-2"></a>22.5-2</h2><blockquote>
<p>在图 22.6 的图表上显示程序$\text{STRONGLY-CONNECTED-COMPONENTS}$如何工作。具体来说，显示第 1 行中计算的完成时间和第 3 行中生成的森林。假设的$\text{DFS}$第 5–7 行的循环按字母顺序考虑顶点，并且邻接表按字母顺序。</p>
</blockquote>
<p>在练习 22.3-2 中计算每个顶点的完成时间。这片森林由 5 棵树组成，每棵树都是一条链。我们将按从根到叶的顺序列出每棵树的顶点：$r$、$u$、$q - y - t$、$x - z$和$s - w - v$。</p>
<h2 id="22-5-3"><a href="#22-5-3" class="headerlink" title="22.5-3"></a>22.5-3</h2><blockquote>
<p>培根教授声称，如果在第二次深度优先搜索中使用原始（而不是转置）图，并按完成时间的_不断增加_顺序扫描顶点，则强连通分量的算法会更简单。这个更简单的算法总是产生正确的结果吗？</p>
</blockquote>
<p>培根教授的建议行不通。举个例子，假设我们的图在三个顶点$\{1, 2, 3\}$上，并且由边$(2, 1), (2, 3), (3, 2)$组成。然后，我们应该以$\{2, 3\}$和$\{1\}$作为我们$\text{SCC}$的结束。然而，可能$\text{DFS}$的开始时间$2$可以在之前$1$探索$3$，这将意味着的$3$完成时间低于$1$和$2$。这意味着当我们第一次执行$\text{DFS}$开始$3$时。但是，$\text{DFS}$从 AT$3$开始将能够到达所有其他顶点。这意味着算法将返回整个图是单个$\text{SCC}$的，尽管情况显然不是这样，因为既没有从$1$到$2$的路径，也没有从$1$到$3$的路径。</p>
<h2 id="22-5-4"><a href="#22-5-4" class="headerlink" title="22.5-4"></a>22.5-4</h2><blockquote>
<p>证明对于任何有向图$G$，我们有$((G^\text T)^{\text{SCC}})^\text T = G^{\text{SCC}}$。也就是说，的分量图$G^\text T$的转置与的分量图$G$相同。</p>
</blockquote>
<p>首先观察$C$是的$G$强连通分支当且仅当它是的$G^\text T$强连通分支。因此，和$(G^\text T)^{\text{SCC}}$的$G^{\text{SCC}}$顶点集是相同的，这意味着和$G^{\text{SCC}}$的$((G^\text T)^\text{SCC})^\text T$顶点集是相同的。这足以表明它们的边集是相同的。假设$(v_i, v_j)$是中的$((G^\text T)^{\text{SCC}})^\text T$一条边。然后$(v_j, v_i)$是边缘在$(G^\text T)^{\text{SCC}}$。因此，存在$x \in C_j$并且$y \in C_i$使得$(x, y)$是的$G^\text T$边，这意味着$(y, x)$是的$G$边。由于组件被保留，这意味着它$(v_i, v_j)$是中的$G^{\text{SCC}}$一条边。对于相反的含义，我们简单地注意到，对于我们拥有的$(G^\text T)^{\text T} = G$任何图$G$。</p>
<h2 id="22-5-5"><a href="#22-5-5" class="headerlink" title="22.5-5"></a>22.5-5</h2><blockquote>
<p>给出了$O(V + E)$计算有向图$G = (V, E)$的分量图的时间算法。确保算法生成的组件图中的两个顶点之间最多有一条边。</p>
</blockquote>
<p>首先执行STRONGLY-CONNECTED-COMPONENTS过程，然后在[1，k]中为每个节点分配一个值，即生成的k个强连通分量。第k个强连通分支中所有节点的值为k。然后遍历每个节点i，对于Adj[i]的每个节点j，如果k[i]和k[j]之前没有边，则相加。</p>
<h2 id="22-5-6"><a href="#22-5-6" class="headerlink" title="22.5-6"></a>22.5-6</h2><blockquote>
<p>给定一个有向图$G = (V, E)$，解释如何创建另一个图$G’ = (V, E’)$，使得（A）$G’$具有与$G$相同的强连通分支，（B）$G’$具有与$G$相同的分支图，并且（C）$E’$尽可能小。描述一个快速算法来计算$G’$。</p>
</blockquote>
<ol>
<li>先对原图G生成k个联通分量和一个SCC子图.</li>
<li>遍历k个所有的联通分量. 对每个联通分量,必然有一个能够到所有点的回路,只添加该回路到新的图.假设第i个联通分量有5个节点a,b,c,d,e,我们只需要添加边a-&gt;b,b-&gt;c,c-&gt;d,d-&gt;e,e-&gt;a即可.</li>
<li>选SCC子图的边,加到新的图. 节点可以任意选择.</li>
</ol>
<h2 id="22-5-7"><a href="#22-5-7" class="headerlink" title="22.5-7"></a>22.5-7</h2><blockquote>
<p>一个有向图$G = (V, E)$是**<em>半连接的</em>**如果，对于所有的顶点$u, v \in V$对，我们有$u \leadsto v$或$v \leadsto u$。给出了判断是否$G$为半连通的有效算法。证明你的算法是正确的，并分析它的运行时间。</p>
</blockquote>
<p>算法：</p>
<ol>
<li>快跑$\text{STRONG-CONNECTED-COMPONENTS}(G)$。</li>
<li>将每个强连通分支作为一个虚拟顶点，创建一个新的虚拟图$G’$。</li>
<li>快跑$\text{TOPOLOGICAL-SORT}(G’)$。</li>
<li>检查对于拓扑排序中的$G’$所有连续顶点$(v_i, v_{i + 1})$，图$G’$中是否存在边$(v_i, v_{i + 1})$。如果是，则原图是半连通的。否则，它就不是。</li>
</ol>
<p>证明：</p>
<p>很容易证明这$G’$是一个 DAG.考虑中的$G’$连续顶点$v_i$和$v_{i + 1}$。如果没有从$v_i$到$v_{i + 1}$的边，我们也可以得出结论，没有从$v_{i + 1}$到$v_i$的路径，因为$v_i$之后$v_{i + 1}$完成了。根据的定义$G’$，我们得出结论，不存在从表示为$v_i$的中$G’$的$G$任何顶点到表示为的$v_{i + 1}$顶点的路径。因此，$G$不是半连接的。如果在所有连续的顶点之间存在一条边，则我们声称在任意两个顶点之间存在一条边。因此，$G$是半连通的。</p>
<p>运行时间：$O(V + E)$。</p>
<blockquote>
<p>让 $G = (V, E)$ 是一个无向连通图，其权重函数为 $w： E \rightarrow \mathbb R$，并假设 $|E| \ge |V|$ 且所有边的权重都不同。</p>
<p>我们定义一棵次优最小生成树如下。让 $mathcal T$ 是 $G$ 所有生成树的集合，让 $T’$ 是 $G$ 的最小生成树。那么**<em>次优最小生成树</em>**就是一棵生成树$T$，使得$W(T) = \min_{T’’ \in \mathcal T - \{T’\}} \（w（T’’））$.</p>
<p><strong>a.</strong> 证明最小生成树是唯一的，但是次优最小生成树不一定是唯一的。</p>
<p><strong>b.</strong> 让 $T$ 成为 $G$ 的最小生成树。证明 $G$ 包含在 T$ 中的边 $(u, v) 和不在 T$ 中的边 $(x, y) ，这样 $T - \{(u, v)\} \cup \{(x, y)\}$ 是G的次优最小生成树。</p>
<p><strong>c.</strong> 让 $T$ 是 $G$ 的一棵生成树，对于 V$ 中的任意两个顶点 $u，v，让 $max[u, v]$ 表示在 $T$ 中 $u$ 和 $v$ 之间唯一的简单路径上权重最大的一条边。描述一个$O(V^2)$时间的算法，在给定$T$的情况下，为V$中的所有$u, v计算$max[u, v]$。</p>
<p><strong>d.</strong> 给出计算 $G$ 的次优最小生成树的高效算法。</p>
</blockquote>
<p><strong>a.</strong> 为了说明次优最小生成树不一定是唯一的，我们来看看下面这个有四个顶点的示例图。假设顶点为 ${a, b, c, d}$, 边的权重如下：</p>
<p>$$<br>\begin{array}{c|c|c|c|c|}<br>  &amp; a &amp; b &amp; c &amp; d \\<br>\hline<br>a &amp; - &amp; 1 &amp; 4 &amp; 3 \\<br>\hline<br>b &amp; 1 &amp; - &amp; 5 &amp; 2 \\<br>\hline<br>c &amp; 4 &amp; 5 &amp; - &amp; 6 \\<br>\hline<br>d &amp; 3 &amp; 2 &amp; 6 &amp; - \\<br>\hline<br>\end{array}<br>$$</p>
<p>那么，最小生成树的权重为 $7$，但有两棵权重次优的生成树，权重为 $8$。</p>
<p><strong>b.</strong> 我们试图证明，有一条边的交换可以使我们的最小生成树降级为次优最小生成树。在获得次优最小生成树的过程中，必须有某个远离其余顶点的单个切点，而在该切点上添加的边并不轻，否则，我们找到的将是最小生成树，而不是次优最小生成树。我们将该切分所选的边称为次优最小生成树 $(x,y)$。现在，考虑同样的切分，只是看看在获得 $T$ 时所选择的边，称之为 $(u，v)$。那么，如果考虑 $T -\{(u, v)} \cup \{(x, y)}$，它将是一棵次优最小生成树。这是因为如果第二好的最小生成树也为另一条切分选择了一条非光边，那么它最终会比所有的最小生成树都要昂贵。这就意味着，我们需要在每条切线上都选择轻边。这意味着所有选择都与最小生成树一致。</p>
<p><strong>c.</strong> 我们在此给出一个动态编程解决方案。假设我们要为 $(u, v)$ 求解。首先，我们将确定在从 $u$ 到 $v$ 的简单路径上紧接着 $u$ 出现的顶点 $x$。然后，我们将使 $\max[u, v]$ 等于 $w((u, x))$ 和 $\max[w, v]$ 的最大值。最后，我们只考虑 $u$ 和 $v$ 相邻的情况，在这种情况下，最大权重边只是两者之间的一条边。如果我们能在恒定时间内找到 $x$，那么整个动态程序的运行时间就是 $O(V^2)$，因为这就是正在建立的表的大小。为了在恒定时间内找到 $x$，我们要对树进行预处理。我们首先选取一个任意根。然后，我们对塔尔扬的离线最小公祖算法进行预处理（见问题 21-3）。这需要的时间只比线性多一点，即 $O(|V|\alpha(|V|))$。计算出所有最小公祖后，我们就可以在恒定时间内，在稍后的某个时间点查找该结果。然后，为了找到我们应该选取的 $w$，我们首先要看 $u = \text{LCA}(u,v)$，如果没有，那么我们就选取树中 $u$ 的父节点。如果是，那么我们就把问题反过来，试着计算 $\max[v，u]$，我们保证不会出现 $v = \text{LCA}(v, u)$ 这种情况，因为我们知道 $u$ 是 $v$ 的祖先。</p>
<p><strong>d.</strong> 在此，我们提供了一种用时 $O(V^2)$的算法，并对是否存在线性时间解（即用时 $O(E+V)$的解）保持开放态度。首先，我们用 $O(E+V\lg(V))$的时间找到一棵最小生成树，其时间为 $O(V^2)$。然后，使用 c 部分的算法，找到双数组最大值。然后，我们在所有顶点 $u$, $v$ 对中取运行最小值 $w(u,v)-\max[u,v]$。如果 $u$ 和 $v$ 之间没有边，我们就认为权重是无限的。然后，对于这个差值最小的一对，我们加入这条边，并从最小生成树中删除从 $u$ 到 $v$ 的路径中权重为 $\max[u,v]$的一条边。</p>
<blockquote>
<p>对于一个非常稀疏的连通图 $G = (V，E)$，我们可以通过在运行 Prim 算法之前对 $G$ 进行预处理以减少顶点数量，从而进一步提高使用斐波那契堆的 Prim 算法的 $O(E + V\lg V)$ 运行时间。具体来说，我们为每个顶点$u$ 选择与$u$ 相连的最小权重边$(u, v)$，并将$(u, v)$ 放入正在构建的最小生成树中。然后，我们收缩所有选定的边（见第 B.4 节）。我们不是一条一条地收缩这些边，而是首先确定合并为同一个新顶点的顶点集。然后，我们创建一个图形，这个图形就是逐条收缩这些边的结果，但我们是根据边的端点所处的集合对边进行 “重命名”。原始图中的几条边可能会被重命名为相同的名称。在这种情况下，结果只有一条边，其权重是相应原始边权重的最小值。</p>
<p>最初，我们将正在构建的最小生成树 $T$ 设置为空，对于 E$ 中的每一条边 $(u，v)，我们初始化属性 $(u, v).orig = (u, v)$ 和 $(u, v).c = w(u，v)$。我们使用 $orig$ 属性来引用与收缩图中的边相关联的初始图中的边。$c$ 属性用于保存边的权重，当边被收缩时，我们会根据上述选择边权重的方案对其进行更新。存储过程 $text{MST-REDUCE}$接受输入 $G$ 和 $T$，并返回带有更新属性 $orig’$ 和 $c’$ 的收缩图 $G’$。程序还会将 $G$ 的边累加到最小生成树 $T$ 中。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MST-<span class="built_in">REDUCE</span>(G, T)</span><br><span class="line">    <span class="keyword">for</span> each v ∈ G.V</span><br><span class="line">        v.mark = <span class="literal">false</span></span><br><span class="line">        MAKE-<span class="built_in">SET</span>(v)</span><br><span class="line">    <span class="keyword">for</span> each u ∈ G.V</span><br><span class="line">        <span class="keyword">if</span> u.mark == <span class="literal">false</span></span><br><span class="line">            choose v ∈ G.Adj[u] such <span class="built_in">that</span> (u, v).c is minimized</span><br><span class="line">                <span class="built_in">UNION</span>(u, v)</span><br><span class="line">                T = T ∪ {(u, v).orig}</span><br><span class="line">                u.mark = v.mark = <span class="literal">true</span></span><br><span class="line">    G<span class="number">'.</span>V = {FIND-<span class="built_in">SET</span>(v): v ∈ G.V}</span><br><span class="line">    G<span class="number">'.</span>E = Ø</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">each</span> (x, y) ∈ G.E</span><br><span class="line">        u = FIND-<span class="built_in">SET</span>(x)</span><br><span class="line">        v = FIND-<span class="built_in">SET</span>(y)</span><br><span class="line">        <span class="keyword">if</span> (u, v) ∉ G<span class="number">'.</span>E</span><br><span class="line">             G<span class="number">'.</span>E = G<span class="number">'.</span>E ∪ {(u, v)}</span><br><span class="line">             (u, v).orig<span class="number">'</span> = (x, y).<span class="built_in">orig</span></span><br><span class="line">             (u, v).c<span class="number">'</span> = (x, y).c</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x, y).c &lt; (u, v).c<span class="number">'</span></span><br><span class="line">             (u, v).orig<span class="number">'</span> = (x, y).<span class="built_in">orig</span></span><br><span class="line">             (u, v).c<span class="number">'</span> = (x, y).c</span><br><span class="line">    construct adjacency lists G<span class="number">'.</span>Adj <span class="keyword">for</span> G<span class="number">'</span></span><br><span class="line">    <span class="keyword">return</span> G<span class="number">'</span> <span class="keyword">and</span> T</span><br></pre></td></tr></tbody></table></figure>

<p><strong>a.</strong> 让 $T$ 是 $text{MST-REDUCE}$ 返回的边的集合，让 $A$ 是调用 $\text{MST-PRIM}(G’,c’,r)$形成的图 $G’$ 的最小生成树，其中 $c’$ 是 $G’E$ 边上的权重属性，$r$ 是 $G’V$ 中的任意顶点。证明 $T \cup {(x,y).orig’: (x, y) \in A}$ 是 $G$ 的最小生成树。</p>
<p><strong>b.</strong> 论证 $|G’.V| \le |V| / 2$.</p>
<p><strong>c.</strong> 展示如何实现 $text{MST-REDUCE}$，使其在 $O(E)$ 时间内运行。($\textit{提示：}$ 使用简单的数据结构)</p>
<p>**d.**假设我们运行$\text{MST-REDUCE}$$的$k$个阶段，使用一个阶段产生的输出$G’$作为下一阶段的输入$G$，并在$T$中累积边。论证 $k$ 阶段的总体运行时间为 $O(kE)$。</p>
<p>**e.**假设在运行$k$阶段的$\text{MST-REDUCE}$后，如第(d)部分所示，我们通过调用$\text{MST-PRIM}(G’, c’, r)$来运行普里姆算法，其中$G’$的权重属性为$c’$，由最后一个阶段返回，而$r$是$G’.V$中的任意顶点。演示如何选择 $k$，从而使总体运行时间为 $O(E/lg/lg V)$。论证您所选择的 $k$ 能使整体渐近运行时间最小化。</p>
<p><strong>f.</strong> 对于 $|E|$（就 $|V|$而言）的哪些值，有预处理的 Prim 算法会渐进地击败无预处理的 Prim 算法？</p>
</blockquote>
<p>**我们将证明每一步添加的边都是安全的。考虑一个无标记顶点 $u$。设 $S = {u/}$，并让 $A$ 是目前树中的边集。那么剪切尊重 $A$，我们添加的下一条边是一条光边，所以对 $A$ 来说是安全的。因此，在我们运行 Prim 算法之前，$T$ 中的每一条边对$T$ 都是安全的。通常情况下，Prim’s 算法在此时添加的任何一条边都必须连接两棵已创建的树，而且会被选作最小边。此外，我们在任何两棵树之间都会选择一条边。因此，我们只有最小的边并不是问题。结果树一定是最小的。</p>
<p>**b.**我们通过对 $G$ 中顶点数量的归纳来论证。我们假设 $|V| &gt; 1$，否则 $text{MST-REDUCE}$ 将在第 6 行遇到错误，因为无法选择 $v$。让 $|V| = 2$。因为 $G$ 是连通的，所以 $u$ 和 $v$ 之间一定有一条边，而且这条边的权重是最小的。它们连接起来，$|G’.V| = 1 = |V| / 2$。</p>
<p>假设在 $|V| = n$ 的情况下，上述主张成立。让 $G$ 是一个有 $n + 1$ 个顶点的连通图。那么在第 4 行的 for 循环检查最终顶点 $v$ 之前，$G’.V \le n / 2$。如果 $v$ 已被标记，那么我们就完成了；如果 $v$ 没有被标记，那么我们将把它连接到其他顶点，由于 $v$ 是最后一个要处理的顶点，所以它必须被标记。</p>
<p>无论如何，$v$ 都无法为 $G’.V$ 带来额外的顶点。所以</p>
<p>$$|G’.V| \le n / 2 \le (n + 1) / 2.$$</p>
<p><strong>c.</strong> 与其使用第 21 章中的不相交集合结构，我们可以简单地使用数组来跟踪顶点所在的组件。假设 $A$ 是一个长度为 $|V|$ 的数组，如果 $v = \text{FIND-SET}(u)$，那么 $A[u] = v$。那么 $\text{FIND-SET}(u)$现在可以替换为 $A[u]$，$\text{UNION}(u, v)$ 可以替换为 $A[v]=A[u]$。由于这些操作的运行时间不变，因此运行时间为 $O(E)$。</p>
<p><strong>d.</strong> 输出中的边的数量是单调递减的，因此每次调用的时间为 $O(E)$。因此，$k$ 调用耗时为 $O(kE)$。</p>
<p>**e.**普里姆算法的运行时间为 $O(E+V/lg V)$。每次运行 $\text{MST-REDUCE}$，顶点数量至少会减少一半。因此，在调用 $k$ 后，顶点数量最多为 $|V| / 2^k$。我们需要最小化</p>
<p>$$E + V / 2^k\lg(V / 2^k) + kE = E + \frac{V\lg V}{2^k} - \frac{Vk}{2^k} + kE$$</p>
<p>与 $k$ 有关。如果我们选择 $k =\lg\lg V$，那么我们就能如愿以偿地实现 $O(E\lg\lg V)$ 的总体运行时间。</p>
<p>要看到这个 $k$ 值最小，请注意 $\frac{Vk}{2^k}$ 项总是小于 $kE$ 项，因为 $E\ge V$。随着 $k$ 的减小，$kE$ 的贡献会减小，而 $\frac{V\lg V}{2^k}$ 的贡献会增大。因此，我们需要找到 $k$ 的值，使它们在最坏的情况下（当 $E = V$ 时）大致相等。为此，我们设置 $\frac{\lg V}{2^k} = k$。要精确解决这个问题，需要用到兰伯特 W 函数，但最接近的基本函数是 $k = \lg\lg V$。</p>
<p><strong>f.</strong> 我们只需设置不等式</p>
<p>$$E\lg\lg V &lt; E + V\lg V$$</p>
<p>发现我们需要</p>
<p>$$E &lt; \frac{V\lg V}{\lg\lg V-1} = O(\frac{V\lg V}{\lg\lg V}).$$</p>
<blockquote>
<p>无向图 $G$ 的**<em>瓶颈生成树</em>** $T$ 是 $G$ 的生成树，其最大边的权重在 $G$ 的所有生成树中最小。我们说瓶颈生成树的值就是 $T$ 中最大边的权重。</p>
<p>**a.**论证最小生成树就是瓶颈生成树。</p>
<p>第（a）部分表明，找到一棵瓶颈生成树并不比找到一棵最小生成树难。在剩下的部分中，我们将展示如何在线性时间内找到一棵瓶颈生成树。</p>
<p><strong>b.</strong> 给定一个图 $G$ 和一个整数 $b$，给出一个线性时间算法，确定瓶颈生成树的值是否最多为 $b$。</p>
<p>**c.**将（b）部分的算法用作瓶颈生成树问题线性时间算法的子程序。($textit{提示:}$ 您可能想使用一个收缩边集的子程序，就像问题 23-2 中描述的 $\text{MST-REDUCE}$程序那样).</p>
</blockquote>
<p><strong>a.</strong> 发现每棵最小生成树也是一棵瓶颈生成树。假设 $T$ 是一棵最小生成树。假设其中有一条边 $(u, v)$ 的权重大于瓶颈生成树的权重。那么，让 $V_1$ 成为 $V$ 的顶点子集，这些顶点在 $T$ 中不经过 $v$ 就能从 $u$ 到达。对称定义 $V_2$。然后，考虑将 $V_1$ 与 $V_2$ 分割开的切口。在这条切线上，我们只能添加一条权重最小的边，因此我们知道在这条切线上没有权重小于 $w(u,v)$的边。</p>
<p>然而，我们知道有一条权重小于该权重的瓶颈生成树。这是一个矛盾，因为瓶颈生成树既然是生成树，就必须有一条边穿过这条切口。</p>
<p>**为此，我们首先处理整个图，删除权重大于 $b$ 的边。如果剩下的图是连通的，我们就可以任意选择其中的任意一棵树，它将是一棵权重最多为 $b$ 的瓶颈生成树。测试图的连通性可以在线性时间内完成，方法是先进行广度搜索，然后确保搜索结束时没有空白顶点。</p>
<p><strong>c.</strong> 写下所有顶点的边重。使用第 9.3 节中的算法，在 $O(E)$的时间内找出这个数字列表的中位数。然后，以该中值为输入，运行 b 部分的程序。那么有两种情况：</p>
<p>第一种情况是，存在一棵权重最多为中位数的瓶颈生成树。那么，只需丢弃权重大于中值的边，然后在这张新图上用一半的边重复程序即可。</p>
<p>其次，我们可以认为不存在权重至多为该权重的瓶颈生成树。然后，我们应该运行与问题 23-2 类似的程序，收缩所有权重至多等于中位数权重的边。这需要花费 $O(E)$，然后我们就可以在现在只有一半边的图上解决问题了。</p>
<p>请注意，两种情况都是 $O(E)$，而且每次递归都会将问题规模减半。因此，这种递归的解法是线性的。</p>
<blockquote>
<p>在这个问题中，我们给出了三种不同算法的伪代码。每种算法都将连通图和权重函数作为输入，并返回一组边 $T$。对于每种算法，要么证明 $T$ 是最小生成树，要么证明 $T$ 不是最小生成树。同时描述每种算法最有效的实现方式，无论它是否能计算出最小生成树。</p>
<p><strong>a.</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MAYBE-MST-<span class="built_in">A</span>(G, w)</span><br><span class="line">    sort the edges into nonincreasing order of edge weights w</span><br><span class="line">    T = E</span><br><span class="line">    <span class="keyword">for</span> each edge e, taken in nonincreasing order by weight</span><br><span class="line">        <span class="keyword">if</span> T - {e} is a connected graph</span><br><span class="line">            T = T - {e}</span><br><span class="line">    <span class="keyword">return</span> T</span><br></pre></td></tr></tbody></table></figure>

<p><strong>b.</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MAYBE-MST-<span class="built_in">B</span>(G, w)</span><br><span class="line">    T = Ø</span><br><span class="line">    <span class="keyword">for</span> each edge e, taken in arbitrary order</span><br><span class="line">        <span class="keyword">if</span> T ∪ {e} has no cycles</span><br><span class="line">            T = T ∪ {e}</span><br><span class="line">    <span class="keyword">return</span> T</span><br></pre></td></tr></tbody></table></figure>

<p><strong>c.</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAYBE-MST-<span class="built_in">C</span>(G, w)</span><br><span class="line">    T = Ø</span><br><span class="line">    <span class="keyword">for</span> each edge e, taken in arbitrary order</span><br><span class="line">        T = T ∪ {e}</span><br><span class="line">        <span class="keyword">if</span> T has a cycle c</span><br><span class="line">            let e<span class="number">'</span> be a maximum-weight edge on c</span><br><span class="line">            T = T - {e}</span><br><span class="line">    <span class="keyword">return</span> T</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p><strong>a.</strong> 这确实会返回一个 $\text{MST}$。为了说明这一点，我们将证明我们永远不会删除必须是最小生成树一部分的边。如果我们删除 $e$，那么 $e$ 就不可能是桥，这意味着 e 位于图的一个简单循环上。由于我们按非递增顺序删除边，循环上每条边的权重必须小于或等于 $e$。根据练习 23.1-5，$G$ 上有一棵删除了边 $e$ 的最小生成树。</p>
<p>要实现这一点，我们首先要在 $O(E \lg E)$ 时间内对边进行排序。对于每一条边，我们都需要检查 $T - {e}$ 是否相连，因此我们需要运行 $\text{DFS}$。每一次都需要 $O(V+E)$，因此对所有边进行检查需要 $O(E(V+E))$。这将主导运行时间，因此总时间为 $O(E^2)$。</p>
<p><strong>b.</strong> 这不会返回 ${MST}$。要了解这一点，让 $G$ 成为有 3 个顶点 $a$、$b$ 和 $c$ 的图。让权重分别为 3、2 和 1 美元的 eges 分别为 $(a,b)$、$(b,c)$ 和 $(c,a)$。如果算法按照列出的顺序检查这些边，则会选取最重的两条边，而不是最轻的两条边。</p>
<p>高效的实现方法是使用不相邻集合来跟踪相连的组件，如问题 23-2 中的 $\text{MST-REDUCE}$。试图在同一组件内联合将产生一个循环。由于我们对 $\text{MAKESET}$ 的调用次数为 $|V|$，对 $\text{FIND-SET}$ 和 $\text{UNION}$ 的调用次数最多为 3|E|$，因此运行时间为 $O(E\alpha(V))$。</p>
<p><strong>c.</strong> 这确实会返回一个 $\text{MST}$。要了解这一点，我们只需引用练习 23.1-5 中的结果即可。我们移除的边只是某个循环上权重最大的边，而且总是存在不包含这些边的最小生成树。此外，如果我们从每个循环中删除一条边，那么得到的图就不可能有任何循环，因此它一定是一棵树。</p>
<p>为了实现这一点，我们使用了第(b)部分中的方法，只不过现在我们还需要找到循环上的最大权重边。对于每一条引入循环的边，我们都可以执行 $\text{DFS}$来找到循环和最大权重边。由于此时的树最多只有一个循环，因此它最多有 $|V|$ 条边，所以我们可以在 $O(V)$ 内运行 $\text{DFS}$。因此运行时间为 $O(EV)$。</p>
<h2 id="23-1-1"><a href="#23-1-1" class="headerlink" title="23.1-1"></a>23.1-1</h2><blockquote>
<p>设$(u, v)$是连通图$G$中的最小权边。显示$(u, v)$属于的$G$某个最小生成树。</p>
</blockquote>
<p>在GENERIC-MST的第一步中，我们可以选择这样的切割，节点u在一边，节点v在另一边。（u，v）是通过这个切割的一条轻边。因此，添加（u，v）是安全的。</p>
<h2 id="23-1-2"><a href="#23-1-2" class="headerlink" title="23.1-2"></a>23.1-2</h2><blockquote>
<p>萨巴蒂尔教授猜想定理 23.1 的逆定理如下。设$G = (V, E)$是一个连通的无向图，其上$E$定义了一个实值权函数$w$。设$A$是包含在某个最小生成树$G$中的$E$子集，设$(S, V - S)$是该方面$A$的$G$任何切割，且设$(u, v)$是用于$A$交叉$(S, V - S)$的安全边。然后，$(u, v)$是一个光边的切割。通过举反例来证明教授的猜想是错误的。</p>
</blockquote>
<p>设$G$图$4$的顶点为：$u, v, w, z$。设图$(u, v), (u, w), (w, z)$的边的权$3$分别为、$1$和$2$。</p>
<p>假设$A$是集合$\{(u, w)\}$。让$S = A$。然后$S$清楚地尊重$A$。既然$G$是一棵树，它的最小生成树就是它本身，所以$A$它通常是最小生成树的一个子集。</p>
<p>此外，每个边缘都是安全的。特别是$(u, v)$，对于切割来说是安全的，但不是轻的边缘。因此，萨巴蒂尔教授的猜想是错误的。</p>
<h2 id="23-1-3"><a href="#23-1-3" class="headerlink" title="23.1-3"></a>23.1-3</h2><blockquote>
<p>证明如果一条边$(u, v)$包含在某个最小生成树中，则它是穿过图的某个割集的一条轻边。</p>
</blockquote>
<p>设$T_0$和$T_1$是通过从 A$\text{MST}$中删除边$(u, v)$而得到的两棵树。假设$V_0$和$V_1$分别是和$T_1$的$T_0$顶点。</p>
<p>考虑与$V_1$分离$V_0$的切口。假设有一个矛盾，即在这个切割中，有一些边的重量小于$(u, v)$。然后，我们可以通过添加该边来$T_1 \cup T_0$构造整个图的最小生成树。这将导致最小生成树的权重小于包含$(u, v)$的原始最小生成树。</p>
<h2 id="23-1-4"><a href="#23-1-4" class="headerlink" title="23.1-4"></a>23.1-4</h2><blockquote>
<p>给出一个简单的例子，一个连通图的边$\{(u, v):$集合存在一个割集$(S, V - S)$，使得$(u, v)$轻边交叉$(S, V - S)\}$不形成最小生成树。</p>
</blockquote>
<p>当三角形三条边权重相同时,每条边在某种 切割 中均是最轻,即结果中存在环,所以不是最小生成树.</p>
<p>例如，如果我们有一个三角形具有相同的重量。在每个切割中，将有两个相等的边e1和e2。如果我们选择e1进入MST，虽然e2也是一个轻量级的，但它不在MST中。</p>
<h2 id="23-1-5"><a href="#23-1-5" class="headerlink" title="23.1-5"></a>23.1-5</h2><blockquote>
<p>设$e$是连通图$G = (V, E)$的某个圈上的最大权边。证明存在的$G’ = (V, E - \{e\})$最小生成树也是的$G$最小生成树。也就是说，存在不包括$e$的$G$最小生成树。</p>
</blockquote>
<p>设$A$为任何切割，其在切割的一侧导致循环中的一些顶点，而在另一侧导致循环中的一些顶点。对于这些切口中的任何一个，我们都知道该切口的边缘$e$不是轻边缘。因为所有其他的切割都不会有边缘$e$穿过它，所以我们也不会有任何切割的边缘是轻的。这意味着我们认为 E 不安全。</p>
<h2 id="23-1-6"><a href="#23-1-6" class="headerlink" title="23.1-6"></a>23.1-6</h2><blockquote>
<p>证明一个图有唯一的最小生成树，如果对于图的每个割集，都有唯一的轻边穿过割集。给出一个反例，说明反之不成立。</p>
</blockquote>
<p>假设存在两个最小生成树 T 和 T’. 对任意一条边 e 属于 T, 如果从 T 中移除 e, 则 T 变得不连通, 形成 cut (S, V - S), 根据练习 23.1-3 可知, e 是穿过 cut(S, V - S) 最轻边. 假设边 x 属于 T’, 并穿过 cut (S, V - S), 则 x 同样是最轻边. 由于穿过 cut(S, V - S) 的最轻边唯一. 既 e 和 x 是同一条边. 所以 e 也属于 T’, 由于我们选择 e 是任意的, 所有在 T 中的边, 同样在 T’ 中. 即最小生成树唯一.</p>
<p>假设有两个MST，称为T和T ‘。对于T中的任何边e，如果我们从T中移除e，则T变得不连通，并且我们有一个割（S，V-S）。根据练习23.1-3，e是通过切割的光边（S，V-S）.如果边x在T’中且穿过切割（S，V-S），则x也是一个轻权。因为光边是独一无二的。所以e和x是同一条边，e也在T ‘中。因为我们随机选择e，在T中的所有边中，也在T ‘中。因此，MST是独一无二的。</p>
<p>将条件和结论调换则不成立, 如下.</p>
<p>如果相反，则不成立。看图片。</p>
<p><img src="https://github.com/gzc/CLRS/raw/master/C23-Minimum-Spanning-Trees/repo/s1/2.jpg" alt="img"></p>
<h2 id="23-1-7"><a href="#23-1-7" class="headerlink" title="23.1-7"></a>23.1-7</h2><blockquote>
<p>如果一个图的所有边权都是正的，那么任何连接所有顶点且总权最小的边子集一定是一棵树。给出一个例子来说明，如果我们允许某些权为非正数，则不能得出相同的结论。</p>
</blockquote>
<p>首先，我们证明了连接所有顶点的最小总权重的边子集是一棵树。为了看到这一点，假设没有，它有一个周期。这意味着移除此循环中的任何边将意味着剩余的边仍将连接所有顶点，但其总权重将小于被移除的边的权重。这将与顶点子集的总权重的最小值相矛盾。由于边的子集形成树，并且具有最小的总权重，因此它也必须是最小生成树。</p>
<p>如果我们允许负的边权，这个结论是不正确的，我们提供了一个构造。考虑所有边权重等于$-1$的图$K_3$。连接图的边的唯一最小权重集具有总权重$-3$，并且由所有边组成。这显然不是 A$\text{MST}$，因为它不是一棵树，这很容易看出，因为它比三个顶点的树多一条边。这个加权图中的任何一个$\text{MST}$都必须具有至少$-2$为的权重。</p>
<h2 id="23-1-8"><a href="#23-1-8" class="headerlink" title="23.1-8"></a>23.1-8</h2><blockquote>
<p>设$T$是图$G$的最小生成树，$L$是图的边权$T$的排序表。证明对于的$G$任何其他最小生成树$T’$，该列表$L$也是的边权重$T’$的排序列表。</p>
</blockquote>
<p>假设这$L’$是最小生成树的边权重的另一个排序列表。如果$L’ \ne L$，则在或$T’$中必须有第一条边$(u, v)$$T$，其权重小于另一组中的相应边$(x, y)$。不失一般性，假设$(u, v)$是在$T$。</p>
<p>设$C$是通过添加$(u, v)$到$L’$得到的图。那么我们一定引入了一个循环。如果在该圈上存在权大于$(u, v)$的边，则我们可以移除它以获得权严格小于的$T’$权的树$C’$，这与最小生成树的事实$T’$相矛盾。</p>
<p>因此，循环上的每条边的权重必须小于或等于$(u, v)$。假设每条边都具有严格较小的权。从$T$拆下$(u, v)$，将其分成两个组件。除了连接这些的圈之外，还必须存在一些边$(u, v)$，由于它具有较小的权重，我们可以使用该边来创建权重小于$T$的生成树，这是一个矛盾。因此，循环上的某些边具有与$(u, v)$相同的权重。将该边缘替换为$(u, v)$。相应的列表$L$和$L’$保持不变，因为我们换出了一条权重相等的边，但和$T’$共有的边$T$的数量增加了$1$。</p>
<p>如果我们以这种方式继续下去，最终它们必须有共同的边，这与它们的边权重在某些地方不同的事实相矛盾。因此，所有最小生成树都具有相同的边权重排序列表。</p>
<h2 id="23-1-9"><a href="#23-1-9" class="headerlink" title="23.1-9"></a>23.1-9</h2><blockquote>
<p>设$T$是一个图$G = (V, E)$的最小生成树，$V’$是的$V$一个子集。设$T’$为由$V’$导出的$T$子图，设$G’$为由$V’$导出的$G$子图。证明如果$T’$是连通的，则$T’$是的$G’$最小生成树。</p>
</blockquote>
<p>假设有一棵比$T’$这更便宜的生成树。也就是说，我们有一些$T’’$，所以$w(T’’) &lt; w(T’)$。然后，设$S$边在中$T$，但不在中$T’$。然后，我们可以通过考虑$S \cup T’’$来构造的$G$最小生成树。这是一个生成树，$T’’$因为$S \cup T’$它使所有的顶点$V’$都像$T’$这样连接起来。</p>
<p>然而，我们有</p>
<p>$$W（s\cup t ‘ ‘）=W（s）+W（t ‘ ‘） &lt;W（s）+W（t ‘）=W（S\cup t ‘）=w（t）。$$</p>
<p>这意味着我们刚刚找到了一个比最小生成树具有更低总权重的生成树。这是一个矛盾，所以我们假设有一个比$T’$更便宜的$V’$生成树一定是错误的。</p>
<h2 id="23-1-10"><a href="#23-1-10" class="headerlink" title="23.1-10"></a>23.1-10</h2><blockquote>
<p>给定一个图$G$和一个最小生成树$T$，假设我们减少其中一条边$T$的权重。显示$T$仍然是的$G$最小生成树。更正式地，设$T$是具有由权函数$w$给出的边权的$G$最小生成树。选择一条边$(x, y) \in T$和一个正数$k$，并定义权重函数$w’$</p>
<p>$$<br>w’(u, v) =<br>\begin{cases}<br>w(u, v)     &amp; \text{ if }(u, v) \ne (x, y), \\<br>w(x, y) - k &amp; \text{ if }(u, v) =   (x, y).<br>\end{cases}<br>$$</p>
<p>证明$T$是的最小生成树，$G$其边权由$w’$给出。</p>
</blockquote>
<p>我们通过切割来证明。最初，（x，y）是某个切割（V1，V2）中的轻边。减小（x，y），（x，y）的权重仍然是一个轻边。所以T是G的最小生成树，其边权由w′给出。</p>
<h2 id="23-1-11-star"><a href="#23-1-11-star" class="headerlink" title="23.1-11$\star$"></a>23.1-11$\star$</h2><blockquote>
<p>给定一个图$G$和一个最小生成树$T$，假设我们减少其中一条不在$T$的边的权重。给出了在修改图中求最小生成树的算法。</p>
</blockquote>
<p>如果我们将这个新减少的边添加到给定的树中，我们将创建一个循环。然后，如果我们沿着这个循环删除任何一条边，我们仍然会有一个生成树。这意味着我们沿着通过添加减少的边而形成的该循环查看所有权重，并且移除最大权重的循环中的边。这正是我们想要的，因为我们可能只想添加单个减少的边，然后，从那里我们将图改回树，使其总权重最小化。</p>
<h2 id="23-2-1"><a href="#23-2-1" class="headerlink" title="23.2-1"></a>23.2-1</h2><blockquote>
<p>Kruskal 的算法可以为相同的输入图$G$返回不同的生成树，这取决于当边按顺序排序时它如何打破联系。证明对于的$G$每个最小生成树$T$，有一种方法可以对克鲁斯卡尔算法中的$G$边进行排序，以便算法返回$T$。</p>
</blockquote>
<p>假设我们想要选择$T$作为我们的最小生成树。然后，为了使用 Kruskal 算法获得该树，我们将首先根据边的权重对边进行排序，然后将通过首先挑选包含在最小生成树中的边来解决边权重的关系，并将所有不$T$包含在最小生成树中的边视为稍大，即使它们具有相同的实际权重。</p>
<p>通过这种排序，我们仍然可以找到与所有最小生成树$w(T)$具有相同权重的树。然而，由于我们对中$T$的边进行了优先排序，我们将在其他最小生成树中的任何其他边上挑选它们。</p>
<h2 id="23-2-2"><a href="#23-2-2" class="headerlink" title="23.2-2"></a>23.2-2</h2><blockquote>
<p>假设我们将图$G = (V, E)$表示为邻接矩阵。对于这种情况，给出 Prim 算法的一个简单实现，它在$O(V^2)$时间上运行。</p>
</blockquote>
<p>在算法的每一步，我们将添加一条边，从目前为止创建的树中的一个顶点到不在树中的一个顶点，使得这条边具有最小权重。因此，对于不在树中的每个顶点，知道从该顶点到最小权重的树中的某个顶点的边将是有用的。我们将此信息存储在一个数组$A$中，其中$A[u] = (v, w)$如果$w$是的权重$(u, v)$，并且在到目前为止构建的树中从$u$到某个顶点$v$的边的权重中是最小的。我们将使用$A[u].1$访问$v$和$A[u].2$访问$w$。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PRIM-<span class="built_in">ADJ</span>(G, w, r)</span><br><span class="line">    initialize A with every entry = (NIL, ∞)</span><br><span class="line">    T = {r}</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to V</span><br><span class="line">        <span class="keyword">if</span> Adj[r, i] != <span class="number">0</span></span><br><span class="line">            A[i] = (r, <span class="built_in">w</span>(r, i))</span><br><span class="line">    <span class="keyword">for</span> each u in V - T</span><br><span class="line">        k = <span class="built_in">min</span>(A[i]<span class="number">.2</span>)</span><br><span class="line">        T = T ∪ {k}</span><br><span class="line">        k.π = A[k]<span class="number">.1</span></span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span> to V</span><br><span class="line">            <span class="keyword">if</span> Adf[k, i] != <span class="number">0</span> <span class="keyword">and</span> Adj[k, i] &lt; A[i]<span class="number">.2</span></span><br><span class="line">                A[i] = (k, Adj[k, i])</span><br></pre></td></tr></tbody></table></figure>

<h2 id="23-2-3"><a href="#23-2-3" class="headerlink" title="23.2-3"></a>23.2-3</h2><blockquote>
<p>对于稀疏图$G = (V, E)$，其中$|E| = \Theta(V)$，使用斐波那契堆实现 Prim 算法是否比二进制堆实现更快？对于一个稠密的图，在哪里$|E| = \Theta(V^2)$？斐波那契堆实现的大小$|E|$和$|V|$之间的关系如何才能比二进制堆实现更快？</p>
</blockquote>
<p>用二进制堆实现的 Prim 算法的运行时间为 $O((V+E)\lg V)$，在稀疏的情况下，运行时间仅为 $O(V\lg V)$。用斐波那契堆实现的算法是</p>
<p>$$O(E + V\lg V) = O(V + V\lg V) = O(V \lg V).$$</p>
<ul>
<li><p>在稀疏情况下，两种算法的渐进运行时间相同。</p>
</li>
<li><p>在密集的情况下。</p>
<ul>
<li><p>二进制堆实现的运行时间为</p>
<p>  $$O((V + E)\lg V) = O((V + V^2)\lg V) = O(V^2\lg V).$$</p>
</li>
<li><p>斐波纳契堆实现的运行时为</p>
<p>  $$O(E + V\lg V) = O(V^2 + V\lg V) = O(V^2).$$</p>
</li>
</ul>
<p>  因此，在密集情况下，斐波那契堆的实现速度会逐渐加快。</p>
</li>
<li><p>只要 $E = \omega(V)$，斐波那契堆实现的速度就会逐渐加快。假设我们有一个比线性增长更快的函数，比如 $f$，而 $E = f(V)$。</p>
</li>
<li><p>二进制堆实现的运行时间为</p>
<p>  $$O((V + E)\lg V) = O((V + f(V))\lg V) = O(f(V)\lg V).$$</p>
</li>
</ul>
<p>但是，斐波纳契堆实现的运行时将具有</p>
<p>$$O(E + V\lg V) = O(f(V) + V\lg V).$$</p>
<p>此运行时要么$O(f(V))$是或，要么$O(V\lg V)$取决于其$f(V)$增长速度是否$V\lg V$分别更快或更慢。</p>
<p>在这两种情况下，运行时都比$O(f(V)\lg V)$。</p>
<h2 id="23-2-4"><a href="#23-2-4" class="headerlink" title="23.2-4"></a>23.2-4</h2><blockquote>
<p>假设图中的所有边权都是从$1$到$|V|$范围内的整数。你能让克鲁斯卡尔的算法以多快的速度运行？如果对于某个常数$W$，边权重是从$1$到$W$范围内的整数呢？</p>
</blockquote>
<p>（已删除）</p>
<p>如果w是一个常数，我们可以使用计数排序</p>
<p>·对边排序：O（E lg E）时间。</p>
<p>· O（E）不交集森林上的运算，时间复杂度为O（Eα（V））。</p>
<p>排序占优势，因此总时间是O（E lg E）。当边落在范围1，. . .，|V|时间复杂度为O（V + E）时间复杂度为O（Eα（V））。如果边缘落在范围1，. . .，W对于任何常数W，我们仍然需要使用Ω（E）时间进行排序，并且总运行时间不能进一步提高。</p>
<h2 id="23-2-5"><a href="#23-2-5" class="headerlink" title="23.2-5"></a>23.2-5</h2><blockquote>
<p>假设图中的所有边权都是从$1$到$|V|$范围内的整数。你能让普里姆的算法运行多快？如果对于某个常数$W$，边权重是从$1$到$W$范围内的整数呢？</p>
</blockquote>
<p>对于第一种情况，我们可以使用 Van Emde Boas 树来改进时间限制$O(E \lg \lg V)$。与 Fibonacci 堆实现相比，该方法仅对稀疏图的渐近运行时间有所改善，而不能多项式地改善运行时间。这种实现的优点是它可以具有较低的开销。</p>
<p>对于第二种情况，我们可以使用双链表的集合，每个双链表对应于一个边权。这提高了到$O(E)$的界限。</p>
<h2 id="23-2-6-star"><a href="#23-2-6-star" class="headerlink" title="23.2-6$\star$"></a>23.2-6$\star$</h2><blockquote>
<p>假设图中的边权在半开区间$[0, 1)$上均匀分布。克鲁斯卡尔算法和普里姆算法，哪种算法能让你跑得更快？</p>
</blockquote>
<p>对于从均匀分布中提取的输入，我将使用 Kruskal 算法的桶排序，用于按权重对边进行预期线性时间排序。这将达到预期的运行时间$O(E\alpha(V))$。</p>
<h2 id="23-2-7-star"><a href="#23-2-7-star" class="headerlink" title="23.2-7$\star$"></a>23.2-7$\star$</h2><blockquote>
<p>假设已经计算了一个图$G$的最小生成树。如果我们添加一个新的顶点和关联边，$G$我们更新最小生成树的速度有多快？</p>
</blockquote>
<p>如果只有一条边,只需要将这个顶点和这条边加进去.</p>
<p>如果有k(k &gt; 1)条边,那么需要删去k-1条边.</p>
<p>假设新节点是v,那么从v必然有一些回路. 遍历k-1次,每次都能找到一个回路,从该回路中删除一条权值最大的边.</p>
<p>如果只有一条边，只需添加此边。</p>
<p>如果有k（k &gt; 1）条边，则需要移除k-1条边。我们可以通过Union-Find找到循环，并删除并集中最重的边。该算法需要（k-1）遍。</p>
<h2 id="23-2-8"><a href="#23-2-8" class="headerlink" title="23.2-8"></a>23.2-8</h2><blockquote>
<p>波登教授提出了一种新的分治算法来计算最小生成树，该算法如下。给定一个图$G = (V, E)$，将顶点集$V$划分为两个集合$V_1$和$V_2$，使得$|V_1|$和$|V_2|$最多$1$相差。设$E_1$为仅在中的$V_1$顶点上关联的边的集合，设$E_2$为仅在中的$V_2$顶点上关联的边的集合。递归求解两个子图$G_1 = (V_1, E_1)$和$G_2 = (V_2, E_2)$上的最小生成树问题。最后，选择穿过切口$(V_1, V_2)$的最小权重边$E$，并使用该边将生成的两个最小生成树合并为一个生成树。</p>
<p>要么论证该算法正确计算了的$G$最小生成树，要么提供一个该算法失败的例子。</p>
</blockquote>
<p>算法失败。假设$E = \{(u, v), (u, w), (v, w)\}$，和$(u, w)$的$(u, v)$权为$1$，的$(v, w)$权为$1000$，将集合划分为两个集合$V_1 = \{u\}$和$V_2 = \{v, w\}$。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.liwuxuanplus.com/2023/10/20/shan-dong-da-xue-hui-bian-shi-yan-yi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liwuxuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MySite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/20/shan-dong-da-xue-hui-bian-shi-yan-yi/" class="post-title-link" itemprop="url">山东大学汇编实验一</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-10-20 20:10:00 / 修改时间：20:11:37" itemprop="dateCreated datePublished" datetime="2023-10-20T20:10:00+08:00">2023-10-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="汇编实验（DOSBox-MASM）"><a href="#汇编实验（DOSBox-MASM）" class="headerlink" title="汇编实验（DOSBox+MASM）"></a>汇编实验（DOSBox+MASM）</h1><p>在编辑器下写好代码（asm文件，assembly（汇编语言）的文件）之后，进入DOSBox执行下面三条指令，例如file_name.asm已经编写好了</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MASM file_name</span><br><span class="line"></span><br><span class="line">LINK file_name</span><br><span class="line"></span><br><span class="line">file_name</span><br></pre></td></tr></tbody></table></figure>

<p>分别是编译，连接，执行</p>
<p>在MASMPlus写完代码，应该放进<strong>MASM64</strong>文件夹，然后才能在DOSBox里面用上面方法运行</p>
<h2 id="汇编语言的语法"><a href="#汇编语言的语法" class="headerlink" title="汇编语言的语法"></a>汇编语言的语法</h2><p>实验使用的汇编语言的版本是8086汇编语言，跟现代汇编语言在语法上大致相同，关键词有点儿变更</p>
<h3 id="实验一（字符串比较）"><a href="#实验一（字符串比较）" class="headerlink" title="实验一（字符串比较）"></a>实验一（字符串比较）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">datarea segment                       		; 定义数据段</span><br><span class="line">    string1 db 'Move the cursor backward.'	;db是伪指令，分配数据大小的</span><br><span class="line">    string2 db 'Move the cursor forward.'</span><br><span class="line">    ;</span><br><span class="line">    mess1   db 'Match.',13,10,'$''$'    ; 匹配消息</span><br><span class="line">    mess2   db 'No match!',13,10,'$''$' ; 不匹配消息</span><br><span class="line">datarea ends</span><br><span class="line"></span><br><span class="line">prognam segment                        		; 定义代码段</span><br><span class="line">    main proc far							;远进程段</span><br><span class="line">        assume cs:prognam, ds:datarea, es:datarea</span><br><span class="line">    start:                                	; 程序入口点</span><br><span class="line">        ; 保存旧数据段</span><br><span class="line">        push   ds</span><br><span class="line">        sub    ax, ax						;ax=ax-ax=0,实际上就是置零指令</span><br><span class="line">        push   ax</span><br><span class="line"></span><br><span class="line">        ; 设置 DS 和 ES 段寄存器</span><br><span class="line">        mov    ax, datarea                ; 数据段地址</span><br><span class="line">        mov    ds, ax                     ; DS 寄存器</span><br><span class="line">        mov    es, ax                     ; ES 寄存器</span><br><span class="line"></span><br><span class="line">        ; 比较字符串</span><br><span class="line">        lea    si, string1                ; SI 指向 string1</span><br><span class="line">        lea    di, string2                ; DI 指向 string2</span><br><span class="line">        cld                               ; 清除方向标志位，从左到右比较</span><br><span class="line">        mov    cx, 25                     ; 比较的字符数</span><br><span class="line">        repz   cmpsb                      ; 比较字符串</span><br><span class="line">        jz     match                      ; 如果相等，跳转到 match 标签</span><br><span class="line">        lea    dx, mess2                  ; 不相等，加载 mess2 地址</span><br><span class="line">        jmp    short disp                ; 跳转到 disp 标签</span><br><span class="line"></span><br><span class="line">    match:								  ;跳转标签</span><br><span class="line">        lea    dx, mess1                  ; 相等，加载 mess1 地址</span><br><span class="line"></span><br><span class="line">    disp:								  ;display,显示</span><br><span class="line">        mov    ah, 09                    ; 设置功能码为 9，用于显示字符串</span><br><span class="line">        int    21h                       ; 调用 DOS 中断显示消息</span><br><span class="line"></span><br><span class="line">        ret                               ; 返回到 DOS</span><br><span class="line">    main endp                             ; 结束主程序</span><br><span class="line">prognam ends                             	; 结束代码段</span><br><span class="line">end start                                ; 程序结束标记</span><br></pre></td></tr></tbody></table></figure>

<p>注意这里有一个系统调用，经过<strong>查看中断表INT 21H</strong>，可以知道<code>mov    ah, 09</code>就是调用了09的系统功能，<strong>显示了字符串</strong>。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>汇编的注释是”;”</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;注释内容</span><br></pre></td></tr></tbody></table></figure>

<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><h4 id="datarea"><a href="#datarea" class="headerlink" title="datarea"></a>datarea</h4><p>datarea=data area，数据段</p>
<p><strong>数据段定义：</strong> 数据段是用于存储数据的部分，以<code>datarea segment</code>开始，以<code>datarea ends</code>结束。</p>
<h4 id="prognam"><a href="#prognam" class="headerlink" title="prognam"></a>prognam</h4><p>“prognam” 的全拼是 “program name”，表示程序的名称。</p>
<h3 id="ASSUME"><a href="#ASSUME" class="headerlink" title="ASSUME"></a>ASSUME</h3><p><code>ASSUME</code> 是一种指令或伪指令，用于建立代码段（<code>CS</code>）、数据段（<code>DS</code>）、附加段（<code>ES</code>）、堆栈段（<code>SS</code>）等不同段寄存器和段寄存器组合之间的关联。这是一种在8086汇编语言和一些后续x86架构中的寄存器分段模型中使用的机制。</p>
<p>以下是 <code>ASSUME</code> 指令的详解：</p>
<ol>
<li><p><strong>语法：</strong> <code>ASSUME seg_reg: seg_name</code>，其中 <code>seg_reg</code> 是段寄存器（如 <code>CS</code>、<code>DS</code>、<code>ES</code>、<code>SS</code> 等），而 <code>seg_name</code> 是段的名称或标签。</p>
</li>
<li><p><strong>作用：</strong> <code>ASSUME</code> 指令建立了一个假设或关联，告诉汇编器哪个段寄存器应与哪个段相关联。这是为了在编译时确定代码和数据的位置，以便在生成机器代码时能够正确地生成内存地址。</p>
</li>
<li><p><strong>用途：</strong> <code>ASSUME</code> 指令通常在程序开头的数据段（<code>DATA</code>）中使用，以确保代码段和数据段的正确关联。例如，代码段（<code>CS</code>）通常与程序代码相关联，数据段（<code>DS</code>）通常与程序数据相关联。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assume cs:prognam, ds:datarea, es:datarea</span><br></pre></td></tr></tbody></table></figure>

<p>在这个示例中，<code>CS</code> 寄存器被关联到 <code>prognam</code> 段，<code>DS</code>和<code>ES</code> 寄存器被关联到 <code>datarea</code> 段。这意味着汇编器将使用这些关联来生成正确的内存地址，以便在程序执行时能够访问正确的代码和数据。</p>
</li>
</ol>
<p>在现代的x86汇编中，由于分段模型的变化，通常不再需要显式使用 <code>ASSUME</code>，因为多数情况下，汇编器会根据段声明自动推断关联。但在一些情况下，特别是在使用老旧的编译器和汇编器时（实验环境），可能需要手动设置关联。</p>
<h3 id="db-dw-dd"><a href="#db-dw-dd" class="headerlink" title="db,dw,dd"></a>db,dw,dd</h3><p>在汇编语言中，<code>db</code> 是一个伪指令（directive），用于定义数据。具体地，<code>db</code> 表示 “define byte”，它用于将一个或多个字节（8位）的数据分配给指定的标识符。其他常用的伪指令还包括 <code>dw</code>（define word，用于定义16位数据）、<code>dd</code>（define doubleword，用于定义32位数据）等，它们用于分配不同大小的数据。</p>
<ol>
<li><p><strong><code>assume</code> 段寄存器指令：</strong> 在程序的开始，<code>assume cs:prognam, ds:datarea, es:datarea</code>用于关联代码段（<code>cs</code>）和数据段（<code>ds</code>、<code>es</code>）的寄存器。这表明代码段和数据段使用相同的内存段，可以相互访问。</p>
</li>
<li><p><strong>栈操作：</strong> 该程序使用栈来保存和还原数据段寄存器的值。<code>push</code>指令用于将数据保存在栈中，<code>pop</code>指令用于将数据弹出栈。这是为了保护程序的状态。</p>
</li>
<li><p><strong>寄存器操作：</strong> <code>ax</code> 寄存器用于存储零值。<code>mov</code> 指令用于将数据加载到寄存器中，例如，<code>mov ax, datarea</code> 将 <code>ax</code> 设置为数据段的地址。</p>
</li>
<li><p><strong>字符串比较：</strong> 使用字符串比较指令，<code>cld</code> 用于确保比较从左到右进行。然后，<code>repz cmpsb</code> 用于比较两个字符串，直到出现不匹配或达到指定的字符数（<code>cx</code> 寄存器中的值）。如果两个字符串匹配，<code>jz match</code> 将跳转到 <code>match</code> 标签，否则跳转到 <code>disp</code> 标签。</p>
</li>
<li><p><strong>消息显示：</strong> <code>lea dx, mess1</code> 或 <code>lea dx, mess2</code> 用于加载消息的地址到 <code>dx</code> 寄存器。接着，<code>mov ah, 09</code> 设置功能码，表示要显示字符串，然后使用 <code>int 21h</code> 来调用DOS中断以显示消息。</p>
</li>
<li><p><strong>返回：</strong> <code>ret</code> 用于返回到DOS。程序的入口点是 <code>start</code> 标签，而 <code>end start</code> 表明程序的结束点。</p>
</li>
</ol>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40843865/article/details/81210164">汇编指令详解-CSDN博客</a></p>
<p>下面列出实验一的一些指令</p>
<p><strong>(1) LEA(Load Effective Address)</strong><br>    格式：   lea REG,OPRD        <br>    功能：   把操作数OPRD的<font color="cornflowerblue">有效地址</font>传送到操作数REG<br>     注：    REG必须是16位通用寄存器，OPRD必须是一个存储器操作数<br> <br>     如：    lea ax,buf            ;buf是变量名<br>            lea ax,[si+2]</p>
<p><strong>(4) CLD(Clear Direction Flag):            DF置0，执行串操作指令时，地址递增</strong></p>
<p><strong><code>REPZ CMPSB</code> 是x86汇编语言中的一个指令序列，用于比较两个内存中的字符串并返回比较结果</strong>。以下是对该指令的详细解释：</p>
<ol>
<li><p><code>REPZ</code> 前缀：<code>REPZ</code> 是一个前缀指令，用于控制<strong>重复执行后续的指令</strong>。它基本上表示”<strong>repeat while zero</strong>“，即只要 <code>ZF</code>（零标志位）标志为1（表示相等），就重复执行后续的指令。如果 <code>ZF</code> 标志变为0（表示不相等），则停止重复执行。</p>
</li>
<li><p><code>CMPSB</code> 指令：<code>CMPSB</code> 是比较字符串指令，用于比较 <code>DS:SI</code> 指向的字节和 <code>ES:DI</code> 指向的字节，并根据比较结果更新一些寄存器和标志。在这里，<code>DS</code> 和 <code>ES</code> 是数据段寄存器，<code>SI</code> 和 <code>DI</code> 是源和目的地偏移地址寄存器。</p>
<ul>
<li><code>CMPSB</code> 会比较 <code>DS:SI</code> 和 <code>ES:DI</code> 指向的字节。</li>
<li>如果两个字节相等，它会设置 <code>ZF</code> 标志位为1（表示相等），否则为0（表示不相等）。</li>
<li>它还会根据 DF 标志位（方向标志位）的值来决定是向前比较（DF=0）还是向后比较（DF=1）。</li>
<li>然后，它会递增或递减 <code>SI</code> 和 <code>DI</code> 的值，取决于 DF 标志位的值，以便指向下一个要比较的字节。</li>
</ul>
</li>
</ol>
<p>在 <code>REPZ CMPSB</code> 指令序列中，重复执行 <code>CMPSB</code> 指令直到 <code>ZF</code> 标志变为0。这意味着它会持续比较两个字符串中的字节，直到找到不匹配的字节或直到达到字符串的末尾。</p>
<p>如果两个字符串完全相等，<code>REPZ</code> 指令将在比较结束后停止，<code>ZF</code> 标志将保持为1，表示字符串相等。如果字符串不相等或任何一个字符串的长度小于 <code>CX</code> 寄存器中的计数，<code>REPZ</code> 将停止，<code>ZF</code> 标志将变为0，表示字符串不相等。</p>
<p>在实验1中，<code>repz cmpsb</code> 的目的是比较 <code>string1</code> 和 <code>string2</code> 中的字符，直到找到不匹配的字符或两个字符串都完全匹配。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.liwuxuanplus.com/2023/10/19/hui-bian-yu-yan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liwuxuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MySite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/19/hui-bian-yu-yan/" class="post-title-link" itemprop="url">汇编语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-19 22:57:50" itemprop="dateCreated datePublished" datetime="2023-10-19T22:57:50+08:00">2023-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-13 19:39:45" itemprop="dateModified" datetime="2023-12-13T19:39:45+08:00">2023-12-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h3 id="8086的字节和字"><a href="#8086的字节和字" class="headerlink" title="8086的字节和字"></a>8086的字节和字</h3><p>8086一个字节是8位（在哪里都不会变），但是8086的一个字是16位，也就是两个字节</p>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>注意：默认小端存储，低位低放，高位高放</p>
<h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104213821128.png" alt="image-20231104213821128"></p>
<h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><p>源操作数与目的操作数字长一致。</p>
<p> 任何操作数不能是IP、FLAGS，目的操作数不能是CS。（有专用指令）</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104214357160.png" alt="image-20231104214357160"></p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231017141209086.png" alt="image-20231017141209086"></p>
<p><strong>AX、BX、CX、DX 通常用来存放一般性数据被称为通用寄存器（16位）</strong></p>
<p>由于8086初期是8位，为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。</p>
<p>​	AX可以分为AH和AL；</p>
<p>​	BX可以分为BH和BL；</p>
<p>​	CX可以分为CH和CL；</p>
<p>​	DX可以分为DH和DL。</p>
<p>AX的低8位（0位<del>7位）构成了AL寄存器，高8位（8位</del>15位）构成了AH寄存器</p>
<p>段地址×16（也就是二进制左移4位）+偏移地址=物理地址，物理地址20位，段地址16位</p>
<p>内存没有分段，只是CPU用段地址记录物理地址</p>
<p>段的起始地址（不是段地址，段地址是去掉末位）必然是xxxx0H（16的倍数），偏移地址16位，所以段长度最多64K</p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>段寄存器就是提供段地址的</p>
<p>8086CPU有4个段寄存器：</p>
<p>​		 CS、DS、SS、ES</p>
<p>当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018224509342.png" alt="image-20231018224509342"></p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018225526532.png" alt="image-20231018225526532"></p>
<h3 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h3><p><strong>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址</strong></p>
<p>​	CS为代码段寄存器</p>
<p>​	IP为指令指针寄存器</p>
<table>
<thead>
<tr>
<th align="center">8086PC工作过程的简要描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">（1）<strong>从CS:IP指向内存单元读取指令</strong>，读取的指令进入指令缓冲器；<br>（2）IP = IP + 所读取指令的长度，从而指向下一条指令；<br>（3）执行指令。 转到步骤 （1），重复这个过程。</td>
</tr>
</tbody></table>
<blockquote>
<p>tip:</p>
<p>在 8086CPU 加电启动或复位后（ 即 CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行，<strong>FFFF0H单元中的指令是8086PC机开机后执行的第一条指令</strong></p>
</blockquote>
<p>CPU将CS:IP指向的内存单元中的内容看作指令</p>
<p>怎么修改CS:IP?</p>
<p>mov指令不能用于设置CS、IP的值，   8086CPU没有提供这样的功能。8086修改CS:IP的指令是转移指令（jmp等）</p>
<p>8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。若有内存被CPU访问，则该内存一定被CS:IP指向过</p>
<h3 id="DS"><a href="#DS" class="headerlink" title="DS"></a>DS</h3><p>执行指令时，8086CPU自动取DS中的数据为内存单元的段地址</p>
<p>​		mov [0],ax即将ax寄存器数据存到DS:0位置</p>
<p>8086CPU中有一个 DS寄存器，通常用来存放<strong>要访问的数据的段地址</strong>。</p>
<p>mov指令的格式：      </p>
<p>​			mov 寄存器名，[内存单元地址]</p>
<p>“[…]”表示一个内存单元， “[…]”中的数字表示内存单元的偏移地址。</p>
<p><font color="red"><strong>8086CPU不支持将数据直接送入段寄存器的操作</strong></font></p>
<p><strong>数据➡️一般的寄存器➡️段寄存器</strong></p>
<h2 id="和-的应用"><a href="#和-的应用" class="headerlink" title="[]和()的应用"></a>[]和()的应用</h2><p>[bx]表示一个内存单元（存储器操作数），它的偏移地址在bx中，比如下面的指令：mov ax,[bx]</p>
<p>ax中的内容为0010H，我们可以这样来描述：(ax)=0010H； </p>
<p>也可以这样说，[]一般出现在指令里面&lt;偏移地址&gt;，()一般出现在计算里面&lt;内容数据&gt;</p>
<table>
<thead>
<tr>
<th align="left">mov [bx],ax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">功能：<br>bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。  即：(ds *16 +(bx))  =  (ax)。</td>
</tr>
</tbody></table>
<h2 id="SI和CI"><a href="#SI和CI" class="headerlink" title="SI和CI"></a>SI和CI</h2><p>SI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8 位寄存器来使用</p>
<p>一般默认SI源寄存器，DI目的寄存器</p>
<p>在“[…]” 中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di</p>
<p>只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231016230952500.png" alt="image-20231016230952500"></p>
<h2 id="控制寄存器（IP和FLAGS）"><a href="#控制寄存器（IP和FLAGS）" class="headerlink" title="控制寄存器（IP和FLAGS）"></a>控制寄存器（IP和FLAGS）</h2><p><strong>IP</strong> 指定将IP用于指令地址记录，即Instruction Pointer。每次取指后都自增1。</p>
<p><strong>FLAGS</strong> 指定将FLAGS用作程序状态指示，也即PSW（Program Status Word）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018224328803.png" alt="image-20231018224328803"></p>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018230055341.png" alt="image-20231018230055341"></p>
<h3 id="PTR什么时候用？"><a href="#PTR什么时候用？" class="headerlink" title="PTR什么时候用？"></a><code>PTR</code>什么时候用？</h3><p>有寄存器时不用，无寄存器（包含【bx】）时要使用，防止源操作数和目的操作数位数不一致</p>
<p><code>BYTE PTR</code>指明是要赋单字节值</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36561697/article/details/80698875">https://blog.csdn.net/qq_36561697/article/details/80698875</a></p>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><h3 id="1-立即寻址"><a href="#1-立即寻址" class="headerlink" title="1.立即寻址"></a>1.立即寻址</h3><p>操作数直接存放在指令中，立即寻址方式用来表示常数，它经常用于给寄存器赋初值，并且只能用于源操作数字段，不能用于目的操作数字段，且源操作数 长度 应与目的操作数 长度一致。</p>
<p><strong>例子：MOV AX, 3064H</strong> </p>
<h3 id="2-寄存器寻址"><a href="#2-寄存器寻址" class="headerlink" title="2.寄存器寻址"></a>2.寄存器寻址</h3><p>操作数 在寄存器中，指令指定寄存器号。 </p>
<p>对于16位操作数，寄存器可以是AX,BX,CX,DX,SI,DI,SP和BP；</p>
<p>对于8位操作数，寄存器可以是AL,AH, BL, BH, CL, CH, DL,DH；</p>
<p><strong>例子：MOV AX, BX</strong> </p>
<h3 id="3-直接寻址"><a href="#3-直接寻址" class="headerlink" title="3.直接寻址"></a>3.直接寻址</h3><p>操作数的有效地址只包含位移量一种成分(位移量（displacement)是存放在指令中的一个 8位、16位或 32位的数，但它不是立即数，而是一个地址。区别在于<strong>位移量加[	]</strong>	)，其值就存放在代码段中指令的操作码之后，位移量的值即操作数的有效地址</p>
<p><strong>例子：MOV AX,[2000H]</strong></p>
<h3 id="4-寄存器间接寻址"><a href="#4-寄存器间接寻址" class="headerlink" title="4.寄存器间接寻址"></a>4.寄存器间接寻址</h3><p>操作数的有效地址只包含基址寄存器内容或变址寄存器内容一种成分。 因此，<strong>有效地址就在某个寄存器中</strong>，而<strong>操作数则在存储器</strong>中</p>
<p><strong>例子：MOV AX，[BX]</strong></p>
<p>没有特殊说明（段跨越前缀），默认段寄存器为DS（BP和SP的时候默认是SS）</p>
<p>假设（DS）=2000H，（BX）=1000H，物理地址EA=（DS）&lt;&lt;4+(BX)=21000H</p>
<p>则(AX)=50A0H，<strong>一定要注意EA是地址，操作数是（EA）</strong>，<strong>AX赋值是操作数赋值</strong>，EA只是用来寻址的</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231019223728313.png" alt="image-20231019223728313"></p>
<h3 id="5-寄存器相对寻址"><a href="#5-寄存器相对寻址" class="headerlink" title="5.寄存器相对寻址"></a>5.寄存器相对寻址</h3><p>操作数的有效地址为基址寄存器或变址寄存器的内容和指令中指定的位移量之和， 所以有效地址由两种成分组成。</p>
<p><strong>例子：MOV AX, COUNT[SI]</strong> （也可表示为<strong>MOV AX, [COUNT+SI])</strong>	其中<strong>COUNT为16位位移量的符号地址。</strong></p>
<p><strong>MOV AX, [BX+10]</strong></p>
<p>如果 (DS) = 3000H, （SI）= 2000H, COUNT= 3000H</p>
<p>则物理地址EA＝30000+2000+3000= 35000H </p>
<h3 id="6-基址变址寻址"><a href="#6-基址变址寻址" class="headerlink" title="6.基址变址寻址"></a>6.基址变址寻址</h3><p>操作数的有效地址是一个基址寄存器和一个变址寄存器的内容之和，所以有效地址由两种成分组成</p>
<p><strong>例子：MOV AX, [BX] [DI] （或写为 ：MOV AX, [BX+ DI]	)</strong></p>
<p>如(DS)= 2100H, （BX) = 0158H, (DI)= 10A5H<br>则EA= 0158+10A5= 11FDH，物理地址＝21000+11FD= 221FDH </p>
<p>执行结果(AX)=1234H</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231019225016657.png" alt="image-20231019225016657"></p>
<h3 id="7-相对基址变址寻址"><a href="#7-相对基址变址寻址" class="headerlink" title="7.相对基址变址寻址"></a>7.相对基址变址寻址</h3><p>操作数的有效地址是一个基址寄存器与一个变址寄存器的内容和指令中指定的位移量之和，所以有效地址由三种 成分组成。</p>
<p><strong>例子：MOV MASK[BX] [SI]（也可写成MOV AX, MASK[BX+SI]或MOV AX, [MASK+BX+ SI])</strong></p>
<p>如（DS)= 3000H, (BX)= 2000H, (SI）= 1000H，MASK= 0250H, </p>
<p>则 物理地址<strong>EA＝（DS)&lt;&lt;4	+(BX)+(SI）+MASK</strong><br>= 30000+2000+1000+0250 = 33250H<br>执行结果(AX)= 1234H。<br><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231019225646835.png" alt="image-20231019225646835"></p>
<h2 id="存储器寻址"><a href="#存储器寻址" class="headerlink" title="存储器寻址"></a>存储器寻址</h2><p><strong><font color="red">一个指令不能有两个存储器操作数</font></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104220620156.png" alt="image-20231104220620156"></p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104220640105.png" alt="image-20231104220640105"></p>
<h3 id="PTR什么时候用？-1"><a href="#PTR什么时候用？-1" class="headerlink" title="PTR什么时候用？"></a><code>PTR</code>什么时候用？</h3><p>有寄存器时不用，无寄存器（包含【bx】）时要使用，防止源操作数和目的操作数位数不一致</p>
<p><code>BYTE PTR</code>指明是要赋单字节值</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36561697/article/details/80698875">https://blog.csdn.net/qq_36561697/article/details/80698875</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104221244053.png" alt="image-20231104221244053"></p>
<h2 id="控制转移寻址"><a href="#控制转移寻址" class="headerlink" title="控制转移寻址"></a>控制转移寻址</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104221750451.png" alt="image-20231104221750451"></p>
<h3 id="SHORT和FAR什么时候用"><a href="#SHORT和FAR什么时候用" class="headerlink" title="SHORT和FAR什么时候用"></a>SHORT和FAR什么时候用</h3><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104221830111.png" alt="image-20231104221830111"></p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104222152841.png" alt="image-20231104222152841"></p>
<p>看看PPT（第3章）记忆吧，总不能把这个文档全贴上图，这里仅仅放了near和far，因为经常见到，算是备忘录吧</p>
<h2 id="数据移动"><a href="#数据移动" class="headerlink" title="数据移动"></a>数据移动</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104222419547.png" alt="image-20231104222419547"></p>
<p>注意段寄存器需要寄存器间接，可以说是设计上的缺陷吧，或者其他什么原因。注意CS是不能寄存器直接改的，但是DS和ES是可以的，只要注意固定搭配</p>
<h2 id="指令大全"><a href="#指令大全" class="headerlink" title="指令大全"></a>指令大全</h2><p>看第4讲PPT</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231105193717038.png" alt="image-20231105193717038"></p>
<h2 id="以字节对齐"><a href="#以字节对齐" class="headerlink" title="以字节对齐"></a>以字节对齐</h2><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20231105195609620.png" alt="image-20231105195609620"></p>
<p>在汇编语言中，<code>BX</code> 寄存器通常用来存储地址或偏移量。乘以2（SHL BX, 1）可能是因为<strong>查找表中的条目是按字（Word）大小存储的</strong>，而字的大小通常是2个字节（16位），因此需要将 <code>BX</code> 乘以2以获得正确的<strong>字节偏移</strong>。</p>
<p><strong><font color="DarkVoilet">这是因为在汇编语言中，地址通常是按字节而不是字（Word）对齐的。</font></strong><font color="MediumVioletRed">查找表的每个条目都是字大小的</font>，因此如果你要访问查找表中的一个条目，你需要考虑每个条目的大小，通常是2个字节，所以需要将 <code>BX</code> 乘以2以得到正确的字节偏移。这确保了你在查找表中正确地访问到所需的条目。</p>
<p>当你在程序中执行 <code>SHL BX, 1</code> 操作时，实际上是将 <code>BX</code> 寄存器的值左移一位，相当于将其乘以2。这是一种常见的操作，用于计算地址偏移量，以便访问数组、查找表或其他内存结构中的元素。这可以确保访问到正确的数据，以执行条件分支操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.liwuxuanplus.com/2023/10/10/sou-suo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liwuxuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MySite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/10/sou-suo/" class="post-title-link" itemprop="url">搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-10-10 18:10:03 / 修改时间：20:02:29" itemprop="dateCreated datePublished" datetime="2023-10-10T18:10:03+08:00">2023-10-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43590232/article/details/104735102">https://blog.csdn.net/weixin_43590232/article/details/104735102</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3332947/what-are-the-practical-factors-to-consider-when-choosing-between-depth-first-sea">https://stackoverflow.com/questions/3332947/what-are-the-practical-factors-to-consider-when-choosing-between-depth-first-sea</a></p>
<p><strong>BFS适用于需要找到最短路径或距离起点最近的解决方案的问题，而DFS适用于需要深度探索或搜索所有可能解决方案的问题。</strong></p>
<p><strong>BFS通常只用来找一个解决方案，DFS用来找所有解决方案。</strong>BFS当然可以搜索所有解决方案，而且时间复杂度跟DFS相同，但是BFS的空间复杂度比DFS高太多了。</p>
<p>BFS和DFS的相邻点 有的时候很明显，有的时候不明显，需要自己总结一下。在做CSP题时，基本上没有明显的节点，都是需要抽象出来树形结构的</p>
<p><strong>做题第一步，纸上写出树形结构，分别考虑边和点。边考虑回溯，点考虑BFS和DFS。一定要考虑记忆化搜索和剪枝，不然一般都会超时。</strong></p>
<h2 id="BFS-最短路径问题"><a href="#BFS-最短路径问题" class="headerlink" title="BFS(最短路径问题)"></a>BFS(最短路径问题)</h2><h3 id="BFS问题的本质都是找从start到target的最短路"><a href="#BFS问题的本质都是找从start到target的最短路" class="headerlink" title="BFS问题的本质都是找从start到target的最短路"></a><code>BFS</code>问题的本质都是找从<code>start</code>到<code>target</code>的最短路</h3><p>如果是找最短路径，第一时间想<code>BFS</code>，注意是<code>短</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>{</span><br><span class="line">    queue&lt;Node&gt; q; </span><br><span class="line">    unordered_set&lt;Node&gt; visited;<span class="comment">//一般是用bool vis[size];用1表示自己去过了,数组访问O(1)。不过unordered_set也差不多。</span></span><br><span class="line">    <span class="comment">//一般是用数组。但是一些问题的索引不好确认，用unordered_set更好，普适性更好一些，但是需要确认元素是否重复（用值时）</span></span><br><span class="line">    q.<span class="built_in">push</span>(start); </span><br><span class="line">    <span class="comment">//visited.insert(start);//有时候写上会有问题，有了下面的，这里不要写了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) {</span><br><span class="line">            Node cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            visited.<span class="built_in">insert</span>(cur);<span class="comment">//必要</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cur == target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.<span class="built_in">adj</span>()) {<span class="comment">//不管是 邻接表 还是邻接数组 还是链式前向星 都要会写</span></span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">count</span>(x) == <span class="number">0</span>) {</span><br><span class="line">                    q.<span class="built_in">push</span>(x);</span><br><span class="line">                    visited.<span class="built_in">insert</span>(x);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果走到这里，说明在图中没有找到目标节点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>BFS</code>的<code>vis</code>数组一般只加不减，<code>vis</code>只是用来指示	邻接点	是否已经遍历过了</p>
<h2 id="BFS优化（双向BFS）"><a href="#BFS优化（双向BFS）" class="headerlink" title="BFS优化（双向BFS）"></a><code>BFS</code>优化（双向<code>BFS</code>）</h2><p><strong>前提：已经知道终点，从起点和终点分别开始<code>BFS</code>，可以降低	大约一半<code>空间复杂度</code>和<code>时间复杂度</code>。这种技巧实际上并没有降低big O时间复杂度。用BFS还是双向BFS看情况吧。</strong></p>
<p>双向 BFS 还是遵循 BFS 算法框架的，只是<strong>不再使用队列，而是使用<code>unordered_set</code>方便快速判断两个集合q1、q2是否有交集。起点和终点分别加入<code>unordered_set</code>，遍历一个集合的时候，判断另一个集合是否有该元素。</strong>。</p>
<p>另外的一个技巧点就是 <strong>while 循环 <code>while( !q1.empty()&amp;&amp;!q2.empty()  )</code>的最后交换 <code>q1</code> 和 <code>q2</code> 的内容</strong>，所以只要默认扩散 <code>q1</code> 就相当于轮流扩散 <code>q1</code> 和 <code>q2</code>。			或者 可以加一个<strong>判定<code>if (q1.size() &gt; q2.size()) </code>交换，仍然默认<code>q1</code>，但每次使用最小的集合</strong>。跟上边没什么区别。</p>
<p><strong>必掌握：求“最短路径”</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>{</span><br><span class="line">    unordered_set&lt;Node&gt; q1, q2, visited;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;<span class="comment">//记录路径长度</span></span><br><span class="line">    q1.<span class="built_in">insert</span>(start);</span><br><span class="line">    q2.<span class="built_in">insert</span>(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()){</span><br><span class="line">        <span class="comment">// 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果</span></span><br><span class="line">        unordered_set&lt;string&gt; temp;<span class="comment">//现在是q1遍历后的q1，相当于clear了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将 q1 中的所有节点向周围扩散 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> cur : q1){</span><br><span class="line">            <span class="comment">/* 判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span>(q2.<span class="built_in">count</span>(cur))</span><br><span class="line">                <span class="keyword">return</span> step;<span class="comment">//q1、q2相交，代表找到了</span></span><br><span class="line"></span><br><span class="line">            visited.<span class="built_in">insert</span>(cur);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将一个节点的未遍历相邻节点加入集合 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.<span class="built_in">adj</span>()) {<span class="comment">//不管是 邻接表 还是邻接数组 还是链式前向星 都要会写</span></span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">count</span>(x) == <span class="number">0</span>) {</span><br><span class="line">                    temp.<span class="built_in">push</span>(x);<span class="comment">//注意：应该是往temp里面加入元素</span></span><br><span class="line">                    visited.<span class="built_in">insert</span>(x);</span><br><span class="line">                }</span><br><span class="line">       		}</span><br><span class="line">        <span class="comment">/* 在这里增加步数 */</span></span><br><span class="line">        step++;</span><br><span class="line">        <span class="comment">// temp 相当于 新的 q1</span></span><br><span class="line">        <span class="comment">// 这里交换 q1 q2，下一轮 while 就是扩散 q2</span></span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/search/astar/">A* - OI Wiki (oi-wiki.org)</a></p>
<p>这里涉及到了一个启发式搜索</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a><code>DFS</code></h2><p>DFS和回溯一般都是混用的，大家没严格区分</p>
<p>时间复杂度较高，但是可以拿部分的分 </p>
<p>本质上是 暴力穷举，递归函数，跟回溯基本一致。不要特别在意区分回溯和<code>DFS</code>，只要能做题就行。一般都是void，不用到返回值。</p>
<p><strong><code>DFS</code>必掌握“N皇后问题、全排列”</strong>，呃，这俩都是回溯</p>
<p>一般不会求最值，没有最优子结构</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> vis[N];<span class="comment">//DFS经常用到，当然也可以用unordered_map</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (终止条件) {</span><br><span class="line">      处理语句</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">    <span class="keyword">for</span> (邻接点) {</span><br><span class="line">        <span class="keyword">if</span>(下一步有效)<span class="comment">//一般是 !vis[i]</span></span><br><span class="line">        {</span><br><span class="line">            处理</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">      			<span class="built_in">dfs</span>(参数);</span><br><span class="line">      		撤销处理</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>就是二叉树遍历的<code>void traverse()</code>函数</p>
<p><strong>一般情况下，回溯算法的「做选择」和「撤销选择」在 for 循环里面，而<code>DFS</code>的操作在 for 循环外面。这是回溯算法和 DFS 算法的区别所在：回溯算法关注的不是节点，而是树枝（也可以说边，就是for里面 的路径选择）。而DFS只处理本身节点的选择和撤销选择。二者的区别在于根节点，DFS会处理和撤销处理根节点，但是回溯不行（回溯关注的是边，边数=点数-1（无环图成立，但是回溯等一般的 图算法都会visited掉环，所以对回溯是永远会漏掉根节点（大概？） ），回溯会漏掉根节点）。</strong></p>
<p>dfs和回溯都是void遍历+外部变量，动态规划是有返回值的（后序遍历）。相同点是都要在前序位置（入栈前判断，判断是否入栈）写判定条件（一定要考虑好边界条件），在后面写的时候，哪怕判断条件重复，实际上也不会影响算法效率。</p>
<p>通过选边还是选点，选择回溯或者DFS</p>
<h3 id="非明显节点型"><a href="#非明显节点型" class="headerlink" title="非明显节点型"></a>非明显节点型</h3><h4 id="1-排列组合问题"><a href="#1-排列组合问题" class="headerlink" title="1.排列组合问题"></a>1.排列组合问题</h4><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231008203914915.png" alt="image-20231008203914915"></p>
<p><strong>边问题，回溯</strong></p>
<p>求一个数组的全排列，这个要注意一点，vis标记与撤销，vis不能不撤销，那样会导致其他分支被剪掉，从而只会剩下一个排列。</p>
<h4 id="2-表格型（棋盘型、迷宫型）"><a href="#2-表格型（棋盘型、迷宫型）" class="headerlink" title="2.表格型（棋盘型、迷宫型）"></a>2.表格型（棋盘型、迷宫型）</h4><p>典型：“N皇后”问题</p>
<p>关键步骤：找到遍历逻辑（怎么遍历），至于皇后不能攻击、迷宫墙不能通过……这些问题是后期限制条件(if语句、剪枝)，前期不用管。</p>
<p>遍历逻辑——&gt;转化为树形结构（图本身也算树形大类）</p>
<p><strong>根节点为空，考虑回溯（抽象为边，边问题的根节点是空的）。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231008210924883.png" alt="image-20231008210924883"></p>
<p>N皇后一般思路：每行取一个皇后，这个皇后可以在该行的每个列（只要不在另一个皇后的攻击范围）——&gt; 后面加<code>if</code>限制条件。</p>
<p> <strong>在宽度优先和深度优先搜索里面，我们都是根据搜索的顺序依次进行搜索，可以称为盲目搜索，搜索效率非常低。</strong></p>
<p>而启发式搜索则大大提高了搜索效率，但启发式搜索可能很繁琐</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/isguxing/p/9800490.html">https://www.cnblogs.com/isguxing/p/9800490.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.liwuxuanplus.com/2023/10/07/gen-ju-shu-ju-gu-suan-shi-jian-fu-za-du/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liwuxuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MySite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/07/gen-ju-shu-ju-gu-suan-shi-jian-fu-za-du/" class="post-title-link" itemprop="url">根据数据估算时间复杂度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-10-07 12:43:12 / 修改时间：13:13:24" itemprop="dateCreated datePublished" datetime="2023-10-07T12:43:12+08:00">2023-10-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>前提：一般都是1秒对应一千万次计算（也可能是一亿）</strong></p>
<p>拿题目数据规模反推大概用个啥算法用些啥优化。</p>
<p><strong>10^5级别？基本上是O(nlogn)；10^7?那必须O(n)了；10^3基本上不就是个O(n^2)；蹦跶出来个诸如20以内的条件基本上就暴力了；如果俩参数范围一个才十几二十另一个成千上万基本上是个状态压缩DP类似的玩意了……诸如此类。</strong></p>
<p>就因为是竞赛，你得正反都能估啊……算法推得出复杂度，复杂度推得出算法什么的。</p>
<p>当然了也不仅仅是一个渐进最大时间复杂度，通常来说还需要熟悉平均时间复杂度……</p>
<p><a target="_blank" rel="noopener" href="https://liam.page/2016/06/20/big-O-cheat-sheet/">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.liwuxuanplus.com/2023/10/04/vector-suo-yin-wen-ti/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liwuxuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MySite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/04/vector-suo-yin-wen-ti/" class="post-title-link" itemprop="url">vector索引问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-10-04 21:17:13 / 修改时间：21:26:40" itemprop="dateCreated datePublished" datetime="2023-10-04T21:17:13+08:00">2023-10-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout&lt;&lt;<span class="string">"输入n"</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        cin&gt;&gt;temp;</span><br><span class="line">        v[i]=temp;<span class="comment">//这里会报错，因为v[i]还没有被定义，所以不能直接赋值，应该用push_back()函数</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="注意一个问题，以前一直理解错了。"><a href="#注意一个问题，以前一直理解错了。" class="headerlink" title="注意一个问题，以前一直理解错了。"></a>注意一个问题，以前一直理解错了。</h2><p><strong>C++里面vector必须分配空间后才能用索引，否则就会报错。不然就用push_back();</strong></p>
<p>以前一直以为会自动处理，要引起重视。</p>
<p>在 C++ 中，如果尝试访问一个尚未分配内存的 <code>vector</code> 的元素，会导致未定义行为。当创建一个空的 <code>vector&lt;int&gt; res;</code> 时，它没有分配任何内存空间来存储元素，因此尝试访问 <code>v[i]</code> 将导致问题。</p>
<p>如果不设置大小，<code>v</code> 将是一个空的、没有分配内存的 <code>vector</code>，尝试在其中存储数据会导致内存越界错误或其他未定义行为，这可能会导致程序崩溃或产生不可预测的结果。因此，在使用 <code>vector</code> 时，通常需要确保分配足够的内存空间来存储数据，以避免这类问题。</p>
<h2 id="普通数组计算长度"><a href="#普通数组计算长度" class="headerlink" title="普通数组计算长度"></a>普通数组计算长度</h2><p>在C++中，你可以使用以下方法来快速计算数组的长度：</p>
<ol>
<li>使用 <code>sizeof</code> 操作符：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br></pre></td></tr></tbody></table></figure>

<p>这种方法会返回数组的总字节数除以每个元素的字节数，从而得到数组的长度。</p>
<ol start="2">
<li>使用 <code>std::size</code> 函数（C++17及以上版本）：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> length = std::<span class="built_in">size</span>(arr);</span><br></pre></td></tr></tbody></table></figure>

<p><code>std::size</code> 是C++17及以上版本的标准库函数，它可以用于获取数组的长度。</p>
<ol start="3">
<li>如果你使用了 <code>std::vector</code> 或其他STL容器，可以使用容器的 <code>size</code> 成员函数来获取长度：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> length = vec.<span class="built_in">size</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>这些方法都可以快速计算数组或容器的长度，你可以根据你的编译环境和需求选择其中一种方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.liwuxuanplus.com/2023/10/04/shuang-zhi-zhen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liwuxuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MySite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/04/shuang-zhi-zhen/" class="post-title-link" itemprop="url">双指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-04 21:16:48" itemprop="dateCreated datePublished" datetime="2023-10-04T21:16:48+08:00">2023-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-06 22:16:17" itemprop="dateModified" datetime="2023-10-06T22:16:17+08:00">2023-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231005115512463.png" alt="image-20231005115512463"></p>
<h1 id="双指针专题"><a href="#双指针专题" class="headerlink" title="双指针专题"></a>双指针专题</h1><h2 id="一、快慢指针技巧（同向指针）"><a href="#一、快慢指针技巧（同向指针）" class="headerlink" title="一、快慢指针技巧（同向指针）"></a>一、快慢指针技巧（同向指针）</h2><h3 id="1、数组问题中比较常见的快慢指针技巧，是让你原地修改数组。"><a href="#1、数组问题中比较常见的快慢指针技巧，是让你原地修改数组。" class="headerlink" title="1、数组问题中比较常见的快慢指针技巧，是让你原地修改数组。"></a>1、数组问题中比较常见的快慢指针技巧，是让你<strong>原地修改</strong>数组。</h3><p>套路框架：fast遍历数组，遇到符合条件的抛给slow。（数组元素只能覆盖，不能删除）</p>
<h3 id="2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。"><a href="#2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。" class="headerlink" title="2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。"></a>2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。</h3><p>强调滑动窗口算法的快慢指针特性：</p>
<p><code>left</code> 指针在后，<code>right</code> 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s)</span> </span>{</span><br><span class="line">    <span class="comment">// 用合适的数据结构记录窗口中的数据</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) {</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        window.<span class="built_in">add</span>(c)</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="comment">// 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment">// 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"window: [%d, %d)\n"</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) {</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            window.<span class="built_in">remove</span>(d)<span class="comment">//应该是window[d]--;</span></span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度为<code>O(n)</code>：	指针 <code>left, right</code> 不会回退（它们的值只增不减），所以字符串/数组中的每个元素都只会进入窗口一次，然后被移出窗口一次，不会说有某些元素多次进入和离开窗口，所以算法的时间复杂度就和字符串/数组的长度成正比</p>
<hr>
<p><strong>滑动窗口算法的思路是这样</strong>：</p>
<p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」。</p>
<table>
<thead>
<tr>
<th>Tip</th>
</tr>
</thead>
<tbody><tr>
<td>理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 <code>left = right = 0</code> 时区间 <code>[0, 0)</code> 中没有元素，但只要让 <code>right</code> 向右移动（扩大）一位，区间 <code>[0, 1)</code> 就包含一个元素 <code>0</code> 了。如果你设置为两端都开的区间，那么让 <code>right</code> 向右移动一位后开区间 <code>(0, 1)</code> 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 <code>[0, 0]</code> 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。</td>
</tr>
</tbody></table>
<p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</p>
<p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p>
<p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p>
<hr>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解</strong>，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<p>下面画图理解一下，<code>needs</code> 和 <code>window</code> 相当于计数器，分别记录 <code>T</code> 中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<p>初始状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1.png" alt="img"></p>
<p>增加 <code>right</code>，直到窗口 <code>[left, right)</code> 包含了 <code>T</code> 中所有字符：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2.png" alt="img"></p>
<p>现在开始增加 <code>left</code>，缩小窗口 <code>[left, right)</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3.png" alt="img"></p>
<p>直到窗口中的字符串不再符合要求，<code>left</code> 不再继续移动：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4.png" alt="img"></p>
<p>之后重复上述过程，先移动 <code>right</code>，再移动 <code>left</code>…… 直到 <code>right</code> 指针到达字符串 <code>S</code> 的末端，算法结束。</p>
<hr>
<h4 id="常见环境：判断window里面的元素是否包含-子串-所有元素"><a href="#常见环境：判断window里面的元素是否包含-子串-所有元素" class="headerlink" title="常见环境：	判断window里面的元素是否包含 子串 所有元素"></a><strong>常见环境：	判断<code>window</code>里面的元素是否包含 子串 所有元素</strong></h4><p>对于 子串问题（字母有重复的）。添加<code>int valid</code>和<code>unordered_set&lt;char,int&gt; need</code>		<code>need</code>是子串的哈希表，记录子串字母和字母数目。</p>
<p>**在扩展窗口的时候，window添加后，当<code>window</code>里面对应字母数量等于子串对应的数量，<code>valid</code>加一。	**</p>
<p><strong>在缩小窗口的时候，在window缩小前，若<code>window</code>内字母数量等于<code>need</code>里面对应的数量时（	也就是缩小窗口后必小于need.size()	），<code>valid</code>减一。</strong></p>
<p>还有就是 <code>window</code>	<strong>一般	只需要记录子串元素，不用管其他元素</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need,window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i:t)need[i]++;<span class="comment">//已完成，不修改</span></span><br><span class="line">        <span class="type">int</span> valid=<span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> need_size=need.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,len=INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> right_value=s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(right_value))<span class="comment">//存在</span></span><br><span class="line">            {</span><br><span class="line">                window[right_value]++;</span><br><span class="line">                <span class="keyword">if</span>(window[right_value]==need[right_value])</span><br><span class="line">                valid++;<span class="comment">//加法判定</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(valid==need_size)<span class="comment">//可缩</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(len&gt;right-left)<span class="comment">//找最小</span></span><br><span class="line">                {</span><br><span class="line">                    start=left;</span><br><span class="line">                    len=right-left;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> delete_value=s[left];</span><br><span class="line">                left++;<span class="comment">//易忘</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(delete_value))<span class="comment">//存在</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span>(window[delete_value]==need[delete_value])</span><br><span class="line">                    {</span><br><span class="line">                        valid--;</span><br><span class="line">                    }</span><br><span class="line">                    window[delete_value]--;</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(len==INT_MAX)<span class="keyword">return</span> <span class="string">""</span>;<span class="comment">//易忘</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>注意小部件：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(need.<span class="built_in">count</span>(deleteleft))</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span>(window[deleteleft]==need[deleteleft])<span class="comment">//必须是先判断等于，因为这里的valid是一次性的。若后判断小于，则会出问题。</span></span><br><span class="line">	{</span><br><span class="line">		valid--;</span><br><span class="line">	}</span><br><span class="line">	window[deleteleft]--;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>类似的还有<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p>
<h4 id="常见环境：求窗口长度"><a href="#常见环境：求窗口长度" class="headerlink" title="常见环境：	求窗口长度"></a><strong>常见环境：	求窗口长度</strong></h4><p>注意窗口是<strong>左闭右开</strong>的，窗口长度一般是<code>right-left</code>。关键就是判断一下right此时是否在window</p>
<hr>
<h2 id="二、左右指针的常用算法（相向指针）"><a href="#二、左右指针的常用算法（相向指针）" class="headerlink" title="二、左右指针的常用算法（相向指针）"></a>二、左右指针的常用算法（相向指针）</h2><p>套路框架和二分差不多</p>
<h3 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a><strong>1、二分查找</strong></h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//右闭</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> mid = left+(right-left)&gt;&gt;<span class="number">1</span>;<span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="二分总结："><a href="#二分总结：" class="headerlink" title="二分总结："></a>二分总结：</h4><p><strong>左闭右闭是left小于等于right，如果右边更新则middle-1</strong></p>
<p><strong>最终原理就是right是否可能是target，左闭右闭自然是可能的。</strong></p>
<p><strong>口诀：是闭沾一（左闭left=middle+1，右闭right=middle-1），两闭相等（）</strong></p>
<p><strong>二分法的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p>
<p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p>
<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这 就是<strong>循环不变量</strong>规则。</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p>
<h5 id="二分法第一种写法"><a href="#二分法第一种写法" class="headerlink" title="二分法第一种写法"></a>二分法第一种写法</h5><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p>
<p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p>
<ul>
<li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) { <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) {</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) {</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<h5 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h5><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p>
<p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) { <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) {</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) {</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<h5 id="不要求二分法的方案"><a href="#不要求二分法的方案" class="headerlink" title="不要求二分法的方案"></a>不要求二分法的方案</h5><p>C++ STL（标准模板库）中提供了封装的二分查找函数，它是 <code>std::binary_search</code> 和 <code>std::lower_bound</code> 和 <code>std::upper_bound</code> 这些函数。</p>
<ol>
<li>**bool	**<code>std::binary_search</code> 函数用于检查容器中是否存在指定的元素。它返回一个布尔值，指示元素是否存在。如果元素存在，则返回 <code>true</code>，否则返回 <code>false</code>。示例用法如下：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="type">bool</span> exists = std::<span class="built_in">binary_search</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exists) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Element found!"</span> &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Element not found."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><code>std::lower_bound</code> 函数用于查找容器中<strong>大于或等于指定值的第一个元素的迭代器</strong>。它返回一个指向该元素的<strong>迭代器</strong>。<strong>如果没有大于或等于指定值的元素，则返回容器的 <code>end()</code> 迭代器</strong>。示例用法如下：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"First element greater than or equal to 3: "</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"No element greater than or equal to 3 found."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><code>std::upper_bound</code> 函数用于<strong>查找容器中大于指定值的第一个元素的迭代器</strong>。它返回一个指向该元素的<strong>迭代器</strong>。<strong>如果没有大于指定值的元素，则返回容器的 <code>end()</code> 迭代器</strong>。示例用法如下：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"First element greater than 3: "</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"No element greater than 3 found."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这些函数使得在有序容器中进行二分查找非常方便，可以帮助你快速定位元素并执行相关操作。</p>
<h5 id="左右指针模板（二分）"><a href="#左右指针模板（二分）" class="headerlink" title="左右指针模板（二分）"></a>左右指针模板（二分）</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//右闭</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> mid = left+(right-left)&gt;&gt;<span class="number">1</span>;<span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2、两数之和"><a href="#2、两数之和" class="headerlink" title="2、两数之和"></a><strong>2、两数之和</strong></h3><h3 id="3、反转数组"><a href="#3、反转数组" class="headerlink" title="3、反转数组"></a><strong>3、反转数组</strong></h3><h3 id="4、回文串判断"><a href="#4、回文串判断" class="headerlink" title="4、回文串判断"></a><strong>4、回文串判断</strong></h3><p>左右指针都可以仿照上面的模版</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.liwuxuanplus.com/2023/10/04/qian-zhui-he-chai-fen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liwuxuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MySite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/04/qian-zhui-he-chai-fen/" class="post-title-link" itemprop="url">前缀和&&差分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-04 21:16:22" itemprop="dateCreated datePublished" datetime="2023-10-04T21:16:22+08:00">2023-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-06 22:20:17" itemprop="dateModified" datetime="2023-10-06T22:20:17+08:00">2023-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前缀和专题"><a href="#前缀和专题" class="headerlink" title="前缀和专题"></a>前缀和专题</h1><p><strong>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。</p>
<p><strong>总结：下面题目基本上都是按照 前缀和presum[0]=0，presum[1]=第一个元素值</strong></p>
<p>在弄不清加一减一的时候，就想一下索引最大值</p>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="1、库函数优化"><a href="#1、库函数优化" class="headerlink" title="1、库函数优化"></a>1、库函数优化</h3><p>在C++中，可以使用STL（标准模板库）来优化前缀和的计算，特别是<strong>使用STL中的<code>partial_sum</code>函数</strong>。<code>partial_sum</code>函数可以快速计算数组的前缀和，而不需要手动编写循环来累加数组的元素。</p>
<p>以下是使用STL的<code>partial_sum</code>函数来计算前缀和的示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// 包含 partial_sum 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 partial_sum 计算前缀和</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">prefixSum</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    std::<span class="built_in">partial_sum</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), prefixSum.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印前缀和</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Prefix Sum: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : prefixSum) {</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上述示例中，我们首先包含了<code>&lt;numeric&gt;</code>头文件，其中包含了<code>partial_sum</code>函数。然后，我们创建一个与原始数组相同大小的<code>prefixSum</code>向量，并使用<code>partial_sum</code>函数计算前缀和，将结果存储在<code>prefixSum</code>中。最后，我们打印前缀和。</p>
<p>使用<code>partial_sum</code>函数可以让前缀和的计算更加简洁和高效，避免手动编写循环。这个函数非常适用于需要频繁计算前缀和的情况。</p>
<h3 id="2、经典写法"><a href="#2、经典写法" class="headerlink" title="2、经典写法"></a>2、经典写法</h3><h4 id="1-当presum-i-代表-nums-0-i-的前缀和时"><a href="#1-当presum-i-代表-nums-0-i-的前缀和时" class="headerlink" title="1)当presum[i] 代表 nums[0...i] 的前缀和时"></a>1)当<code>presum[i]</code> 代表 <code>nums[0...i]</code> 的前缀和时</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getPresum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">presum</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> presum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 nums[0...i] 的前缀和</span></span><br><span class="line">    presum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; presum.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        presum[i] = presum[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> presum;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRangeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; presum, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> presum[j];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> presum[j] - presum[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-当presum-i-代表-nums-0-i-1-的前缀和时-推荐"><a href="#2-当presum-i-代表-nums-0-i-1-的前缀和时-推荐" class="headerlink" title="2)当presum[i] 代表 nums[0...i-1] 的前缀和时(推荐)"></a>2)当<code>presum[i]</code> 代表 <code>nums[0...i-1]</code> 的前缀和时(推荐)</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getPresum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">presum</span><span class="params">(nums.size()+<span class="number">1</span>)</span></span>;<span class="comment">//presum[nums.size()]代表的是全nums数组的和</span></span><br><span class="line">    presum[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//便于计算前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> presum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 nums[0...i] 的前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; presum.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        presum[i] = presum[i - <span class="number">1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> presum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRangeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; presum, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> presum[j+<span class="number">1</span>] - presum[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; preSum;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//总共m行n列</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 构造前缀和矩阵</span></span><br><span class="line">        preSum = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">                <span class="comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">                preSum[i][j] = preSum[i<span class="number">-1</span>][j] + preSum[i][j<span class="number">-1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] - preSum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算子矩阵 [x1, y1, x2, y2] 的元素和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>{</span><br><span class="line">        <span class="comment">// 目标矩阵之和由四个相邻矩阵运算获得</span></span><br><span class="line">        <span class="keyword">return</span> preSum[x2+<span class="number">1</span>][y2+<span class="number">1</span>] - preSum[x1][y2+<span class="number">1</span>] - preSum[x2+<span class="number">1</span>][y1] + preSum[x1][y1];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>二维数组的前缀和一般都是从1索引开始，在计算一块区域的时候记住:	<strong>二维数组前缀和，一般都从一开始。计算矩阵元素和，大的加一小不变（索引）。</strong></p>
<h1 id="差分数组专题"><a href="#差分数组专题" class="headerlink" title="差分数组专题"></a>差分数组专题</h1><p> <strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong></p>
<p>差分数组不能STL优化</p>
<p><strong><code>diff[i]</code> 就是 <code>nums[i]</code> 和 <code>nums[i-1]</code> 之差</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> diff[nums.<span class="built_in">size</span>()];</span><br><span class="line"><span class="comment">// 构造差分数组</span></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>通过这个 <code>diff</code> 差分数组是可以反推出原始数组 <code>nums</code> 的，代码逻辑如下：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res[diff.<span class="built_in">size</span>()];</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这样构造差分数组 <code>diff</code>，就可以快速进行区间增减的操作</strong>，如果你想对区间 <code>nums[i..j]</code> 的元素全部加 3，那么只需要<strong>让 <code>diff[i] += 3</code>，然后再让 <code>diff[j+1] -= 3</code></strong> 即可<strong>：</strong>	因为只对区间 <code>nums[i..j]</code> 的元素全部加 3，[j+1… …]不变，如果 <code>diff[j+1]</code>不变， [j+1… …]也是加3</p>
<p><strong>原理很简单，回想 <code>diff</code> 数组反推 <code>nums</code> 数组的过程，<code>diff[i] += 3</code> 意味着给 <code>nums[i..]</code> 所有的元素都加了 3，然后 <code>diff[j+1] -= 3</code> 又意味着对于 <code>nums[j+1..]</code> 所有元素再减 3，那综合起来，就是对 <code>nums[i..j]</code> 中的所有元素都加 3 了</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; diff; <span class="comment">// 差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，接受一个初始数组 nums</span></span><br><span class="line">    <span class="built_in">Difference</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">assert</span>(nums.<span class="built_in">size</span>() &gt; <span class="number">0</span>); <span class="comment">// 确保输入数组不为空</span></span><br><span class="line">        diff = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">size</span>()); <span class="comment">// 初始化差分数组的大小</span></span><br><span class="line">        <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给闭区间 [i, j] 增加 val（可以是负数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        diff[i] += val; <span class="comment">// 更新差分数组的起始位置</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.<span class="built_in">size</span>()) {</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val; <span class="comment">// 更新差分数组的结束位置（注意边界检查）</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(diff.size())</span></span>; <span class="comment">// 初始化结果数组的大小</span></span><br><span class="line">        <span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.liwuxuanplus.com/2023/09/30/di-gui/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liwuxuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MySite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/30/di-gui/" class="post-title-link" itemprop="url">递归</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-30 20:51:09" itemprop="dateCreated datePublished" datetime="2023-09-30T20:51:09+08:00">2023-09-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-02 21:45:12" itemprop="dateModified" datetime="2023-10-02T21:45:12+08:00">2023-10-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <iframe src="//player.bilibili.com/player.html?aid=733411277&amp;bvid=BV1UD4y1Y769&amp;cid=915366282&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="500" padding-bottom:="" 56.25%="" high_quality="1" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe>



<p>​	这个视频讲的很好，<strong>处理递归，核心就是千万不要想子问题的过程，你脑子能处理几层？马上就绕迷糊了。要想子问题的结果，思路就清晰了。</strong></p>
<p>​	<strong>只要代码的边界条件和非边界条件的逻辑写对了，其他的事情交给数学归纳法就好了。也就是说，写对了这两个逻辑，你的代码自动就是正确的了，没必要想递归是怎么一层一层走的。</strong></p>
<p>我的想法是：<strong>明确递归函数的作用，坚定相信递归函数能做这件事。由此可以逻辑上分解做题思路。</strong>这是系统设计、网络设计上的常见思想。充分相信上层信息。</p>
<p>还有就是“回溯和递归是一套的，有一个递归就要有一个回溯”。不过很多回溯是隐性的。关键就是用递归分解问题，确定是否显性回溯。</p>
<p>留一个显性回溯的题目。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/description/">257. 二叉树的所有路径 - 力扣（LeetCode）</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231001184646709.png" alt="image-20231001184646709"></p>
<p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31412436/answer/683820765">对于递归有没有什么好的理解方法？ - 知乎 (zhihu.com)</a></p>
<p><strong>这篇把递归分三步</strong></p>
<p>①明确函数功能（以及参数和返回值），这点也是我想强调的。</p>
<p>②找到递归结束条件，这个在③后要再来一次，避免情况遗漏，很容易遗漏。</p>
<p>③<strong>找到函数的等价关系式</strong>，这个是作者提出的最难的部分，提出了一个观点（缩小参数的范围）。这个点也能覆盖住二叉树递归的情况。这一步类似于：“<strong>找到单层逻辑</strong>”。</p>
<p>记录一下圆桌会议：<a target="_blank" rel="noopener" href="https://www.zhihu.com/roundtable/ruhexuehaoshujujiego">如何学好数据结构与算法 (zhihu.com)</a></p>
<iframe src="//player.bilibili.com/player.html?aid=428008124&amp;bvid=BV1nG411x77H&amp;cid=764491411&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="500" padding-bottom:="" 56.25%="" high_quality="1"> </iframe>

<p>不得不说这个labuladong的视频，真的解答了很多困惑。尤其是刷了三四天的二叉树合集之后。这个视频值得反复看。</p>
<p>【一周刷爆LeetCode，算法大神左神（左程云）耗时100天打造算法与数据结构基础到高级全家桶教程，直击BTAJ等一线大厂必问算法面试题真题详解】<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?vd_source=4280d897d89a285191ff2a49582a555b">https://www.bilibili.com/video/BV13g41157hK?vd_source=4280d897d89a285191ff2a49582a555b</a></p>
<p>左程云+labuladong，配合食用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231002212118059.png" alt="image-20231002212118059"></p>
<p><strong>前序是入栈，后序是出栈，中序是节点更换。N叉树没有中序遍历就是因为节点更换位置太多，不唯一。</strong></p>
<p><strong>只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。</strong></p>
<p><strong>所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候</strong>，那么进一步，你把代码写在不同位置，代码执行的时机也不同：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1.jpeg"></p>
<p><img src="https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%94%B6%E5%AE%98/2.jpeg"></p>
<p><strong>你可以发现每个节点都有「唯一」属于自己的前中后序位置</strong>，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。</p>
<p>这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。</p>
<p>说了这么多基础的，就是要帮你对二叉树建立正确的认识，然后你会发现：</p>
<p><strong>二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作</strong>。</p>
<p>你也可以看到，<a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/">图论算法基础</a> 把二叉树的遍历框架扩展到了图，并以遍历为基础实现了图论的各种经典算法，不过这是后话，本文就不多说了。</p>
<h3 id="两种解题思路"><a href="#两种解题思路" class="headerlink" title="两种解题思路"></a><strong>两种解题思路</strong></h3><p>前文 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/wo-de-shua-5fe0c/">我的算法学习心得</a> 说过：</p>
<p>**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/">回溯算法核心框架</a> 和 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/">动态规划核心框架</a>**。</p>
<p><code>Tip</code></p>
<p><code>这里说一下我的函数命名习惯：二叉树中用遍历思路解题时函数签名一般是 void traverse(...)，没有返回值，靠更新外部变量来计算结果，而用分解问题思路解题时函数名根据该函数具体功能而定，而且一般会有返回值，返回值是子问题的计算结果。</code></p>
<p><code>与此对应的，你会发现我在 [回溯算法核心框架](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 中给出的函数签名一般也是没有返回值的 void backtrack(...)，而在 [动态规划核心框架](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 中给出的函数签名是带有返回值的 dp 函数。这也说明它俩和二叉树之间千丝万缕的联系。</code></p>
<p><strong>虽然函数命名没有什么硬性的要求，但我还是建议你也遵循我的这种风格，这样更能突出函数的作用和解题的思维模式，便于你自己理解和运用。</strong></p>
<p>综上，遇到一道二叉树的题目时的通用思考过程是：</p>
<p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现。</p>
<p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</p>
<p><strong>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做</strong>。</p>
<h2 id="后序位置的特殊之处"><a href="#后序位置的特殊之处" class="headerlink" title="后序位置的特殊之处"></a>后序位置的特殊之处</h2><p>说后序位置之前，先简单说下中序和前序。</p>
<h2 id="中序位置主要用在-BST-场景中，你完全可以把-BST-的中序遍历认为是遍历有序数组。"><a href="#中序位置主要用在-BST-场景中，你完全可以把-BST-的中序遍历认为是遍历有序数组。" class="headerlink" title="中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。"></a><strong>中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。</strong></h2><h2 id="前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。"><a href="#前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。" class="headerlink" title="前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。"></a>前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。</h2><p>你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：</p>
<p><img src="https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%94%B6%E5%AE%98/2.jpeg"></p>
<p>这不奇怪，因为本文开头就说了前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。</p>
<h2 id="但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。"><a href="#但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。" class="headerlink" title="但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。"></a><strong>但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据</strong>。</h2><h2 id="那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。"><a href="#那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。" class="headerlink" title="那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。"></a><strong>那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231002214509684.png" alt="image-20231002214509684"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liwuxuan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liwuxuan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
