<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>云计算实验报告3</title>
      <link href="/2024/03/23/yun-ji-suan-shi-yan-bao-gao-3/"/>
      <url>/2024/03/23/yun-ji-suan-shi-yan-bao-gao-3/</url>
      
        <content type="html"><![CDATA[<p>个人博客域名：<a href="https://www.liwuxuanplus.com/">MySite (liwuxuanplus.com)</a></p><h1 id="云计算实验报告3"><a href="#云计算实验报告3" class="headerlink" title="云计算实验报告3"></a>云计算实验报告3</h1><h2 id="实验基本信息"><a href="#实验基本信息" class="headerlink" title="实验基本信息"></a>实验基本信息</h2><table><thead><tr><th align="center">项目</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center"><strong>学号</strong></td><td align="center">202120130274</td></tr><tr><td align="center"><strong>姓名</strong></td><td align="center">李武轩</td></tr><tr><td align="center"><strong>班级</strong></td><td align="center">计科1班</td></tr><tr><td align="center"><strong>实验题目</strong></td><td align="center">利用主流云平台搭建个人博客或网站</td></tr><tr><td align="center"><strong>实验学时</strong></td><td align="center">2</td></tr><tr><td align="center"><strong>实验日期</strong></td><td align="center">2024/3/22</td></tr><tr><td align="center"><strong>实验目的</strong></td><td align="center">熟悉使用主流云平台并搭建个人博客或者网站</td></tr></tbody></table><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><table><thead><tr><th align="center">项目</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center"><strong>硬件环境</strong></td><td align="center">联网的计算机一台</td></tr><tr><td align="center"><strong>软件环境</strong></td><td align="center">Windows or Linux</td></tr></tbody></table><h2 id="实验步骤与内容"><a href="#实验步骤与内容" class="headerlink" title="实验步骤与内容"></a>实验步骤与内容</h2><h3 id="博客搭建方式"><a href="#博客搭建方式" class="headerlink" title="博客搭建方式"></a>博客搭建方式</h3><ul><li>采用方式：GitHub托管，Hexo方式创建</li><li>域名与DNS解析：使用阿里云配置了域名和DNS解析</li><li>CDN加速：使用jsDelivr进行CDN加速</li><li>图床加速：使用PicGo加速GitHub图床的访问</li></ul><h3 id="博客功能"><a href="#博客功能" class="headerlink" title="博客功能"></a>博客功能</h3><ul><li>评论功能：Gitalk和匿名自由评论</li><li>其他功能：网站留言等</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/yaorongke/article/details/119089190">https://blog.csdn.net/yaorongke/article/details/119089190</a></li></ul><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><ul><li>可以在网站里面详细体验：<a href="https://www.liwuxuanplus.com/">https://www.liwuxuanplus.com/</a></li></ul><p>注：由于使用了GitHub的服务器托管，访问速度可能不太理想，建议科学上网以获得更好的体验。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 云计算实验报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>山东大学汇编实验一</title>
      <link href="/2023/10/20/shan-dong-da-xue-hui-bian-shi-yan-yi/"/>
      <url>/2023/10/20/shan-dong-da-xue-hui-bian-shi-yan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编实验（DOSBox-MASM）"><a href="#汇编实验（DOSBox-MASM）" class="headerlink" title="汇编实验（DOSBox+MASM）"></a>汇编实验（DOSBox+MASM）</h1><p>在编辑器下写好代码（asm文件，assembly（汇编语言）的文件）之后，进入DOSBox执行下面三条指令，例如file_name.asm已经编写好了</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MASM file_name</span><br><span class="line"></span><br><span class="line">LINK file_name</span><br><span class="line"></span><br><span class="line">file_name</span><br></pre></td></tr></tbody></table></figure><p>分别是编译，连接，执行</p><p>在MASMPlus写完代码，应该放进<strong>MASM64</strong>文件夹，然后才能在DOSBox里面用上面方法运行</p><h2 id="汇编语言的语法"><a href="#汇编语言的语法" class="headerlink" title="汇编语言的语法"></a>汇编语言的语法</h2><p>实验使用的汇编语言的版本是8086汇编语言，跟现代汇编语言在语法上大致相同，关键词有点儿变更</p><h3 id="实验一（字符串比较）"><a href="#实验一（字符串比较）" class="headerlink" title="实验一（字符串比较）"></a>实验一（字符串比较）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">datarea segment                       ; 定义数据段</span><br><span class="line">    string1 db 'Move the cursor backward.';db是伪指令，分配数据大小的</span><br><span class="line">    string2 db 'Move the cursor forward.'</span><br><span class="line">    ;</span><br><span class="line">    mess1   db 'Match.',13,10,'$''$'    ; 匹配消息</span><br><span class="line">    mess2   db 'No match!',13,10,'$''$' ; 不匹配消息</span><br><span class="line">datarea ends</span><br><span class="line"></span><br><span class="line">prognam segment                        ; 定义代码段</span><br><span class="line">    main proc far;远进程段</span><br><span class="line">        assume cs:prognam, ds:datarea, es:datarea</span><br><span class="line">    start:                                ; 程序入口点</span><br><span class="line">        ; 保存旧数据段</span><br><span class="line">        push   ds</span><br><span class="line">        sub    ax, ax;ax=ax-ax=0,实际上就是置零指令</span><br><span class="line">        push   ax</span><br><span class="line"></span><br><span class="line">        ; 设置 DS 和 ES 段寄存器</span><br><span class="line">        mov    ax, datarea                ; 数据段地址</span><br><span class="line">        mov    ds, ax                     ; DS 寄存器</span><br><span class="line">        mov    es, ax                     ; ES 寄存器</span><br><span class="line"></span><br><span class="line">        ; 比较字符串</span><br><span class="line">        lea    si, string1                ; SI 指向 string1</span><br><span class="line">        lea    di, string2                ; DI 指向 string2</span><br><span class="line">        cld                               ; 清除方向标志位，从左到右比较</span><br><span class="line">        mov    cx, 25                     ; 比较的字符数</span><br><span class="line">        repz   cmpsb                      ; 比较字符串</span><br><span class="line">        jz     match                      ; 如果相等，跳转到 match 标签</span><br><span class="line">        lea    dx, mess2                  ; 不相等，加载 mess2 地址</span><br><span class="line">        jmp    short disp                ; 跳转到 disp 标签</span><br><span class="line"></span><br><span class="line">    match:  ;跳转标签</span><br><span class="line">        lea    dx, mess1                  ; 相等，加载 mess1 地址</span><br><span class="line"></span><br><span class="line">    disp:  ;display,显示</span><br><span class="line">        mov    ah, 09                    ; 设置功能码为 9，用于显示字符串</span><br><span class="line">        int    21h                       ; 调用 DOS 中断显示消息</span><br><span class="line"></span><br><span class="line">        ret                               ; 返回到 DOS</span><br><span class="line">    main endp                             ; 结束主程序</span><br><span class="line">prognam ends                             ; 结束代码段</span><br><span class="line">end start                                ; 程序结束标记</span><br></pre></td></tr></tbody></table></figure><p>注意这里有一个系统调用，经过<strong>查看中断表INT 21H</strong>，可以知道<code>mov    ah, 09</code>就是调用了09的系统功能，<strong>显示了字符串</strong>。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>汇编的注释是”;”</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;注释内容</span><br></pre></td></tr></tbody></table></figure><h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><h4 id="datarea"><a href="#datarea" class="headerlink" title="datarea"></a>datarea</h4><p>datarea=data area，数据段</p><p><strong>数据段定义：</strong> 数据段是用于存储数据的部分，以<code>datarea segment</code>开始，以<code>datarea ends</code>结束。</p><h4 id="prognam"><a href="#prognam" class="headerlink" title="prognam"></a>prognam</h4><p>“prognam” 的全拼是 “program name”，表示程序的名称。</p><h3 id="ASSUME"><a href="#ASSUME" class="headerlink" title="ASSUME"></a>ASSUME</h3><p><code>ASSUME</code> 是一种指令或伪指令，用于建立代码段（<code>CS</code>）、数据段（<code>DS</code>）、附加段（<code>ES</code>）、堆栈段（<code>SS</code>）等不同段寄存器和段寄存器组合之间的关联。这是一种在8086汇编语言和一些后续x86架构中的寄存器分段模型中使用的机制。</p><p>以下是 <code>ASSUME</code> 指令的详解：</p><ol><li><p><strong>语法：</strong> <code>ASSUME seg_reg: seg_name</code>，其中 <code>seg_reg</code> 是段寄存器（如 <code>CS</code>、<code>DS</code>、<code>ES</code>、<code>SS</code> 等），而 <code>seg_name</code> 是段的名称或标签。</p></li><li><p><strong>作用：</strong> <code>ASSUME</code> 指令建立了一个假设或关联，告诉汇编器哪个段寄存器应与哪个段相关联。这是为了在编译时确定代码和数据的位置，以便在生成机器代码时能够正确地生成内存地址。</p></li><li><p><strong>用途：</strong> <code>ASSUME</code> 指令通常在程序开头的数据段（<code>DATA</code>）中使用，以确保代码段和数据段的正确关联。例如，代码段（<code>CS</code>）通常与程序代码相关联，数据段（<code>DS</code>）通常与程序数据相关联。</p></li><li><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assume cs:prognam, ds:datarea, es:datarea</span><br></pre></td></tr></tbody></table></figure><p>在这个示例中，<code>CS</code> 寄存器被关联到 <code>prognam</code> 段，<code>DS</code>和<code>ES</code> 寄存器被关联到 <code>datarea</code> 段。这意味着汇编器将使用这些关联来生成正确的内存地址，以便在程序执行时能够访问正确的代码和数据。</p></li></ol><p>在现代的x86汇编中，由于分段模型的变化，通常不再需要显式使用 <code>ASSUME</code>，因为多数情况下，汇编器会根据段声明自动推断关联。但在一些情况下，特别是在使用老旧的编译器和汇编器时（实验环境），可能需要手动设置关联。</p><h3 id="db-dw-dd"><a href="#db-dw-dd" class="headerlink" title="db,dw,dd"></a>db,dw,dd</h3><p>在汇编语言中，<code>db</code> 是一个伪指令（directive），用于定义数据。具体地，<code>db</code> 表示 “define byte”，它用于将一个或多个字节（8位）的数据分配给指定的标识符。其他常用的伪指令还包括 <code>dw</code>（define word，用于定义16位数据）、<code>dd</code>（define doubleword，用于定义32位数据）等，它们用于分配不同大小的数据。</p><ol><li><p><strong><code>assume</code> 段寄存器指令：</strong> 在程序的开始，<code>assume cs:prognam, ds:datarea, es:datarea</code>用于关联代码段（<code>cs</code>）和数据段（<code>ds</code>、<code>es</code>）的寄存器。这表明代码段和数据段使用相同的内存段，可以相互访问。</p></li><li><p><strong>栈操作：</strong> 该程序使用栈来保存和还原数据段寄存器的值。<code>push</code>指令用于将数据保存在栈中，<code>pop</code>指令用于将数据弹出栈。这是为了保护程序的状态。</p></li><li><p><strong>寄存器操作：</strong> <code>ax</code> 寄存器用于存储零值。<code>mov</code> 指令用于将数据加载到寄存器中，例如，<code>mov ax, datarea</code> 将 <code>ax</code> 设置为数据段的地址。</p></li><li><p><strong>字符串比较：</strong> 使用字符串比较指令，<code>cld</code> 用于确保比较从左到右进行。然后，<code>repz cmpsb</code> 用于比较两个字符串，直到出现不匹配或达到指定的字符数（<code>cx</code> 寄存器中的值）。如果两个字符串匹配，<code>jz match</code> 将跳转到 <code>match</code> 标签，否则跳转到 <code>disp</code> 标签。</p></li><li><p><strong>消息显示：</strong> <code>lea dx, mess1</code> 或 <code>lea dx, mess2</code> 用于加载消息的地址到 <code>dx</code> 寄存器。接着，<code>mov ah, 09</code> 设置功能码，表示要显示字符串，然后使用 <code>int 21h</code> 来调用DOS中断以显示消息。</p></li><li><p><strong>返回：</strong> <code>ret</code> 用于返回到DOS。程序的入口点是 <code>start</code> 标签，而 <code>end start</code> 表明程序的结束点。</p></li></ol><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><p><a href="https://blog.csdn.net/qq_40843865/article/details/81210164">汇编指令详解-CSDN博客</a></p><p>下面列出实验一的一些指令</p><p><strong>(1) LEA(Load Effective Address)</strong><br>    格式：   lea REG,OPRD        <br>    功能：   把操作数OPRD的<font color="cornflowerblue">有效地址</font>传送到操作数REG<br>     注：    REG必须是16位通用寄存器，OPRD必须是一个存储器操作数<br> <br>     如：    lea ax,buf            ;buf是变量名<br>            lea ax,[si+2]</p><p><strong>(4) CLD(Clear Direction Flag):            DF置0，执行串操作指令时，地址递增</strong></p><p><strong><code>REPZ CMPSB</code> 是x86汇编语言中的一个指令序列，用于比较两个内存中的字符串并返回比较结果</strong>。以下是对该指令的详细解释：</p><ol><li><p><code>REPZ</code> 前缀：<code>REPZ</code> 是一个前缀指令，用于控制<strong>重复执行后续的指令</strong>。它基本上表示”<strong>repeat while zero</strong>“，即只要 <code>ZF</code>（零标志位）标志为1（表示相等），就重复执行后续的指令。如果 <code>ZF</code> 标志变为0（表示不相等），则停止重复执行。</p></li><li><p><code>CMPSB</code> 指令：<code>CMPSB</code> 是比较字符串指令，用于比较 <code>DS:SI</code> 指向的字节和 <code>ES:DI</code> 指向的字节，并根据比较结果更新一些寄存器和标志。在这里，<code>DS</code> 和 <code>ES</code> 是数据段寄存器，<code>SI</code> 和 <code>DI</code> 是源和目的地偏移地址寄存器。</p><ul><li><code>CMPSB</code> 会比较 <code>DS:SI</code> 和 <code>ES:DI</code> 指向的字节。</li><li>如果两个字节相等，它会设置 <code>ZF</code> 标志位为1（表示相等），否则为0（表示不相等）。</li><li>它还会根据 DF 标志位（方向标志位）的值来决定是向前比较（DF=0）还是向后比较（DF=1）。</li><li>然后，它会递增或递减 <code>SI</code> 和 <code>DI</code> 的值，取决于 DF 标志位的值，以便指向下一个要比较的字节。</li></ul></li></ol><p>在 <code>REPZ CMPSB</code> 指令序列中，重复执行 <code>CMPSB</code> 指令直到 <code>ZF</code> 标志变为0。这意味着它会持续比较两个字符串中的字节，直到找到不匹配的字节或直到达到字符串的末尾。</p><p>如果两个字符串完全相等，<code>REPZ</code> 指令将在比较结束后停止，<code>ZF</code> 标志将保持为1，表示字符串相等。如果字符串不相等或任何一个字符串的长度小于 <code>CX</code> 寄存器中的计数，<code>REPZ</code> 将停止，<code>ZF</code> 标志将变为0，表示字符串不相等。</p><p>在实验1中，<code>repz cmpsb</code> 的目的是比较 <code>string1</code> 和 <code>string2</code> 中的字符，直到找到不匹配的字符或两个字符串都完全匹配。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2023/10/19/hui-bian-yu-yan/"/>
      <url>/2023/10/19/hui-bian-yu-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h3 id="8086的字节和字"><a href="#8086的字节和字" class="headerlink" title="8086的字节和字"></a>8086的字节和字</h3><p>8086一个字节是8位（在哪里都不会变），但是8086的一个字是16位，也就是两个字节</p><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>注意：默认小端存储，低位低放，高位高放</p><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104213821128.png" alt="image-20231104213821128"></p><h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><p>源操作数与目的操作数字长一致。</p><p> 任何操作数不能是IP、FLAGS，目的操作数不能是CS。（有专用指令）</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104214357160.png" alt="image-20231104214357160"></p><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231017141209086.png" alt="image-20231017141209086"></p><p><strong>AX、BX、CX、DX 通常用来存放一般性数据被称为通用寄存器（16位）</strong></p><p>由于8086初期是8位，为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。</p><p>​AX可以分为AH和AL；</p><p>​BX可以分为BH和BL；</p><p>​CX可以分为CH和CL；</p><p>​DX可以分为DH和DL。</p><p>AX的低8位（0位<del>7位）构成了AL寄存器，高8位（8位</del>15位）构成了AH寄存器</p><p>段地址×16（也就是二进制左移4位）+偏移地址=物理地址，物理地址20位，段地址16位</p><p>内存没有分段，只是CPU用段地址记录物理地址</p><p>段的起始地址（不是段地址，段地址是去掉末位）必然是xxxx0H（16的倍数），偏移地址16位，所以段长度最多64K</p><h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>段寄存器就是提供段地址的</p><p>8086CPU有4个段寄存器：</p><p>​ CS、DS、SS、ES</p><p>当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018224509342.png" alt="image-20231018224509342"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018225526532.png" alt="image-20231018225526532"></p><h3 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h3><p><strong>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址</strong></p><p>​CS为代码段寄存器</p><p>​IP为指令指针寄存器</p><table><thead><tr><th align="center">8086PC工作过程的简要描述</th></tr></thead><tbody><tr><td align="center">（1）<strong>从CS:IP指向内存单元读取指令</strong>，读取的指令进入指令缓冲器；<br>（2）IP = IP + 所读取指令的长度，从而指向下一条指令；<br>（3）执行指令。 转到步骤 （1），重复这个过程。</td></tr></tbody></table><blockquote><p>tip:</p><p>在 8086CPU 加电启动或复位后（ 即 CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行，<strong>FFFF0H单元中的指令是8086PC机开机后执行的第一条指令</strong></p></blockquote><p>CPU将CS:IP指向的内存单元中的内容看作指令</p><p>怎么修改CS:IP?</p><p>mov指令不能用于设置CS、IP的值，   8086CPU没有提供这样的功能。8086修改CS:IP的指令是转移指令（jmp等）</p><p>8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。若有内存被CPU访问，则该内存一定被CS:IP指向过</p><h3 id="DS"><a href="#DS" class="headerlink" title="DS"></a>DS</h3><p>执行指令时，8086CPU自动取DS中的数据为内存单元的段地址</p><p>​mov [0],ax即将ax寄存器数据存到DS:0位置</p><p>8086CPU中有一个 DS寄存器，通常用来存放<strong>要访问的数据的段地址</strong>。</p><p>mov指令的格式：      </p><p>​mov 寄存器名，[内存单元地址]</p><p>“[…]”表示一个内存单元， “[…]”中的数字表示内存单元的偏移地址。</p><p><font color="red"><strong>8086CPU不支持将数据直接送入段寄存器的操作</strong></font></p><p><strong>数据➡️一般的寄存器➡️段寄存器</strong></p><h2 id="和-的应用"><a href="#和-的应用" class="headerlink" title="[]和()的应用"></a>[]和()的应用</h2><p>[bx]表示一个内存单元（存储器操作数），它的偏移地址在bx中，比如下面的指令：mov ax,[bx]</p><p>ax中的内容为0010H，我们可以这样来描述：(ax)=0010H； </p><p>也可以这样说，[]一般出现在指令里面&lt;偏移地址&gt;，()一般出现在计算里面&lt;内容数据&gt;</p><table><thead><tr><th align="left">mov [bx],ax</th></tr></thead><tbody><tr><td align="left">功能：<br>bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。  即：(ds *16 +(bx))  =  (ax)。</td></tr></tbody></table><h2 id="SI和CI"><a href="#SI和CI" class="headerlink" title="SI和CI"></a>SI和CI</h2><p>SI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8 位寄存器来使用</p><p>一般默认SI源寄存器，DI目的寄存器</p><p>在“[…]” 中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di</p><p>只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231016230952500.png" alt="image-20231016230952500"></p><h2 id="控制寄存器（IP和FLAGS）"><a href="#控制寄存器（IP和FLAGS）" class="headerlink" title="控制寄存器（IP和FLAGS）"></a>控制寄存器（IP和FLAGS）</h2><p><strong>IP</strong> 指定将IP用于指令地址记录，即Instruction Pointer。每次取指后都自增1。</p><p><strong>FLAGS</strong> 指定将FLAGS用作程序状态指示，也即PSW（Program Status Word）。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018224328803.png" alt="image-20231018224328803"></p><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018230055341.png" alt="image-20231018230055341"></p><h3 id="PTR什么时候用？"><a href="#PTR什么时候用？" class="headerlink" title="PTR什么时候用？"></a><code>PTR</code>什么时候用？</h3><p>有寄存器时不用，无寄存器（包含【bx】）时要使用，防止源操作数和目的操作数位数不一致</p><p><code>BYTE PTR</code>指明是要赋单字节值</p><p><a href="https://blog.csdn.net/qq_36561697/article/details/80698875">https://blog.csdn.net/qq_36561697/article/details/80698875</a></p><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><h3 id="1-立即寻址"><a href="#1-立即寻址" class="headerlink" title="1.立即寻址"></a>1.立即寻址</h3><p>操作数直接存放在指令中，立即寻址方式用来表示常数，它经常用于给寄存器赋初值，并且只能用于源操作数字段，不能用于目的操作数字段，且源操作数 长度 应与目的操作数 长度一致。</p><p><strong>例子：MOV AX, 3064H</strong> </p><h3 id="2-寄存器寻址"><a href="#2-寄存器寻址" class="headerlink" title="2.寄存器寻址"></a>2.寄存器寻址</h3><p>操作数 在寄存器中，指令指定寄存器号。 </p><p>对于16位操作数，寄存器可以是AX,BX,CX,DX,SI,DI,SP和BP；</p><p>对于8位操作数，寄存器可以是AL,AH, BL, BH, CL, CH, DL,DH；</p><p><strong>例子：MOV AX, BX</strong> </p><h3 id="3-直接寻址"><a href="#3-直接寻址" class="headerlink" title="3.直接寻址"></a>3.直接寻址</h3><p>操作数的有效地址只包含位移量一种成分(位移量（displacement)是存放在指令中的一个 8位、16位或 32位的数，但它不是立即数，而是一个地址。区别在于<strong>位移量加[]</strong>)，其值就存放在代码段中指令的操作码之后，位移量的值即操作数的有效地址</p><p><strong>例子：MOV AX,[2000H]</strong></p><h3 id="4-寄存器间接寻址"><a href="#4-寄存器间接寻址" class="headerlink" title="4.寄存器间接寻址"></a>4.寄存器间接寻址</h3><p>操作数的有效地址只包含基址寄存器内容或变址寄存器内容一种成分。 因此，<strong>有效地址就在某个寄存器中</strong>，而<strong>操作数则在存储器</strong>中</p><p><strong>例子：MOV AX，[BX]</strong></p><p>没有特殊说明（段跨越前缀），默认段寄存器为DS（BP和SP的时候默认是SS）</p><p>假设（DS）=2000H，（BX）=1000H，物理地址EA=（DS）&lt;&lt;4+(BX)=21000H</p><p>则(AX)=50A0H，<strong>一定要注意EA是地址，操作数是（EA）</strong>，<strong>AX赋值是操作数赋值</strong>，EA只是用来寻址的</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231019223728313.png" alt="image-20231019223728313"></p><h3 id="5-寄存器相对寻址"><a href="#5-寄存器相对寻址" class="headerlink" title="5.寄存器相对寻址"></a>5.寄存器相对寻址</h3><p>操作数的有效地址为基址寄存器或变址寄存器的内容和指令中指定的位移量之和， 所以有效地址由两种成分组成。</p><p><strong>例子：MOV AX, COUNT[SI]</strong> （也可表示为<strong>MOV AX, [COUNT+SI])</strong>其中<strong>COUNT为16位位移量的符号地址。</strong></p><p><strong>MOV AX, [BX+10]</strong></p><p>如果 (DS) = 3000H, （SI）= 2000H, COUNT= 3000H</p><p>则物理地址EA＝30000+2000+3000= 35000H </p><h3 id="6-基址变址寻址"><a href="#6-基址变址寻址" class="headerlink" title="6.基址变址寻址"></a>6.基址变址寻址</h3><p>操作数的有效地址是一个基址寄存器和一个变址寄存器的内容之和，所以有效地址由两种成分组成</p><p><strong>例子：MOV AX, [BX] [DI] （或写为 ：MOV AX, [BX+ DI])</strong></p><p>如(DS)= 2100H, （BX) = 0158H, (DI)= 10A5H<br>则EA= 0158+10A5= 11FDH，物理地址＝21000+11FD= 221FDH </p><p>执行结果(AX)=1234H</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231019225016657.png" alt="image-20231019225016657"></p><h3 id="7-相对基址变址寻址"><a href="#7-相对基址变址寻址" class="headerlink" title="7.相对基址变址寻址"></a>7.相对基址变址寻址</h3><p>操作数的有效地址是一个基址寄存器与一个变址寄存器的内容和指令中指定的位移量之和，所以有效地址由三种 成分组成。</p><p><strong>例子：MOV MASK[BX] [SI]（也可写成MOV AX, MASK[BX+SI]或MOV AX, [MASK+BX+ SI])</strong></p><p>如（DS)= 3000H, (BX)= 2000H, (SI）= 1000H，MASK= 0250H, </p><p>则 物理地址<strong>EA＝（DS)&lt;&lt;4+(BX)+(SI）+MASK</strong><br>= 30000+2000+1000+0250 = 33250H<br>执行结果(AX)= 1234H。<br><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231019225646835.png" alt="image-20231019225646835"></p><h2 id="存储器寻址"><a href="#存储器寻址" class="headerlink" title="存储器寻址"></a>存储器寻址</h2><p><strong><font color="red">一个指令不能有两个存储器操作数</font></strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104220620156.png" alt="image-20231104220620156"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104220640105.png" alt="image-20231104220640105"></p><h3 id="PTR什么时候用？-1"><a href="#PTR什么时候用？-1" class="headerlink" title="PTR什么时候用？"></a><code>PTR</code>什么时候用？</h3><p>有寄存器时不用，无寄存器（包含【bx】）时要使用，防止源操作数和目的操作数位数不一致</p><p><code>BYTE PTR</code>指明是要赋单字节值</p><p><a href="https://blog.csdn.net/qq_36561697/article/details/80698875">https://blog.csdn.net/qq_36561697/article/details/80698875</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104221244053.png" alt="image-20231104221244053"></p><h2 id="控制转移寻址"><a href="#控制转移寻址" class="headerlink" title="控制转移寻址"></a>控制转移寻址</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104221750451.png" alt="image-20231104221750451"></p><h3 id="SHORT和FAR什么时候用"><a href="#SHORT和FAR什么时候用" class="headerlink" title="SHORT和FAR什么时候用"></a>SHORT和FAR什么时候用</h3><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104221830111.png" alt="image-20231104221830111"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104222152841.png" alt="image-20231104222152841"></p><p>看看PPT（第3章）记忆吧，总不能把这个文档全贴上图，这里仅仅放了near和far，因为经常见到，算是备忘录吧</p><h2 id="数据移动"><a href="#数据移动" class="headerlink" title="数据移动"></a>数据移动</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104222419547.png" alt="image-20231104222419547"></p><p>注意段寄存器需要寄存器间接，可以说是设计上的缺陷吧，或者其他什么原因。注意CS是不能寄存器直接改的，但是DS和ES是可以的，只要注意固定搭配</p><h2 id="指令大全"><a href="#指令大全" class="headerlink" title="指令大全"></a>指令大全</h2><p>看第4讲PPT</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231105193717038.png" alt="image-20231105193717038"></p><h2 id="以字节对齐"><a href="#以字节对齐" class="headerlink" title="以字节对齐"></a>以字节对齐</h2><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20231105195609620.png" alt="image-20231105195609620"></p><p>在汇编语言中，<code>BX</code> 寄存器通常用来存储地址或偏移量。乘以2（SHL BX, 1）可能是因为<strong>查找表中的条目是按字（Word）大小存储的</strong>，而字的大小通常是2个字节（16位），因此需要将 <code>BX</code> 乘以2以获得正确的<strong>字节偏移</strong>。</p><p><strong><font color="DarkVoilet">这是因为在汇编语言中，地址通常是按字节而不是字（Word）对齐的。</font></strong><font color="MediumVioletRed">查找表的每个条目都是字大小的</font>，因此如果你要访问查找表中的一个条目，你需要考虑每个条目的大小，通常是2个字节，所以需要将 <code>BX</code> 乘以2以得到正确的字节偏移。这确保了你在查找表中正确地访问到所需的条目。</p><p>当你在程序中执行 <code>SHL BX, 1</code> 操作时，实际上是将 <code>BX</code> 寄存器的值左移一位，相当于将其乘以2。这是一种常见的操作，用于计算地址偏移量，以便访问数组、查找表或其他内存结构中的元素。这可以确保访问到正确的数据，以执行条件分支操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索</title>
      <link href="/2023/10/10/sou-suo/"/>
      <url>/2023/10/10/sou-suo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_43590232/article/details/104735102">https://blog.csdn.net/weixin_43590232/article/details/104735102</a></p><p><a href="https://stackoverflow.com/questions/3332947/what-are-the-practical-factors-to-consider-when-choosing-between-depth-first-sea">https://stackoverflow.com/questions/3332947/what-are-the-practical-factors-to-consider-when-choosing-between-depth-first-sea</a></p><p><strong>BFS适用于需要找到最短路径或距离起点最近的解决方案的问题，而DFS适用于需要深度探索或搜索所有可能解决方案的问题。</strong></p><p><strong>BFS通常只用来找一个解决方案，DFS用来找所有解决方案。</strong>BFS当然可以搜索所有解决方案，而且时间复杂度跟DFS相同，但是BFS的空间复杂度比DFS高太多了。</p><p>BFS和DFS的相邻点 有的时候很明显，有的时候不明显，需要自己总结一下。在做CSP题时，基本上没有明显的节点，都是需要抽象出来树形结构的</p><p><strong>做题第一步，纸上写出树形结构，分别考虑边和点。边考虑回溯，点考虑BFS和DFS。一定要考虑记忆化搜索和剪枝，不然一般都会超时。</strong></p><h2 id="BFS-最短路径问题"><a href="#BFS-最短路径问题" class="headerlink" title="BFS(最短路径问题)"></a>BFS(最短路径问题)</h2><h3 id="BFS问题的本质都是找从start到target的最短路"><a href="#BFS问题的本质都是找从start到target的最短路" class="headerlink" title="BFS问题的本质都是找从start到target的最短路"></a><code>BFS</code>问题的本质都是找从<code>start</code>到<code>target</code>的最短路</h3><p>如果是找最短路径，第一时间想<code>BFS</code>，注意是<code>短</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>{</span><br><span class="line">    queue&lt;Node&gt; q; </span><br><span class="line">    unordered_set&lt;Node&gt; visited;<span class="comment">//一般是用bool vis[size];用1表示自己去过了,数组访问O(1)。不过unordered_set也差不多。</span></span><br><span class="line">    <span class="comment">//一般是用数组。但是一些问题的索引不好确认，用unordered_set更好，普适性更好一些，但是需要确认元素是否重复（用值时）</span></span><br><span class="line">    q.<span class="built_in">push</span>(start); </span><br><span class="line">    <span class="comment">//visited.insert(start);//有时候写上会有问题，有了下面的，这里不要写了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) {</span><br><span class="line">            Node cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            visited.<span class="built_in">insert</span>(cur);<span class="comment">//必要</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cur == target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.<span class="built_in">adj</span>()) {<span class="comment">//不管是 邻接表 还是邻接数组 还是链式前向星 都要会写</span></span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">count</span>(x) == <span class="number">0</span>) {</span><br><span class="line">                    q.<span class="built_in">push</span>(x);</span><br><span class="line">                    visited.<span class="built_in">insert</span>(x);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果走到这里，说明在图中没有找到目标节点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>BFS</code>的<code>vis</code>数组一般只加不减，<code>vis</code>只是用来指示邻接点是否已经遍历过了</p><h2 id="BFS优化（双向BFS）"><a href="#BFS优化（双向BFS）" class="headerlink" title="BFS优化（双向BFS）"></a><code>BFS</code>优化（双向<code>BFS</code>）</h2><p><strong>前提：已经知道终点，从起点和终点分别开始<code>BFS</code>，可以降低大约一半<code>空间复杂度</code>和<code>时间复杂度</code>。这种技巧实际上并没有降低big O时间复杂度。用BFS还是双向BFS看情况吧。</strong></p><p>双向 BFS 还是遵循 BFS 算法框架的，只是<strong>不再使用队列，而是使用<code>unordered_set</code>方便快速判断两个集合q1、q2是否有交集。起点和终点分别加入<code>unordered_set</code>，遍历一个集合的时候，判断另一个集合是否有该元素。</strong>。</p><p>另外的一个技巧点就是 <strong>while 循环 <code>while( !q1.empty()&amp;&amp;!q2.empty()  )</code>的最后交换 <code>q1</code> 和 <code>q2</code> 的内容</strong>，所以只要默认扩散 <code>q1</code> 就相当于轮流扩散 <code>q1</code> 和 <code>q2</code>。或者 可以加一个<strong>判定<code>if (q1.size() &gt; q2.size()) </code>交换，仍然默认<code>q1</code>，但每次使用最小的集合</strong>。跟上边没什么区别。</p><p><strong>必掌握：求“最短路径”</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>{</span><br><span class="line">    unordered_set&lt;Node&gt; q1, q2, visited;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;<span class="comment">//记录路径长度</span></span><br><span class="line">    q1.<span class="built_in">insert</span>(start);</span><br><span class="line">    q2.<span class="built_in">insert</span>(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()){</span><br><span class="line">        <span class="comment">// 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果</span></span><br><span class="line">        unordered_set&lt;string&gt; temp;<span class="comment">//现在是q1遍历后的q1，相当于clear了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将 q1 中的所有节点向周围扩散 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> cur : q1){</span><br><span class="line">            <span class="comment">/* 判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span>(q2.<span class="built_in">count</span>(cur))</span><br><span class="line">                <span class="keyword">return</span> step;<span class="comment">//q1、q2相交，代表找到了</span></span><br><span class="line"></span><br><span class="line">            visited.<span class="built_in">insert</span>(cur);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将一个节点的未遍历相邻节点加入集合 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.<span class="built_in">adj</span>()) {<span class="comment">//不管是 邻接表 还是邻接数组 还是链式前向星 都要会写</span></span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">count</span>(x) == <span class="number">0</span>) {</span><br><span class="line">                    temp.<span class="built_in">push</span>(x);<span class="comment">//注意：应该是往temp里面加入元素</span></span><br><span class="line">                    visited.<span class="built_in">insert</span>(x);</span><br><span class="line">                }</span><br><span class="line">       }</span><br><span class="line">        <span class="comment">/* 在这里增加步数 */</span></span><br><span class="line">        step++;</span><br><span class="line">        <span class="comment">// temp 相当于 新的 q1</span></span><br><span class="line">        <span class="comment">// 这里交换 q1 q2，下一轮 while 就是扩散 q2</span></span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><a href="https://oi-wiki.org/search/astar/">A* - OI Wiki (oi-wiki.org)</a></p><p>这里涉及到了一个启发式搜索</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a><code>DFS</code></h2><p>DFS和回溯一般都是混用的，大家没严格区分</p><p>时间复杂度较高，但是可以拿部分的分 </p><p>本质上是 暴力穷举，递归函数，跟回溯基本一致。不要特别在意区分回溯和<code>DFS</code>，只要能做题就行。一般都是void，不用到返回值。</p><p><strong><code>DFS</code>必掌握“N皇后问题、全排列”</strong>，呃，这俩都是回溯</p><p>一般不会求最值，没有最优子结构</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> vis[N];<span class="comment">//DFS经常用到，当然也可以用unordered_map</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (终止条件) {</span><br><span class="line">      处理语句</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">    <span class="keyword">for</span> (邻接点) {</span><br><span class="line">        <span class="keyword">if</span>(下一步有效)<span class="comment">//一般是 !vis[i]</span></span><br><span class="line">        {</span><br><span class="line">            处理</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">      <span class="built_in">dfs</span>(参数);</span><br><span class="line">      撤销处理</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>就是二叉树遍历的<code>void traverse()</code>函数</p><p><strong>一般情况下，回溯算法的「做选择」和「撤销选择」在 for 循环里面，而<code>DFS</code>的操作在 for 循环外面。这是回溯算法和 DFS 算法的区别所在：回溯算法关注的不是节点，而是树枝（也可以说边，就是for里面 的路径选择）。而DFS只处理本身节点的选择和撤销选择。二者的区别在于根节点，DFS会处理和撤销处理根节点，但是回溯不行（回溯关注的是边，边数=点数-1（无环图成立，但是回溯等一般的 图算法都会visited掉环，所以对回溯是永远会漏掉根节点（大概？） ），回溯会漏掉根节点）。</strong></p><p>dfs和回溯都是void遍历+外部变量，动态规划是有返回值的（后序遍历）。相同点是都要在前序位置（入栈前判断，判断是否入栈）写判定条件（一定要考虑好边界条件），在后面写的时候，哪怕判断条件重复，实际上也不会影响算法效率。</p><p>通过选边还是选点，选择回溯或者DFS</p><h3 id="非明显节点型"><a href="#非明显节点型" class="headerlink" title="非明显节点型"></a>非明显节点型</h3><h4 id="1-排列组合问题"><a href="#1-排列组合问题" class="headerlink" title="1.排列组合问题"></a>1.排列组合问题</h4><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231008203914915.png" alt="image-20231008203914915"></p><p><strong>边问题，回溯</strong></p><p>求一个数组的全排列，这个要注意一点，vis标记与撤销，vis不能不撤销，那样会导致其他分支被剪掉，从而只会剩下一个排列。</p><h4 id="2-表格型（棋盘型、迷宫型）"><a href="#2-表格型（棋盘型、迷宫型）" class="headerlink" title="2.表格型（棋盘型、迷宫型）"></a>2.表格型（棋盘型、迷宫型）</h4><p>典型：“N皇后”问题</p><p>关键步骤：找到遍历逻辑（怎么遍历），至于皇后不能攻击、迷宫墙不能通过……这些问题是后期限制条件(if语句、剪枝)，前期不用管。</p><p>遍历逻辑——&gt;转化为树形结构（图本身也算树形大类）</p><p><strong>根节点为空，考虑回溯（抽象为边，边问题的根节点是空的）。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231008210924883.png" alt="image-20231008210924883"></p><p>N皇后一般思路：每行取一个皇后，这个皇后可以在该行的每个列（只要不在另一个皇后的攻击范围）——&gt; 后面加<code>if</code>限制条件。</p><p> <strong>在宽度优先和深度优先搜索里面，我们都是根据搜索的顺序依次进行搜索，可以称为盲目搜索，搜索效率非常低。</strong></p><p>而启发式搜索则大大提高了搜索效率，但启发式搜索可能很繁琐</p><p><a href="https://www.cnblogs.com/isguxing/p/9800490.html">https://www.cnblogs.com/isguxing/p/9800490.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据数据估算时间复杂度</title>
      <link href="/2023/10/07/gen-ju-shu-ju-gu-suan-shi-jian-fu-za-du/"/>
      <url>/2023/10/07/gen-ju-shu-ju-gu-suan-shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<p><strong>前提：一般都是1秒对应一千万次计算（也可能是一亿）</strong></p><p>拿题目数据规模反推大概用个啥算法用些啥优化。</p><p><strong>10^5级别？基本上是O(nlogn)；10^7?那必须O(n)了；10^3基本上不就是个O(n^2)；蹦跶出来个诸如20以内的条件基本上就暴力了；如果俩参数范围一个才十几二十另一个成千上万基本上是个状态压缩DP类似的玩意了……诸如此类。</strong></p><p>就因为是竞赛，你得正反都能估啊……算法推得出复杂度，复杂度推得出算法什么的。</p><p>当然了也不仅仅是一个渐进最大时间复杂度，通常来说还需要熟悉平均时间复杂度……</p><p><a href="https://liam.page/2016/06/20/big-O-cheat-sheet/">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector索引问题</title>
      <link href="/2023/10/04/vector-suo-yin-wen-ti/"/>
      <url>/2023/10/04/vector-suo-yin-wen-ti/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout&lt;&lt;<span class="string">"输入n"</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        cin&gt;&gt;temp;</span><br><span class="line">        v[i]=temp;<span class="comment">//这里会报错，因为v[i]还没有被定义，所以不能直接赋值，应该用push_back()函数</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注意一个问题，以前一直理解错了。"><a href="#注意一个问题，以前一直理解错了。" class="headerlink" title="注意一个问题，以前一直理解错了。"></a>注意一个问题，以前一直理解错了。</h2><p><strong>C++里面vector必须分配空间后才能用索引，否则就会报错。不然就用push_back();</strong></p><p>以前一直以为会自动处理，要引起重视。</p><p>在 C++ 中，如果尝试访问一个尚未分配内存的 <code>vector</code> 的元素，会导致未定义行为。当创建一个空的 <code>vector&lt;int&gt; res;</code> 时，它没有分配任何内存空间来存储元素，因此尝试访问 <code>v[i]</code> 将导致问题。</p><p>如果不设置大小，<code>v</code> 将是一个空的、没有分配内存的 <code>vector</code>，尝试在其中存储数据会导致内存越界错误或其他未定义行为，这可能会导致程序崩溃或产生不可预测的结果。因此，在使用 <code>vector</code> 时，通常需要确保分配足够的内存空间来存储数据，以避免这类问题。</p><h2 id="普通数组计算长度"><a href="#普通数组计算长度" class="headerlink" title="普通数组计算长度"></a>普通数组计算长度</h2><p>在C++中，你可以使用以下方法来快速计算数组的长度：</p><ol><li>使用 <code>sizeof</code> 操作符：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br></pre></td></tr></tbody></table></figure><p>这种方法会返回数组的总字节数除以每个元素的字节数，从而得到数组的长度。</p><ol start="2"><li>使用 <code>std::size</code> 函数（C++17及以上版本）：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> length = std::<span class="built_in">size</span>(arr);</span><br></pre></td></tr></tbody></table></figure><p><code>std::size</code> 是C++17及以上版本的标准库函数，它可以用于获取数组的长度。</p><ol start="3"><li>如果你使用了 <code>std::vector</code> 或其他STL容器，可以使用容器的 <code>size</code> 成员函数来获取长度：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> length = vec.<span class="built_in">size</span>();</span><br></pre></td></tr></tbody></table></figure><p>这些方法都可以快速计算数组或容器的长度，你可以根据你的编译环境和需求选择其中一种方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 易错点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2023/10/04/shuang-zhi-zhen/"/>
      <url>/2023/10/04/shuang-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231005115512463.png" alt="image-20231005115512463"></p><h1 id="双指针专题"><a href="#双指针专题" class="headerlink" title="双指针专题"></a>双指针专题</h1><h2 id="一、快慢指针技巧（同向指针）"><a href="#一、快慢指针技巧（同向指针）" class="headerlink" title="一、快慢指针技巧（同向指针）"></a>一、快慢指针技巧（同向指针）</h2><h3 id="1、数组问题中比较常见的快慢指针技巧，是让你原地修改数组。"><a href="#1、数组问题中比较常见的快慢指针技巧，是让你原地修改数组。" class="headerlink" title="1、数组问题中比较常见的快慢指针技巧，是让你原地修改数组。"></a>1、数组问题中比较常见的快慢指针技巧，是让你<strong>原地修改</strong>数组。</h3><p>套路框架：fast遍历数组，遇到符合条件的抛给slow。（数组元素只能覆盖，不能删除）</p><h3 id="2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。"><a href="#2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。" class="headerlink" title="2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。"></a>2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。</h3><p>强调滑动窗口算法的快慢指针特性：</p><p><code>left</code> 指针在后，<code>right</code> 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s)</span> </span>{</span><br><span class="line">    <span class="comment">// 用合适的数据结构记录窗口中的数据</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) {</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        window.<span class="built_in">add</span>(c)</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="comment">// 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment">// 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"window: [%d, %d)\n"</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) {</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            window.<span class="built_in">remove</span>(d)<span class="comment">//应该是window[d]--;</span></span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>时间复杂度为<code>O(n)</code>：指针 <code>left, right</code> 不会回退（它们的值只增不减），所以字符串/数组中的每个元素都只会进入窗口一次，然后被移出窗口一次，不会说有某些元素多次进入和离开窗口，所以算法的时间复杂度就和字符串/数组的长度成正比</p><hr><p><strong>滑动窗口算法的思路是这样</strong>：</p><p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」。</p><table><thead><tr><th>Tip</th></tr></thead><tbody><tr><td>理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 <code>left = right = 0</code> 时区间 <code>[0, 0)</code> 中没有元素，但只要让 <code>right</code> 向右移动（扩大）一位，区间 <code>[0, 1)</code> 就包含一个元素 <code>0</code> 了。如果你设置为两端都开的区间，那么让 <code>right</code> 向右移动一位后开区间 <code>(0, 1)</code> 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 <code>[0, 0]</code> 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。</td></tr></tbody></table><p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</p><p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p><p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p><hr><p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解</strong>，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p><p>下面画图理解一下，<code>needs</code> 和 <code>window</code> 相当于计数器，分别记录 <code>T</code> 中字符出现次数和「窗口」中的相应字符的出现次数。</p><p>初始状态：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1.png" alt="img"></p><p>增加 <code>right</code>，直到窗口 <code>[left, right)</code> 包含了 <code>T</code> 中所有字符：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2.png" alt="img"></p><p>现在开始增加 <code>left</code>，缩小窗口 <code>[left, right)</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3.png" alt="img"></p><p>直到窗口中的字符串不再符合要求，<code>left</code> 不再继续移动：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4.png" alt="img"></p><p>之后重复上述过程，先移动 <code>right</code>，再移动 <code>left</code>…… 直到 <code>right</code> 指针到达字符串 <code>S</code> 的末端，算法结束。</p><hr><h4 id="常见环境：判断window里面的元素是否包含-子串-所有元素"><a href="#常见环境：判断window里面的元素是否包含-子串-所有元素" class="headerlink" title="常见环境：判断window里面的元素是否包含 子串 所有元素"></a><strong>常见环境：判断<code>window</code>里面的元素是否包含 子串 所有元素</strong></h4><p>对于 子串问题（字母有重复的）。添加<code>int valid</code>和<code>unordered_set&lt;char,int&gt; need</code><code>need</code>是子串的哈希表，记录子串字母和字母数目。</p><p>**在扩展窗口的时候，window添加后，当<code>window</code>里面对应字母数量等于子串对应的数量，<code>valid</code>加一。**</p><p><strong>在缩小窗口的时候，在window缩小前，若<code>window</code>内字母数量等于<code>need</code>里面对应的数量时（也就是缩小窗口后必小于need.size()），<code>valid</code>减一。</strong></p><p>还有就是 <code>window</code><strong>一般只需要记录子串元素，不用管其他元素</strong></p><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need,window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i:t)need[i]++;<span class="comment">//已完成，不修改</span></span><br><span class="line">        <span class="type">int</span> valid=<span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> need_size=need.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,len=INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> right_value=s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(right_value))<span class="comment">//存在</span></span><br><span class="line">            {</span><br><span class="line">                window[right_value]++;</span><br><span class="line">                <span class="keyword">if</span>(window[right_value]==need[right_value])</span><br><span class="line">                valid++;<span class="comment">//加法判定</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(valid==need_size)<span class="comment">//可缩</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(len&gt;right-left)<span class="comment">//找最小</span></span><br><span class="line">                {</span><br><span class="line">                    start=left;</span><br><span class="line">                    len=right-left;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> delete_value=s[left];</span><br><span class="line">                left++;<span class="comment">//易忘</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(delete_value))<span class="comment">//存在</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span>(window[delete_value]==need[delete_value])</span><br><span class="line">                    {</span><br><span class="line">                        valid--;</span><br><span class="line">                    }</span><br><span class="line">                    window[delete_value]--;</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(len==INT_MAX)<span class="keyword">return</span> <span class="string">""</span>;<span class="comment">//易忘</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>注意小部件：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(need.<span class="built_in">count</span>(deleteleft))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(window[deleteleft]==need[deleteleft])<span class="comment">//必须是先判断等于，因为这里的valid是一次性的。若后判断小于，则会出问题。</span></span><br><span class="line">{</span><br><span class="line">valid--;</span><br><span class="line">}</span><br><span class="line">window[deleteleft]--;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>类似的还有<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p><h4 id="常见环境：求窗口长度"><a href="#常见环境：求窗口长度" class="headerlink" title="常见环境：求窗口长度"></a><strong>常见环境：求窗口长度</strong></h4><p>注意窗口是<strong>左闭右开</strong>的，窗口长度一般是<code>right-left</code>。关键就是判断一下right此时是否在window</p><hr><h2 id="二、左右指针的常用算法（相向指针）"><a href="#二、左右指针的常用算法（相向指针）" class="headerlink" title="二、左右指针的常用算法（相向指针）"></a>二、左右指针的常用算法（相向指针）</h2><p>套路框架和二分差不多</p><h3 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a><strong>1、二分查找</strong></h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//右闭</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> mid = left+(right-left)&gt;&gt;<span class="number">1</span>;<span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="二分总结："><a href="#二分总结：" class="headerlink" title="二分总结："></a>二分总结：</h4><p><strong>左闭右闭是left小于等于right，如果右边更新则middle-1</strong></p><p><strong>最终原理就是right是否可能是target，左闭右闭自然是可能的。</strong></p><p><strong>口诀：是闭沾一（左闭left=middle+1，右闭right=middle-1），两闭相等（）</strong></p><p><strong>二分法的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这 就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><h5 id="二分法第一种写法"><a href="#二分法第一种写法" class="headerlink" title="二分法第一种写法"></a>二分法第一种写法</h5><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) { <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) {</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) {</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h5><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) { <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) {</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) {</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="不要求二分法的方案"><a href="#不要求二分法的方案" class="headerlink" title="不要求二分法的方案"></a>不要求二分法的方案</h5><p>C++ STL（标准模板库）中提供了封装的二分查找函数，它是 <code>std::binary_search</code> 和 <code>std::lower_bound</code> 和 <code>std::upper_bound</code> 这些函数。</p><ol><li>**bool**<code>std::binary_search</code> 函数用于检查容器中是否存在指定的元素。它返回一个布尔值，指示元素是否存在。如果元素存在，则返回 <code>true</code>，否则返回 <code>false</code>。示例用法如下：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="type">bool</span> exists = std::<span class="built_in">binary_search</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exists) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Element found!"</span> &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Element not found."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><code>std::lower_bound</code> 函数用于查找容器中<strong>大于或等于指定值的第一个元素的迭代器</strong>。它返回一个指向该元素的<strong>迭代器</strong>。<strong>如果没有大于或等于指定值的元素，则返回容器的 <code>end()</code> 迭代器</strong>。示例用法如下：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"First element greater than or equal to 3: "</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"No element greater than or equal to 3 found."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><code>std::upper_bound</code> 函数用于<strong>查找容器中大于指定值的第一个元素的迭代器</strong>。它返回一个指向该元素的<strong>迭代器</strong>。<strong>如果没有大于指定值的元素，则返回容器的 <code>end()</code> 迭代器</strong>。示例用法如下：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"First element greater than 3: "</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"No element greater than 3 found."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这些函数使得在有序容器中进行二分查找非常方便，可以帮助你快速定位元素并执行相关操作。</p><h5 id="左右指针模板（二分）"><a href="#左右指针模板（二分）" class="headerlink" title="左右指针模板（二分）"></a>左右指针模板（二分）</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//右闭</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> mid = left+(right-left)&gt;&gt;<span class="number">1</span>;<span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2、两数之和"><a href="#2、两数之和" class="headerlink" title="2、两数之和"></a><strong>2、两数之和</strong></h3><h3 id="3、反转数组"><a href="#3、反转数组" class="headerlink" title="3、反转数组"></a><strong>3、反转数组</strong></h3><h3 id="4、回文串判断"><a href="#4、回文串判断" class="headerlink" title="4、回文串判断"></a><strong>4、回文串判断</strong></h3><p>左右指针都可以仿照上面的模版</p>]]></content>
      
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和&amp;&amp;差分</title>
      <link href="/2023/10/04/qian-zhui-he-chai-fen/"/>
      <url>/2023/10/04/qian-zhui-he-chai-fen/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和专题"><a href="#前缀和专题" class="headerlink" title="前缀和专题"></a>前缀和专题</h1><p><strong>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。</p><p><strong>总结：下面题目基本上都是按照 前缀和presum[0]=0，presum[1]=第一个元素值</strong></p><p>在弄不清加一减一的时候，就想一下索引最大值</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="1、库函数优化"><a href="#1、库函数优化" class="headerlink" title="1、库函数优化"></a>1、库函数优化</h3><p>在C++中，可以使用STL（标准模板库）来优化前缀和的计算，特别是<strong>使用STL中的<code>partial_sum</code>函数</strong>。<code>partial_sum</code>函数可以快速计算数组的前缀和，而不需要手动编写循环来累加数组的元素。</p><p>以下是使用STL的<code>partial_sum</code>函数来计算前缀和的示例：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// 包含 partial_sum 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 partial_sum 计算前缀和</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">prefixSum</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    std::<span class="built_in">partial_sum</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), prefixSum.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印前缀和</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Prefix Sum: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : prefixSum) {</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上述示例中，我们首先包含了<code>&lt;numeric&gt;</code>头文件，其中包含了<code>partial_sum</code>函数。然后，我们创建一个与原始数组相同大小的<code>prefixSum</code>向量，并使用<code>partial_sum</code>函数计算前缀和，将结果存储在<code>prefixSum</code>中。最后，我们打印前缀和。</p><p>使用<code>partial_sum</code>函数可以让前缀和的计算更加简洁和高效，避免手动编写循环。这个函数非常适用于需要频繁计算前缀和的情况。</p><h3 id="2、经典写法"><a href="#2、经典写法" class="headerlink" title="2、经典写法"></a>2、经典写法</h3><h4 id="1-当presum-i-代表-nums-0-i-的前缀和时"><a href="#1-当presum-i-代表-nums-0-i-的前缀和时" class="headerlink" title="1)当presum[i] 代表 nums[0...i] 的前缀和时"></a>1)当<code>presum[i]</code> 代表 <code>nums[0...i]</code> 的前缀和时</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getPresum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">presum</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> presum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 nums[0...i] 的前缀和</span></span><br><span class="line">    presum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; presum.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        presum[i] = presum[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> presum;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRangeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; presum, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> presum[j];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> presum[j] - presum[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-当presum-i-代表-nums-0-i-1-的前缀和时-推荐"><a href="#2-当presum-i-代表-nums-0-i-1-的前缀和时-推荐" class="headerlink" title="2)当presum[i] 代表 nums[0...i-1] 的前缀和时(推荐)"></a>2)当<code>presum[i]</code> 代表 <code>nums[0...i-1]</code> 的前缀和时(推荐)</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getPresum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">presum</span><span class="params">(nums.size()+<span class="number">1</span>)</span></span>;<span class="comment">//presum[nums.size()]代表的是全nums数组的和</span></span><br><span class="line">    presum[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//便于计算前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> presum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 nums[0...i] 的前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; presum.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        presum[i] = presum[i - <span class="number">1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> presum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRangeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; presum, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> presum[j+<span class="number">1</span>] - presum[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; preSum;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//总共m行n列</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 构造前缀和矩阵</span></span><br><span class="line">        preSum = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">                <span class="comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">                preSum[i][j] = preSum[i<span class="number">-1</span>][j] + preSum[i][j<span class="number">-1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] - preSum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算子矩阵 [x1, y1, x2, y2] 的元素和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>{</span><br><span class="line">        <span class="comment">// 目标矩阵之和由四个相邻矩阵运算获得</span></span><br><span class="line">        <span class="keyword">return</span> preSum[x2+<span class="number">1</span>][y2+<span class="number">1</span>] - preSum[x1][y2+<span class="number">1</span>] - preSum[x2+<span class="number">1</span>][y1] + preSum[x1][y1];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>二维数组的前缀和一般都是从1索引开始，在计算一块区域的时候记住:<strong>二维数组前缀和，一般都从一开始。计算矩阵元素和，大的加一小不变（索引）。</strong></p><h1 id="差分数组专题"><a href="#差分数组专题" class="headerlink" title="差分数组专题"></a>差分数组专题</h1><p> <strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong></p><p>差分数组不能STL优化</p><p><strong><code>diff[i]</code> 就是 <code>nums[i]</code> 和 <code>nums[i-1]</code> 之差</strong>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> diff[nums.<span class="built_in">size</span>()];</span><br><span class="line"><span class="comment">// 构造差分数组</span></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>通过这个 <code>diff</code> 差分数组是可以反推出原始数组 <code>nums</code> 的，代码逻辑如下：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res[diff.<span class="built_in">size</span>()];</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>这样构造差分数组 <code>diff</code>，就可以快速进行区间增减的操作</strong>，如果你想对区间 <code>nums[i..j]</code> 的元素全部加 3，那么只需要<strong>让 <code>diff[i] += 3</code>，然后再让 <code>diff[j+1] -= 3</code></strong> 即可<strong>：</strong>因为只对区间 <code>nums[i..j]</code> 的元素全部加 3，[j+1… …]不变，如果 <code>diff[j+1]</code>不变， [j+1… …]也是加3</p><p><strong>原理很简单，回想 <code>diff</code> 数组反推 <code>nums</code> 数组的过程，<code>diff[i] += 3</code> 意味着给 <code>nums[i..]</code> 所有的元素都加了 3，然后 <code>diff[j+1] -= 3</code> 又意味着对于 <code>nums[j+1..]</code> 所有元素再减 3，那综合起来，就是对 <code>nums[i..j]</code> 中的所有元素都加 3 了</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; diff; <span class="comment">// 差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，接受一个初始数组 nums</span></span><br><span class="line">    <span class="built_in">Difference</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">assert</span>(nums.<span class="built_in">size</span>() &gt; <span class="number">0</span>); <span class="comment">// 确保输入数组不为空</span></span><br><span class="line">        diff = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">size</span>()); <span class="comment">// 初始化差分数组的大小</span></span><br><span class="line">        <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给闭区间 [i, j] 增加 val（可以是负数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        diff[i] += val; <span class="comment">// 更新差分数组的起始位置</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.<span class="built_in">size</span>()) {</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val; <span class="comment">// 更新差分数组的结束位置（注意边界检查）</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(diff.size())</span></span>; <span class="comment">// 初始化结果数组的大小</span></span><br><span class="line">        <span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2023/09/30/di-gui/"/>
      <url>/2023/09/30/di-gui/</url>
      
        <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=733411277&amp;bvid=BV1UD4y1Y769&amp;cid=915366282&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="500" padding-bottom:="" 56.25%="" high_quality="1" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe><p>​这个视频讲的很好，<strong>处理递归，核心就是千万不要想子问题的过程，你脑子能处理几层？马上就绕迷糊了。要想子问题的结果，思路就清晰了。</strong></p><p>​<strong>只要代码的边界条件和非边界条件的逻辑写对了，其他的事情交给数学归纳法就好了。也就是说，写对了这两个逻辑，你的代码自动就是正确的了，没必要想递归是怎么一层一层走的。</strong></p><p>我的想法是：<strong>明确递归函数的作用，坚定相信递归函数能做这件事。由此可以逻辑上分解做题思路。</strong>这是系统设计、网络设计上的常见思想。充分相信上层信息。</p><p>还有就是“回溯和递归是一套的，有一个递归就要有一个回溯”。不过很多回溯是隐性的。关键就是用递归分解问题，确定是否显性回溯。</p><p>留一个显性回溯的题目。</p><p><a href="https://leetcode.cn/problems/binary-tree-paths/description/">257. 二叉树的所有路径 - 力扣（LeetCode）</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231001184646709.png" alt="image-20231001184646709"></p><p><a href="https://www.programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><p><a href="https://www.zhihu.com/question/31412436/answer/683820765">对于递归有没有什么好的理解方法？ - 知乎 (zhihu.com)</a></p><p><strong>这篇把递归分三步</strong></p><p>①明确函数功能（以及参数和返回值），这点也是我想强调的。</p><p>②找到递归结束条件，这个在③后要再来一次，避免情况遗漏，很容易遗漏。</p><p>③<strong>找到函数的等价关系式</strong>，这个是作者提出的最难的部分，提出了一个观点（缩小参数的范围）。这个点也能覆盖住二叉树递归的情况。这一步类似于：“<strong>找到单层逻辑</strong>”。</p><p>记录一下圆桌会议：<a href="https://www.zhihu.com/roundtable/ruhexuehaoshujujiego">如何学好数据结构与算法 (zhihu.com)</a></p><iframe src="//player.bilibili.com/player.html?aid=428008124&amp;bvid=BV1nG411x77H&amp;cid=764491411&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="500" padding-bottom:="" 56.25%="" high_quality="1"> </iframe><p>不得不说这个labuladong的视频，真的解答了很多困惑。尤其是刷了三四天的二叉树合集之后。这个视频值得反复看。</p><p>【一周刷爆LeetCode，算法大神左神（左程云）耗时100天打造算法与数据结构基础到高级全家桶教程，直击BTAJ等一线大厂必问算法面试题真题详解】<a href="https://www.bilibili.com/video/BV13g41157hK?vd_source=4280d897d89a285191ff2a49582a555b">https://www.bilibili.com/video/BV13g41157hK?vd_source=4280d897d89a285191ff2a49582a555b</a></p><p>左程云+labuladong，配合食用。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231002212118059.png" alt="image-20231002212118059"></p><p><strong>前序是入栈，后序是出栈，中序是节点更换。N叉树没有中序遍历就是因为节点更换位置太多，不唯一。</strong></p><p><strong>只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。</strong></p><p><strong>所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候</strong>，那么进一步，你把代码写在不同位置，代码执行的时机也不同：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1.jpeg"></p><p><img src="https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%94%B6%E5%AE%98/2.jpeg"></p><p><strong>你可以发现每个节点都有「唯一」属于自己的前中后序位置</strong>，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。</p><p>这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。</p><p>说了这么多基础的，就是要帮你对二叉树建立正确的认识，然后你会发现：</p><p><strong>二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作</strong>。</p><p>你也可以看到，<a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/">图论算法基础</a> 把二叉树的遍历框架扩展到了图，并以遍历为基础实现了图论的各种经典算法，不过这是后话，本文就不多说了。</p><h3 id="两种解题思路"><a href="#两种解题思路" class="headerlink" title="两种解题思路"></a><strong>两种解题思路</strong></h3><p>前文 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/wo-de-shua-5fe0c/">我的算法学习心得</a> 说过：</p><p>**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/">回溯算法核心框架</a> 和 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/">动态规划核心框架</a>**。</p><p><code>Tip</code></p><p><code>这里说一下我的函数命名习惯：二叉树中用遍历思路解题时函数签名一般是 void traverse(...)，没有返回值，靠更新外部变量来计算结果，而用分解问题思路解题时函数名根据该函数具体功能而定，而且一般会有返回值，返回值是子问题的计算结果。</code></p><p><code>与此对应的，你会发现我在 [回溯算法核心框架](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 中给出的函数签名一般也是没有返回值的 void backtrack(...)，而在 [动态规划核心框架](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 中给出的函数签名是带有返回值的 dp 函数。这也说明它俩和二叉树之间千丝万缕的联系。</code></p><p><strong>虽然函数命名没有什么硬性的要求，但我还是建议你也遵循我的这种风格，这样更能突出函数的作用和解题的思维模式，便于你自己理解和运用。</strong></p><p>综上，遇到一道二叉树的题目时的通用思考过程是：</p><p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现。</p><p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</p><p><strong>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做</strong>。</p><h2 id="后序位置的特殊之处"><a href="#后序位置的特殊之处" class="headerlink" title="后序位置的特殊之处"></a>后序位置的特殊之处</h2><p>说后序位置之前，先简单说下中序和前序。</p><h2 id="中序位置主要用在-BST-场景中，你完全可以把-BST-的中序遍历认为是遍历有序数组。"><a href="#中序位置主要用在-BST-场景中，你完全可以把-BST-的中序遍历认为是遍历有序数组。" class="headerlink" title="中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。"></a><strong>中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。</strong></h2><h2 id="前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。"><a href="#前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。" class="headerlink" title="前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。"></a>前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。</h2><p>你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：</p><p><img src="https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%94%B6%E5%AE%98/2.jpeg"></p><p>这不奇怪，因为本文开头就说了前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。</p><h2 id="但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。"><a href="#但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。" class="headerlink" title="但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。"></a><strong>但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据</strong>。</h2><h2 id="那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。"><a href="#那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。" class="headerlink" title="那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。"></a><strong>那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231002214509684.png" alt="image-20231002214509684"></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用move优化程序</title>
      <link href="/2023/09/30/yong-move-you-hua-cheng-xu/"/>
      <url>/2023/09/30/yong-move-you-hua-cheng-xu/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) {</span><br><span class="line">        <span class="keyword">if</span> (!root) {</span><br><span class="line">            <span class="keyword">return</span> {};</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="type">int</span> cnt = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) {</span><br><span class="line">                Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (Node* child: cur-&gt;children) {</span><br><span class="line">                    q.<span class="built_in">push</span>(child);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">move</span>(level));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></p><p>在这段代码中，<code>ans.push_back(move(level));</code> 中的 <code>move</code> 是用来将 <code>level</code> 向量的所有权从当前的 <code>level</code> 向量转移到 <code>ans</code> 向量中。这个操作有几个作用：</p><ol><li><p><strong>性能优化</strong>：<code>move</code> 操作会将 <code>level</code> 的内部数据指针转移给 <code>ans</code>，而不是进行复制操作。这可以节省内存和提高性能，特别是当 <code>level</code> 向量包含大量数据时。</p></li><li><p><strong>清空 <code>level</code> 向量</strong>：通过执行 <code>move</code> 操作，<code>level</code> 向量将变为空，这有助于释放 <code>level</code> 中的内存，防止内存泄漏或不必要的资源占用。</p></li><li><p><strong>语义上的标记</strong>：使用 <code>move</code> 可以清晰地表示 <code>level</code> 向量已经不再需要，因为它的内容已经被转移到 <code>ans</code> 向量中。这有助于防止在后续代码中意外修改 <code>level</code> 向量。</p></li></ol><p>总之，<code>move(level)</code> 是为了将 <code>level</code> 向量的所有权转移到 <code>ans</code> 向量，以提高性能、释放内存并明确表示 <code>level</code> 向量不再需要。这在处理大型数据结构或需要优化内存使用的情况下特别有用。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础学习(无框架)</title>
      <link href="/2023/09/28/java-ji-chu-xue-xi-wu-kuang-jia/"/>
      <url>/2023/09/28/java-ji-chu-xue-xi-wu-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p><strong>C&amp;C++更多是造轮子的，java更多是用轮子的。</strong></p><p><a href="https://javaguide.cn/">Java 面试指南 | JavaGuide(Java面试 + 学习指南)</a></p><p><strong>学习路线：基本语法+网络+并发（学习go语言后可以不看）+框架（Springboot）</strong></p><p><strong>看的书里面推荐了Swing框架，但是目前来看，并不推荐学。可以学Spring</strong></p><p><strong>Java的很多API都提供了异常处理</strong></p><p><strong><img src="D:/桌面/media/41d57f251770c4f4149e339c6fdd966e.png"></strong></p><p><strong><img src="D:/桌面/media/bdf617ad4e5c8f23dbbbe8536be34858.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/314bf4a47592c553174d4a72856f7c69.png"></strong></p><p><a href="https://www.w3cschool.cn/java/java-exceptions.html">Java 异常处理_w3cschool</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f5a1ac74c8d90c29141523f011437885.jpeg"><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/78d75271aa7cfe01a58c0f619fae2a5c.png"></strong></p><p><strong>注意，非检查异常实际上是默认使用的（即使不去声明，也会一直在使用）。非检查的异常是由糟糕的编程导致的。</strong></p><p><strong><img src="D:/桌面/media/771c1d9f17b248503796f2d5f763db10.png"></strong></p><p>Java的异常处理是try,catch,finally。比C++多了个finally。finally可以<strong>保证Java程序不管发生什么异常，总会使代码照常执行</strong>，这是对Java异常处理块的最佳补充。还有一点值得一提就是，finally可以维护对象的内部状态，还可以清理非内存资源。如果不使用finally就必须编写代码来释放那些非内存资源。</p><p>在c++中，所有类型(包括原语和指针)都可以作为异常抛出（throw）。但是在Java中，只有可抛出对象(Throwable对象是Throwable类的任何子类的实例)可以作为异常抛出。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4ce2c5332db24fb642a6c1f99f6de8c8.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e601d2ca3a003fc552a24a377c6c6acc.png"></p><p><strong>throw的用法是throw new 异常处理类（“异常处理语句”）</strong></p><p><img src="D:/桌面/media/36932d8aace7609f4b8ddbb91cdbc8b1.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e5eef9a5444066ac28738e557a04a1cc.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/13137dfcbb09385386337b0a24843650.png"></p><p><a href="https://blog.csdn.net/MrYushiwen/article/details/109814008">(108条消息) Java异常处理详解(全文干货，写得非常全，值得收藏)_java 异常_MrYuShiwen的博客-CSDN博客</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f16936cac31dce5170ec4e321dffde6b.png"></p><p><img src="D:/桌面/media/9570f9e4678ab6da0ff756a56a702cd7.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0797936faf8dd6cbe01370de827eaf97.png"></p><p><a href="https://zhuanlan.zhihu.com/p/99770142">2020 年最棒的 9 个 Java 框架，哪个最香？ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/yoyo31/article/details/117994678#:~:text=10%E7%A7%8D%E6%B5%81%E8%A1%8C%E7%9A%84Java%E6%A1%86%E6%9E%B6%201%201.Spring%20%E8%BF%99%E6%98%AF%E5%85%B6%E4%BB%96Java%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%BB%9D%E5%AF%B9%E9%A2%86%E5%AF%BC%E8%80%85%E3%80%82%20%E6%8E%8C%E6%8F%A1Spring%E6%98%AFJava%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E8%81%8C%E4%BD%8D%E6%9C%80%E6%99%AE%E9%81%8D%E7%9A%84%E8%A6%81%E6%B1%82%E4%B9%8B%E4%B8%80%E3%80%82%20...%202%202.Play,MyBatis%20...%208%208.Struts%20Struts%E6%98%AF%E7%94%A8%E4%BA%8E%E5%88%9B%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7Java%20Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E6%BA%90MVC%EF%BC%88%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE-%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89%E6%A1%86%E6%9E%B6%E3%80%82%20...%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE">(108条消息) 10种流行的Java框架_最受欢迎服务器框架_普通网友的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/49893350">Java中的内部类 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/zhao_miao/article/details/83245816">(108条消息) Java内部类的定义、如何创建内部类、内部类的分类、内部类与外部类的关系_java创建内部类_zhao_miao的博客-CSDN博客</a><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d1751b38bdd2f321b938ddd7d4f96719.png"></p><p><strong>内部类可以分为四种：</strong></p><ol><li>实例内部类（成员内部类）：直接定义在类当中的一个类，在类前面没有任何一个修饰符 （这种内部类相当于是外部类的一个对象，它的对象需要用外部类对象new出来），内部类可以访问所有外部类成员（包括private），但是外部类方法不能访问内部类的成员。实例内部类必须依赖于外部类，<strong>需要用外部类的对象创建内部类的对象</strong>。非内部类不能被声明为private或protected访问类型。这个是要考虑到内部类的向上转型为接口 可以完全隐藏内部类的具体实现。外部提供一个接口，就可以有多个内部类以不同的方式实现。这个是一般的类实现不了的。成员内部类内部<strong>不允许存在任何static变量或方法</strong> 正如成员方法中不能有任何静态属性 （成员方法与对象相关、静态属性与类有关）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9a3dc0ab2eb711f6a93238febfe5cd54.png"></p><p>如果在外部类中定义的成员变量与内部类的成员变量名称相同，可以使用this关键字（感觉应该不推荐这么做）</p><p><img src="D:/桌面/media/b51d83c5c27d804f63cd3c4f4b53a850.png"></p><ol><li>静态内部类：在内部类前面加上一个static</li></ol><p>静态内部类不可以使用任何外部类的非static类（包括属性和方法），但可以存在自己的成员变量</p><ol><li>局部内部类：定义在方法的内部类</li></ol><p>方法内部类<strong>不允许使用访问权限修饰符</strong>（public、private、protected）均不允许</p><p>方法内部类对外部完全隐藏，<strong>除了创建这个类的方法可以访问它以外，其他地方均不能访问</strong> (换句话说其他方法或者类都不知道有这个类的存在)方法内部类对外部完全隐藏，出了创建这个类的方法可以访问它，其他地方均不能访问。</p><p>方法内部类如果<strong>想要使用方法形参</strong>，该形参必须使用final声明（JDK8形参变为隐式final声明）。（如果需要在方法体中使用局部变量，该局部变量需要被设置为final类型，换句话说，<strong>在方法中定义的内部类只能访问方法中final类型的局部变量</strong>，这是因为在方法中定义的局部变量相当于一个常量，它的生命周期超出方法运行的生命周期，由于该局部变量被设置为final，所以<strong>不能在内部类中改变该局部变量的值</strong>）</p><p><img src="D:/桌面/media/d0d80297a2e199be795f338ec00858f6.png"></p><ol><li>匿名内部类：属于局部内部的一种特殊情况</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/602c28b2e2930688497afb10996716a7.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4d37889b3ca52b1b97d2393e5e46984f.png"></p><p>类包的主要作用是解决类的同名问题，便于代码复用。Java包通常是第一行代码（package …），而且应该全部使用小写字母。</p><p>在使用import关键字时，可以指定类的完整描述，如果为了使用包中更多的类，可以在使用import关键字指定时在包指定后加上*，这表示可以在程序中使用包中的所有类。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a598327663eaaa15e0a870649420c120.png"></p><p>final关键字修饰基本数据类型时，其值不可变。final关键字修饰引用类型时，指向不可变。类似于C++的const。const *是指向的值不可变，*const是指向不可变。C++的引用是*const即指针常量</p><p>在Java中定义全局常量，通常使用public static final修饰，这样的常量只能在定义时被赋值。</p><p><a href="https://blog.csdn.net/yyhhlancelot/article/details/81531940">(108条消息) C++ 继承与java继承之区别_yyhhlancelot的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_45707610/article/details/124980431?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-124980431-blog-123145312.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-124980431-blog-123145312.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=1">(108条消息) JAVA与C++的区别详解_c++和java_xiaoweids的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/tsingke/article/details/109153565?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-109153565-blog-81531940.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-109153565-blog-81531940.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=3">(108条消息) Java与C、C++的10大区别-总结_Tsingke的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/HD243608836/article/details/78060704">java中函数覆盖（即重写override），子类的返回类型一定要和父类一样吗？_子类返回值类型必须与父类相同吗_HD243608836的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/71576194#:~:text=1%20%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E8%A6%81%E6%B1%82%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E5%BF%85%E9%A1%BB%E4%B8%80%E8%87%B4%EF%BC%8C%E8%80%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E8%A6%81%E6%B1%82%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E5%BF%85%E9%A1%BB%E4%B8%8D%E4%B8%80%E8%87%B4%E3%80%82%202%20%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E8%A6%81%E6%B1%82%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%BF%85%E9%A1%BB%E4%B8%80%E8%87%B4%EF%BC%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%AF%B9%E6%AD%A4%E6%B2%A1%E6%9C%89%E8%A6%81%E6%B1%82%E3%80%82%203,%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%8F%AA%E8%83%BD%E7%94%A8%E4%BA%8E%E5%AD%90%E7%B1%BB%E8%A6%86%E7%9B%96%E7%88%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E7%94%A8%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%EF%BC%88%E5%8C%85%E6%8B%AC%E4%BB%8E%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%89%E3%80%82%204%20%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%AF%B9%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%92%8C%E6%8A%9B%E5%87%BA%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9C%89%E7%89%B9%E6%AE%8A%E7%9A%84%E8%A6%81%E6%B1%82%EF%BC%8C%E8%80%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%9C%A8%E8%BF%99%E6%96%B9%E9%9D%A2%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E9%99%90%E5%88%B6%E3%80%82%205%20%E7%88%B6%E7%B1%BB%E7%9A%84%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%8F%AA%E8%83%BD%E8%A2%AB%E5%AD%90%E7%B1%BB%E8%A6%86%E7%9B%96%E4%B8%80%E6%AC%A1%EF%BC%8C%E8%80%8C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%89%80%E6%9C%89%E7%9A%84%E7%B1%BB%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E8%BD%BD%E5%A4%9A%E6%AC%A1%E3%80%82">Java继承中的方法覆盖、重载（及实例化对比） - 知乎 (zhihu.com)</a></p><p><strong>在Java中使用extends关键字来标识两个类的继承关系，显然java只能实现单一继承。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/ed346947b00cdf82496615cc1f252b16.png"></strong></p><p><strong>在子类中可以连同初始化父类构造方法来完成子类初始化操作，既可以在子类的构造方法中使用super()语句调用父类的构造方法，也可以在子类中使用super关键字调用父类的成员方法等。但是子类没有权限调用父类中被修饰为private的方法，只可以调用父类中修饰为public或protected的成员方法</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/26d8aa9705c6df463102add2e1f87018.png"></strong></p><p><strong>当重写父类方法时，修改方法的修饰权限只能从小的范围到大的范围改变，例如，父类中的doSomething()方法的修饰权限为protected，继承后子类中的方法doSomething()的修饰权限只能修改为public，不能修改为private</strong></p><p><strong>（这里的重写指的是函数覆盖）java函数覆盖的条件有点儿多</strong></p><p><strong>覆盖必须满足一个对象向上转型为它的基本类型并调用相同方法这样一个条件</strong></p><p><strong>在实例化子类对象时，父类无参构造方法将被自动调用。有参构造方法不能被自动调用，用户只能使用super关键字显式地调用父类的构造方法。（从最顶级父类开始构造）</strong></p><p><strong>Java有一点特殊，所有类都是Object的子类（直接或者间接，不声明extends的都是直接子类）。所以所有类都可以使用或者重写Object中的一些方法（主要包括clone()、finalize()、equals()、toString()等方法，其中常用的两个方法为equals()和toString()方法）</strong></p><p><strong>在使用String对象时，应该注意运算符“==”比较的是对象的引用地址，equals()方法是比较内容。但是在自定义类中，equals()默认的也是比较引用地址，需要使用的话，应该自己重写一下。</strong></p><p><strong>类的对象的向上转型总是安全的，但是向下转型就会出现很多问题（而且要注意，必须显式类型转换）。</strong></p><p><em>// 向上转型：将父类引用指向子类对象</em></p><p>Father f = new Son();</p><p>f.sleep();//<em>输出“爸爸睡觉”</em></p><p><em>// 向下转型</em></p><p>Father f = new Son();</p><p>((Son)f).P();<em>//输出“儿子调皮”</em></p><p><img src="D:/桌面/media/2922d7751d5e09d83b2248e9d9de40ce.png"></p><p><a href="https://blog.csdn.net/HuoYiHengYuan/article/details/84855069">(108条消息) Java向上转型和向下转型的通俗简单理解以及使用用途_java中向上转型和向下转型的作用_苏一恒的博客-CSDN博客</a></p><p><strong>Java函数重载还有多态（父类兼容子类，子类不兼容父类）等方面跟C++还是差不多的。但是抽象的关键词从virtual变成了abstract，可以给类名前面加上这个关键词声明，抽象方法不能有方法体，只要有抽象方法就是抽象类（但是抽象类不一定要有抽象方法）。</strong></p><p><strong>由于java的类只接受单一继承，所以支持多继承的接口应运而生。接口更倾向于特定功能的实现，类的继承更倾向于从属关系。接口相当于纯抽象类，接口的所有方法都没有方法体。接口的变量只能是而且默认是public static final类型，接口的方法只能是public，而且默认是public abstract类型。在接口中定义的任何字段都自动是static和final的。</strong></p><p><strong>接口用interface关键字定义，使用接口的时候用implements关键字。接口的多重继承用逗号隔开</strong></p><p><strong><img src="D:/桌面/media/491fd6e04672c46211bce82d81ccbf7f.png"></strong></p><p><a href="https://www.cnblogs.com/dolphin0520/p/3811437.html">深入理解Java的接口和抽象类 - Matrix海子 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq_44543508/article/details/102609910">(108条消息) java抽象类（abstract）与接口（Interface）的区别_抽象类和接口的区别_宜春的博客-CSDN博客</a></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1908def5606690cb95a5574b4ad7a7d6.png"></strong></p><p><strong>上图的第五点已经变了，现在接口可以有静态方法，但是不能继承只能调用。</strong></p><p><strong>Java自带的大数运算、高精度运算是一个非常亮眼的特点。BigInteger类是针对大整数的处理类，而BigDecimal类则是针对大小数的处理类。BigInteger类支持任意大小的整数，BigDecimal扩展支持了小数。</strong></p><p><strong>初学者应该记不全这些函数，只需要记住类就好，然后Ctrl+N查找这些类，那里能看到使用方法。</strong></p><p><strong>Java有一种叫做包装类的东西：Java是可以直接处理基本类型的，但在有些情况下需要将其作为对象来处理，这时就需要将其转换为包装类。基本类型到包装类，基本类型基本上都是小写，转换成包装类就转换成大驼峰（基本类型不是复合词，所以只要首字母大写就行了）。除了int是变成Integer，char是变成Character</strong></p><p><strong>抽象类Number是BigDecimal、BigInteger、Byte、Double、Float、Integer、Long和Short类的父类</strong></p><p>无论是C++还是Java，只要有两个迭代器，表示开头和结尾，所指示范围都是不包括结尾那个元素</p><p>在Java中使用java.text.DecimalFormat格式化数字。在Java中没有格式化的数据遵循以下原则：</p><p>如果数据绝对值大于0.001并且小于10000000，使以常规小数形式表示。</p><p>如果数据绝对值小于0.001或者大于10000000，使用科学记数法表示。</p><p><img src="D:/桌面/media/060abbc6d725a20eb261d3b0d33d0c7e.png"></p><p>在Math类中存在一个random()方法，用于产生随机数字。这个方法默认生成大于等于0.0且小于1.0的double型随机数，即0&lt;=Math.random()&lt;1.0</p><p>与C&amp;C++需要手动释放内存不同，Java有垃圾回收机制，用户不必担心废弃的对象占用内存，垃圾回收器会自动回收无用却占用内存的资源。<strong>但是垃圾回收机制只能回收用new操作符创建的对象</strong></p><p>var这个数据类型相当于C++的auto，但是并不推荐使用</p><p>Java没有地址传递，只有值传递</p><p><a href="https://blog.csdn.net/demo_yo/article/details/115984217">(106条消息) java实现swap函数的几种方案_java swap_Whitemeen太白的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/bjweimengshu/article/details/79799485">(106条消息) 为什么说Java中只有值传递_程序员小灰的博客-CSDN博客</a>这个解释比较清楚</p><p>最简单的实现应该就是借助数组进行交换</p><p><strong>注意，JAVA中大小写非常严格</strong></p><p><a href="https://blog.csdn.net/kuangay/article/details/81485324">(105条消息) Java static关键字详解_Cappuccinooo的博客-CSDN博客</a></p><p>Java常见的static跟C++中的作用大部分一样（但是java的static不会改变访问权限），声明为静态，可以在没有对象（不依赖于对象）的情况下直接调用，静态函数只能使用静态成员。所以，<strong>如果想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。</strong></p><p><strong>最常见的静态方法就是main方法，这就是为什么main方法是静态方法就一目了然了，因为程序在执行main方法的时候没有创建任何对象，只有通过类名来访问。</strong></p><p>局部变量不可以声明为static</p><p>类的地方，略有不同。Java中引入了“包”的概念</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7127c0bffe4685b1b9c2463390d2d7b6.png"></p><p>当声明类时不使用public、protected和private修饰符设置类的权限，则这个类预设为<strong>包存取范围</strong>，即只有一个包中的类可以调用这个类的成员变量或成员方法。<strong>Java语言规定，类的权限设定会约束类成员的权限设定</strong></p><p>注意switch语句在C++和java中有区别，C++的switch不支持字符串，但是java支持。C++要想用字符串就借助constexpr</p><p>Java中也有遍历元素的操作，与C++不同，C++是for(auto i:array);java是for(int i:array)，即java是具体类型。Java的forEach方法实现同样功能。</p><p>C++字符串比较是用strcmp，java字符串比较是用compareTo方法</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/51f47a442a799a51406be37ce154a3d6.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f384a9ca41362766f8b2acfa49e76b88.png"></p><p><img src="D:/桌面/media/3816ef8a8e4f5040ca4bd7150d24dae9.png"></p><p>三个双引号在java里面是文本块，必须使用一个换行</p><p>方法是小驼峰，类和文件是大驼峰</p><p>常量名（final）一般用全大写字母表示，当定义的final变量属于“成员变量”时，必须在定义时就设定它的初值，否则将会产生编译错误</p><p>同包的方法不需要import导入，在IDEA中ctrl+N是查询方法快捷键。</p><p>Java.lang不需要导入，包含常见的Math和String等</p><p>将class文件打包为jar文件，可以用命令行运行jar</p><p><strong>Springboot:这个使用中涉及到了JS和HTML</strong></p><p>使用 向导 或者Spring Initializr，获取Maven包，解压并添加模块，/src/main/java里面运行，可以运行一个服务器。使用浏览器localhost:8080（<a href="http://localhost:8080）访问这个服务器。">http://localhost:8080）访问这个服务器。</a></p><p>JS里面反引号``也表示拼接，了解就行</p><p>注解是必须的</p><p><a href="http://localhost:8080/add?%E5%8F%82%E6%95%B01=%E5%80%BC1&amp;%E5%8F%82%E6%95%B02=%E5%80%BC2">http://localhost:8080/add?参数1=值1&amp;参数2=值2</a></p><p><a href="https://zhuanlan.zhihu.com/p/634522077">Java 容器详解：使用与案例 - 知乎 (zhihu.com)</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d301f8bc08d4bc80a26ad101fe1be4b7.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2babc362e8965f9a0bff69dc6d7aaa21.png"></p><p><img src="D:/桌面/media/d0b7053582bd2802e0ca117d734c33ce.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/672901a72ce5cf778b0648ff8a09d720.jpeg"></p><p><strong>注意：Map没有继承Collection接口</strong></p><p>java.util包中提供了一些集合类，这些集合类又被称为容器。提到容器不难想到数组，集合类与数组的不同之处是，数组的长度是固定的，集合的长度是可变的；数组用来存放基本类型的数据，<strong>集合用来存放对象的引用</strong>。常用的集合有List集合、Set集合和Map集合，其中List与Set继承了<strong>Collection接口</strong>，各接口还提供了不同的实现类。上述集合类的继承关系如上图所示。</p><p><img src="D:/桌面/media/6900bee42772bf8b60bf0e9f15d1cdc9.png"></p><p>Java也有迭代器，是这么用的：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/21c9e227d386aa314fe0e187fa7164cb.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/180d099ef672c9b8fdf45cceefdf5a12.png"></p><p>C++的迭代器是这么用的：</p><p><img src="D:/桌面/media/16ae9edf917f46fc03f648059217f3a3.png"></p><p>Java 的迭代器有两个重要的函数 ①boolean hasNext（）②对象 next（）</p><p>容器的特点基本上与C++保持一致</p><p><img src="D:/桌面/media/6fcda427ce90e0815ec9ca90c1cd6ad9.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e4d416ca0ae78e5308f870e3b7e404f5.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1c1f1cdcfa102341d4ec03f9299fa2e6.png"></p><p>存入TreeSet类实现的Set集合必须实现Comparable接口，该接口中的compareTo(Object o)方法比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、0或正整数。</p><p>headSet()、subSet()、tailSet()方法截取对象生成新集合时是否包含指定的参数，可通过如下方法来判别：如果指定参数位于新集合的起始位置，则包含该对象，如subSet()方法的第一个参数和tailSet()方法的参数；如果指定参数是新集合的终止位置，则不包含该参数，如headSet()方法的入口参数和subSet()方法的第二个入口参数。</p><p><img src="D:/桌面/media/d5bc44e9a80f38110649fc3a3d3df33e.png"></p><p>Map集合中允许值对象是null，而且没有个数限制。例如，可通过“map.put(“05”,null);”语句向集合中添加对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0be754c793a31c899940e42d06adc81c.png"></p><p>Java语言定义了许多类专门负责各种方式的输入／输出，这些类都被放在java.io包中。其中，所有输入流类都是抽象类InputStream（字节输入流）或抽象类Reader（字符输入流）的子类；而所有输出流都是抽象类OutputStream（字节输出流）或抽象类Writer（字符输出流）的子类。</p><p><img src="D:/桌面/media/b4debbec758d594ed152dd6e6a185173.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/8c93b55b9ab6be6e12b8511108ff9bad.png"></p><p>并不是所有的InputStream类的子类都支持InputStream中定义的所有方法，如skip()、mark()、reset()等方法只对某些子类有用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习（无框架）</title>
      <link href="/2023/09/28/python-ji-chu-xue-xi-wu-kuang-jia/"/>
      <url>/2023/09/28/python-ji-chu-xue-xi-wu-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p>因为是以前的PDF转的Markdown,很多图片在上传图床的时候出了问题，暂时没有想到好的解决办法，将就一下吧</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/03ef78595848ed93ebf0db0171cf3d95.png"></p><p>注意<strong>函数不能修改不可变对象</strong>，C++的swap在python里面是一句a,b=b,a</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/fb4a7202372fc8f46b0d33bbb0e5e1cd.png"></p><p>Python不适合大工程，但是做小型项目就非常快。web推荐Django(好处是全面)，Flask（轻量）。桌面的话就推荐PyQt。</p><p>字符串不可改变，只能换新。<strong>split()<strong>可以基于指定分隔符将字符串分隔成多个子字符串(存储到列表中)。如果不指定分隔符，则</strong>默认使用空白字符(换行符/空格/制表符)。</strong></p><p><strong>join（）</strong>的调用对象是“分隔符”，参数是字符串列表。</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/521dbeefac9c8dec33977701045d8acf.png"><img src="D:/桌面/media/2dee1a946c2d645d64338f0324a2d0f5.png"></strong></p><p><strong>变量在栈内存，对象在堆内存，变量是对象的引用（地址）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/69696b15fa732f3728d6d2563437f3a1.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/eae1a4e6e2c4b3a046a4af953794351f.png"></p><p>常量字符串也相当于缓存</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/fde29955aa45ea9ab8c9446961b6bccb.png"></p><p>is对比id，==调用equal</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f08621679d95377e3dc1bc261de1f283.png"></p><p><img src="D:/桌面/media/a7dff5ee018135538cc1c8c4b0e88eda.png"></p><p><a href="https://blog.csdn.net/weixin_38981172/article/details/90176525">python中的各种符号（欢迎补充）_python符号大全_杉木人的博客-CSDN博客</a></p><p>Python的很多语法接近java。Python里面没有long，int可以无限大 。//是地板除，结果是整数。**是幂的意思。python里面没有单字符类型char，python里面单个字符也是字符串类型</p><p><a href="https://blog.csdn.net/moqisaonianqiong/article/details/114674204">python中format用法（最全汇总）_python语言format用法_西部点心王的博客-CSDN博客</a></p><p>Python里面去掉了很多C++和java的格式，<strong>用缩进和冒号代替了大括号（千万不要忘记冒号）</strong>，缩进是区分大括号内容的重要参考，语句之间不需要分号隔开了</p><p>注释的区别：在Python中，<strong>使用“#”作为单行注释的符号</strong>。从符号“#”开始直到换行为止，其后面所有的内容都作为注释的内容而被Python编译器忽略。多行注释是三引号（单引号或双引号都可以），在Python中，三引号（’’’……’’’）或者（”””……”””）是字符串定界符。所以，如果三引号作为语句的一部分出现，那么就不是注释，而是字符串。在JS中三引号有着同样的作用。</p><p><img src="D:/桌面/media/55ab63cdad4c7db3f48daa60492e00a7.png"></p><p>有一个链式赋值可以注意一下。</p><p>Python代码规范：函数、类的属性和方法、包名全小写。类名大驼峰。内部类类名_大驼峰。常量名是全大写</p><p>使用单下划线“_”开头的<strong>模块变量或者函数是受保护的</strong>，在使用import*from语句<strong>从模块中导入时这些变量或者函数不能被导入</strong>。</p><p>使用双下划线“__”开头的<strong>实例变量或方法是类私有的</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/5b3157cc5b1a36bcf58ca28c4712efaf.png"></p><p>Python的索引很神奇，允许是负数，-1就是最后一个元素，0是第一个元素，也就是循环<img src="D:/桌面/media/38b1d47d4916fe53e189174efd79f089.png"></p><p>如果想要复制整个序列，可以将start和end参数都省略，但是中间的冒号需要保留。例如，sname[:]就表示复制整个名称为sname的序列。</p><p>序列支持相同类型（序列类型，不是数据类型）相加。序列支持乘法（仅限与整数型），在Python中，使用数字n乘以一个序列会生成新的序列。新序列的内容为原来序列被重复n次的结果</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/69b6873d84fb6243d87a868a2434c391.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3056c83a7c1995b9119af3bbc2de8393.png"></p><p><img src="D:/桌面/media/b8143fb754253c08bc023cf18742b72b.png"></p><p><img src="D:/桌面/media/e2a7467582549419d5ef7d0a4fe7085c.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/99845659f5e2ea9a4b25586b1f877c89.png"></p><p>列表的使用非常灵活，可放进任意类型，同一个列表可容纳不同类型。用中括号括起来。</p><p>在使用列表时，虽然可以将不同类型的数据放入同一个列表中，但是通常情况下，我们不这样做，而是在一个列表中只放入一种类型的数据。这样可以提高程序的可读性。</p><p>使用list()函数不仅能通过range对象创建列表，还可以通过其他对象创建列表。</p><p>print(列表名)在输出列表时，是包括左右两侧的中括号的。</p><p>元组是不可变的列表（不可变是指单个元素不可修改，只能对整个元组进行重新赋值）。列表是中括号，元组是圆括号。元组的访问速度更快，元组可以作为字典的键，但是列表就不行</p><p>字典类似于C++和java的map，但是字典是无序的，java 的map是一个接口，有有序的也有无序的。<strong>字典用花括号，键与值之间用冒号：隔开</strong></p><p>注意一下，dict（）和zip（）</p><p>enumerate()函数用于将一个<strong>可遍历的数据对象（如列表或元组）</strong>组合为一个索引序列，同时<strong>列出数据下标和数据</strong>，一般在for循环中使用。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/324a8226693add7cdddb4e491590735e.png"></p><p><strong>Python的保留字和标识符是严格区分大小写</strong></p><p><strong>Python中以下划线开头的标识符有特殊意义，一般应避免使用相似的标识符。</strong></p><p><strong>①以单下划线开头的标识符（如_width）表示不能直接访问的类属性，另外，也不能通过from xxx import *导入；</strong></p><p><strong>②以双下划线开头的标识符（如__add）表示类的私有成员；</strong></p><p><strong>③以双下划线开头和结尾的是Python里专用的标识，例如，<strong>init</strong>()表示构造函数。</strong></p><p>在Python语言中允许使用汉字作为标识符，如“我的名字=”明日科技””，在程序运行时并不会出现错误（如图2.17所示），但<strong>建议读者尽量不要使用汉字作为标识符</strong>。</p><p>在Python中，<strong>不需要先声明变量名及其类型，直接赋值即可创建各种类型的变量</strong>。需要注意的是，对于变量的命名并不是任意的，应遵循以下几条规则。</p><ol><li>变量名必须是一个有效的标识符；</li><li>变量名不能使用Python中的保留字；</li><li>慎用小写字母i和大写字母O；</li><li>应选择有意义的单词作为变量名。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/5a86591ffecb35716bbd2bbf2250b7c1.png"></p><p>这跟java和C++都不一样，它们都需要声明类型。</p><p>Python是动态类型的语言（也称为弱类型语言），不需要像Java或者C语言一样在使用变量前必须先声明变量的类型。虽然Python不需要先声明变量的类型，但有时仍然需要用到类型转换。例如a=100是整型，在Java里面可以print(“hello”+a)，但是在python就是错的，print(“hello”+str（a）)这样才对</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/128ea372360a3032345e4825b75a56ce.png"></p><p>另外，<strong>Python是一种动态类型的语言</strong>，也就是说，<strong>变量的类型可以随时变化</strong>。例如，在IDLE中，创建变量nickname，并赋值为字符串“碧海苍梧”，然后输出该变量的类型，可以看到该变量为字符串类型，再为变量赋值为数值1024，并输出该变量的类型，可以看到该变量为整型。在Python语言中，<strong>使用内置函数type()可以返回变量类型</strong>。</p><p>在Python中，<strong>允许多个变量指向同一个值</strong>。将两个变量都赋值为数字2048，再分别应用内置函数id()获取变量的内存地址，将得到相同的结果。在Python语言中，<strong>使用内置函数id()可以返回变量所指的内存地址</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9a93575f55d0a91a996456c8fd66252b.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0b9d520320aca530fd4089c0457d5073.png"></p><p><img src="D:/桌面/media/8fe797b6eb248716345214123f839cf6.png"></p><p>Python的print和java的println一样，是自动换行的</p><p>注意，python没有switch语句。for语句也有一些不一样</p><p><img src="D:/桌面/media/92508e2d275ff63cea0f899efe7f0e12.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/863b02ba481b7d019e2325d8ead1f5e3.png"></p><p><img src="D:/桌面/media/f1db99fac41d62bcae3b4ae9b6de983d.png"></p><p>在保留了break和continue之外，Python多了一个代表doNothing的pass语句</p><p><img src="D:/桌面/media/2ffae691893dc0be9750bdb1fa5367de.png"></p><p>在Python里面没有提供定义 常量的保留字，不过在PEP 8规范中定义了常量的命名规范为大写字母和下划线组成，但是在实际项目中，常量首次赋值后，还是可以被其他代码修改。</p><p>在python中，前缀区分进制：</p><p>十进制开头不能是0，二进制是只有1或者0<br>在Python 3.x中，对于八进制数，必须以0o/0O开头</p><p>十六进制必须以0X或0x开头。</p><p>Python将数值转化为字符串的函数是str(arg)</p><p>Python里面有一个复数类型。Python中的复数与数学中的复数的形式完全一致，都是由实部和虚部组成，并且使用j或J表示虚部。当表示一个复数时，可以将其实部和虚部相加，例如，一个复数，实部为3.14，虚部为12.5j，则这个复数为3.14+12.5j。</p><p>在Python中，字符串属于不可变序列，通常使用单引号“’’”、双引号“”””或者三引号“’’’ ‘’’”或“”””””””括起来。这三种引号形式在语义上没有差别，只是在形式上有些差别。其中单引号和双引号中的字符序列必须在一行上，而三引号内的字符序列可以分布在连续的多行上</p><p>其中，str表示Unicode字符（ASCII或者其他）；bytes表示二进制数据（包括编码的文本）。这两种类型的字符串不能拼接在一起使用。通常情况下，str在内存中以Unicode表示，一个字符对应若干个字节。但是如果在网络上传输，或者保存到磁盘上，就需要把str转换为字节类型，即bytes类型。</p><p>Python的startswith、endswith函数与java的startsWith、endsWith函数是一样的</p><p>函数定义时参数列表中的参数就是形式参数，而函数调用时传递进来的参数就是实际参数，就像剧本选主角一样，剧本的角色相当于形式参数，而演角色的演员就相当于实际参数。</p><p><strong>当实际参数为不可变对象时，进行的是值传递；当实际参数为可变对象时，进行的是引用传递。这个看后面的解释比较好，按照栈内存和堆内存区分</strong></p><p>值传递和引用传递的基本区别就是，进行值传递后，改变形式参数的值，实际参数的值不变；而进行引用传递后，改变形式参数的值，实际参数的值也一同改变。</p><p>定义函数时，为形式参数设置默认值要牢记一点：默认参数必须指向不可变对象。</p><p><img src="D:/桌面/media/aa723b6d69286e768c13aca610fd290a.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b5b34040403c38b50498bf3e2534f3f2.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/34f5eb856589e3e9db1fd61222214952.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/33c977ed9328da06844b3095188c49e7.png"></p><p><img src="D:/桌面/media/89414341722e7044822b003c1c246fbf.png"></p><p>记住*参数是元组，**参数是字典</p><p>Python里面用global关键字修饰全局变量</p><p>Python类名使用“大驼峰命名法”</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7de5e29e56fb8f04933bf88242a9fdc9.png"></p><p>类里面的函数都需要一个self参数</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9911e6d1a881e3488c41cf5aba852d7e.png"></p><p><img src="D:/桌面/media/816f677122870edca3a30dd27e3559c1.png"></p><p>类属性是全类用一个，共享。实例属性 是每个实例的都不一样，区别是实例属性用self定义</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/bf592487cb836c1bf906070044c14ae6.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2191ade786c4ff99bf0a64b03a4c88ce.png"></p><p>保护属性可以通过实例名访问。</p><p><img src="D:/桌面/media/125a014c20f548e9a0ccdf1693990245.png"></p><p>私有属性可以在类的实例方法中访问，也可以通过“实例名.类名__xxx”方式访问，但是不能直接通过实例名＋属性名访问。</p><p>_<em>foo__：首尾双下划线表示定义特殊方法，一般是系统定义名字，如__init</em>_()。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/830d7a8cd6f4d0446c135d6b7cb3bfeb.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/c8b085c1932495870b374d15fdd6e26e.png"></p><p><img src="D:/桌面/media/d97b751ff004ba1bd421a218dd53f439.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d40dd248f3bd7fc2c9b4adf4a82af749.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6ad79cc3f123f55cdedf27a1d227808f.png"></p><p>在Python里面也用super（）表示父类，java是用super。</p><p>Python的__init__（）函数里面应该有下面这句</p><p><img src="D:/桌面/media/6dbc069288a6e14240aa1de25db94d56.png"></p><p>而java的构造函数需要只需要一句super()；</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/dc3152e5f4e15ae629fc1c311618f9c2.png"></p><p><a href="https://blog.csdn.net/weixin_35684521/article/details/81396434">Python中的 if _<em>name</em>_ == “<strong>main</strong>“到底是个啥意思？_大表哥在曾母暗沙的博客-CSDN博客</a></p><p>if _<em>name</em>_ == “<strong>main</strong>“<strong>：</strong>这个语句使得<strong>该文件作为模块使用时下面的代码不运行</strong></p><p><img src="D:/桌面/media/cc06c906d6edff9ea019665c33a32af5.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/71c56e2c522582a79524793030804630.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/cd1b89ee15c868917caa13dd7b40d126.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a4aa18d9fd5e8981e29d98d42c16e074.png"></p><p><strong><img src="D:/桌面/media/f27bcd249cf17587bd790510b1b8a5ca.png"></strong></p><p><strong>总结：import什么，以后调用就要用什么</strong></p><p><strong>在异常处理方面，python跟java类似，但是java是catch，Python是except。抛出异常方面java是throw就跟C++一样，但是Python是raise。Python也有断言assert</strong></p><p><strong><img src="D:/桌面/media/87280a5742b3a08c2510ecce9416b656.png"></strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e9fb901e4c9c5ea487b43e77e2ec891e.png"></p><p>Python的文件打开模式是</p><p><img src="D:/桌面/media/16d04a53e970d4773aad39c93d880d43.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/56de5343546efc74a7cd255100b0bda3.png"></p><p><img src="D:/桌面/media/fde8941d67c26072d96099d31523fbc5.png"></p><p><a href="https://www.runoob.com/python3/python3-mysql.html">Python3 MySQL 数据库连接 – PyMySQL 驱动 | 菜鸟教程 (runoob.com)</a></p><p>尽管wxPython不是最流行的GUI，但他是书里面的。</p><p>正常情况下更推荐PyQT5</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/bb90e6c1710ee7be0e3ec92b88761782.png"></p><p>一般情况都用不到</p><p><strong>序列</strong></p><p><strong>列表：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/642b224f788c91057cb8bcaa8ebd70b5.png"></p><p>例a=[10,20,30,40]，则del a[2]和a.pop(2)和a.remove(30)是一样的效果，都是在原列表上的操作。remove是删除第一个该元素</p><p>sort和sorted的reserve为True时都是降序</p><p>sort和reserve都是在原列表上操作，方便的操作应该是都赋值一下。</p><p><strong>元组</strong></p><p><img src="D:/桌面/media/48c527366ccb11ed30405eef55f0cc2b.png"></p><p>元组是不可变的列表，元组圆括号（可以省，这是唯一可以省的序列）。</p><p><strong>这个不可变是指里面的不可变元素（数字等）不可变，如果元组里面的子对象（列表等）是一个可变子对象，是可以修改的。</strong></p><p>元组特色zip()：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/8688a6c2a7256c8ac0022dd2212d23c5.png"></p><p>字典经常用它构造（二元）。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1329006ad1917c59bf84bc5059804f5e.png"></p><p>生成器内部维护了一个指针，产生一个生成器对象，生成器对象有一个__next__()方法用于遍历。<img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7dded9565f6099ab74c4107119891229.png"></p><p>**<br>**</p><p><strong>字典</strong></p><p>字典是快速通过键对象获取值对象：<img src="D:/桌面/media/1b8ea5f01f1bf0bb252e843abc04e251.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/5b0961cc8d4ab7541430b8be270dd6e2.png"></p><p>字典的访问通常使用get（），因为这个方法不会抛异常，而是在找不到的时候默认None</p><p>get(查找的键对象key,找不到时的默认值)</p><p><img src="D:/桌面/media/08a591e9409c6a58645387309f56974c.png"><img src="D:/桌面/media/24a4d72636d0cf896d00d373684a45fd.png"></p><p><img src="D:/桌面/media/b283095130a877c4d813d0e8ed9fa37e.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/86f1062878e155504a4f19d344f05b15.png"></p><p><strong>———————————————————————————————————————</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/ff8633246f59c7fc6bdc274c8cb648cc.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/343a74b7ce0333081a944a0cea2f6f47.png"></p><p>删除的话有pop()和del()，参考元组和列表，将索引替换为键对象即可。还有clear（）清空。</p><p>还有popitem()无参函数，随机删除一个（很少见 ）。</p><p><img src="D:/桌面/media/4c9cacfbb0970b6d39a1d6e66afe1005.png"><img src="D:/桌面/media/21d188e627a4813d695aeb2e512d9e92.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/53f42e31e43faf22eadc0c80aa758c41.png"></p><p>字典的底层实现看一下资料</p><p><strong>集合</strong></p><p>相当于字典的键对象集合</p><p><img src="D:/桌面/media/756ed47d83453b3fab5530f222501e95.png"></p><p>也用花括号</p><p><img src="D:/桌面/media/9ded222351c54e1acfb7247e44fc5b9e.png"><img src="D:/桌面/media/a84fb17820b43fb06d7105df371c198a.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4e193ad8f257364f215a65c4ace0531d.png"></p><p>条件表达式</p><p><img src="D:/桌面/media/f4881d3d836672642c8b0ba49e328846.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e8156f57b51145720134921423f03d9a.png"><img src="D:/桌面/media/a40365c9dba1fe8899626149548fd724.png"></p><p><img src="D:/桌面/media/2d642db26c8823f4ff585900649fd0bd.png"></p><p><img src="D:/桌面/media/88c0467a76727676731c03ce9b506149.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6976ff28e24ee13cb2174aa3fec44740.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1094a5535946971ac2437b92921bf8b5.png"></p><p>全局变量尽量少用（会降低通用性和可读性），且局部变量效率更高</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2a5b1e3ef9d98fc82dc8ed4aaa78ed4d.png"></p><p><img src="D:/桌面/media/5ad43ca60ddfedf90d95f1ef993fce7d.png">-</p><p><img src="D:/桌面/media/0bcd78c21723403e8afa218e71fe627e.png"></p><p><img src="D:/桌面/media/fb4a7202372fc8f46b0d33bbb0e5e1cd.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d08efb40d3a9ef9fcb0a3fd1db4ce2ca.png"></p><p><img src="D:/桌面/media/b37371125bbeed34df9bd0fe1a626e97.png"></p><p>a=print_star</p><p>b=a</p><p>则a和b都指向了实际的对象，b不会指向a，a的改变（不是实际对象改变）不会影响b</p><p>python的赋值都是引用赋值。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0f8bea5b794089eadd01ffa7c98f50d4.png"></p><p>栈区里面那个方框是栈帧，代表了def里面的变量。所以在def里面a覆盖了全局的a，如果a被声明为global，则是调用了帧外的那个a。栈帧里面是局部变量，外面（不在任何一个帧里面）是全局变量</p><p>python的垃圾回收是指堆区的对象没有一个箭头（引用），则该对象被自动回收。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b9c7d648809848d7986685869f4da8b4.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1ee91cd71900052b8c774e931b9133e2.png"></p><p>这个内置函数需要导入copy模块</p><p><img src="D:/桌面/media/1b9c8a889b5c2bbfe5600b450bdc8cef.png"></p><p>浅拷贝：拷贝一层对象，子对象拷贝了引用。对子对象的修改会影响到拷贝对象，对最浅层的修改不会。例如上面加一句b[1]=99，那么也不会影响到a</p><p>深拷贝：直接完全复制，所有子对象都一起复制了。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4fc245c97f5a5c663912a8501dc3d4b4.png"></p><p><img src="D:/桌面/media/065411778fd8a4a34c14bc4cc37c2343.png"></p><p>这样想：函数在执行修改的时候，只有修改不了（不可变对象）的时候才会创建一个新的对象。当然，修改不了的时候会抛出异常，但是理解就行。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4d18918fa76200a669686f5a1c41f96a.png"></p><p>内部函数 是为了避免函数内大量重复代码。外面是不能调用内部函数的。</p><p>non_local是声明外层的局部变量，目的是为了使用外层的局部变量。</p><p><img src="D:/桌面/media/371bbfeca007041a4d2fccb52faa23d6.png"></p><p>OOP</p><p>Python的方法也是属性。</p><p>类里面的属性和方法 都可以动态添加、修改，当然，是通过类名调用的。但是要注意一个事情，原方法需要self参数的，修改后的方法也应该有一个slef参数（参数名随便起，但必须有一个），不然就会报错</p><p>python里面数字也是对象，java里面int等不是对象，有专门的数字对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f7486670e2a166ba717b2ce0598d8026.png"></p><p>_<em>init</em>_()是构造函数，用于初始化。</p><p>_<em>new</em>_()是创建函数，用于函数的创建，但是我们一般不需要重定义。</p><p>class里面的是共享属性，构造函数里面的是实例属性（self.定义的），对象私有的。</p><p>实例方法是第一个参数是self的函数。</p><p>self是实例的地址。这也就表明了为什么带self的是不共享的，不带self的是共享的。</p><p>self参数是解释器自动传参的，我们不用管。</p><p><img src="D:/桌面/media/f99102c872111faeb7dd1ad2a2961801.png"></p><p>类对象，实例对象，类属性，和 实例属性之间的关系</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4b2f84312ff3c8b33304eb3e0bb561bf.png"></p><p>很少用</p><p><img src="D:/桌面/media/26575707b05459b254bab673ca235799.png"><img src="D:/桌面/media/1c60770ae4336bd251147231b249eafc.png"></p><p>静态对象不需要cls，也不需要self，就是一个普通函数，放在了类的命名空间</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/ce34dac57c89947c9a8e9f7451db0f0e.png"></p><p>这也就说明了，类名调用的是__init__()函数，类名（）调用的是__call__()函数。</p><p><strong>python里面没有方法（函数）重载，只要重名就会覆盖，哪怕一个有参一个无参。</strong></p><p><img src="D:/桌面/media/bd0993c05d4bc74ad8b1f4b12c54a538.png"></p><p>双下划线开头的是私有的，解释器在运行的时候 把 <strong>__私有方法</strong> 解释为<strong>_类名__私有方法</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/258dbfe3a3851d69bd1e7310436ff0c1.png"></strong></p><p><strong><img src="D:/桌面/media/b726bea957e0e8684d6e0534a8bb007a.png"></strong></p><p><strong>注意一下，这里salary必须是私有属性，不然就会报错。当然一般也只有私有属性会用这两个装饰器。</strong></p><p>**<br>**</p><p>python支持多重继承的，java不支持多重继承，但是java’可以有多个接口。</p><p>python的类都默认继承了object类</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d15b477cbe7914868d60c342942fa4dd.png"></p><p>python的继承是除了构造函数全部继承，哪怕是私有也会被继承</p><p><img src="D:/桌面/media/4f3f353fa13f5b110f07b58f362677f6.png"></p><p>注意一下，在用super().xxx的时候，xxx不要加参数self</p><p><strong>help(类名)可以看帮助文档</strong></p><p><img src="D:/桌面/media/7586d446e88710f6a894c7fd051f799c.png"></p><p>调用str(对象)的时候，实际上都是自动调用了对象的__str__()方法。</p><p>实操中尽量避免多重继承。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7977b6d03d0bcc400cd9e27f2667fc28.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/20e0ef7f2d608ca49e2ac416ed9cb827.png"></p><p><img src="D:/桌面/media/964247d6f43c19678fdacb32d20d2962.png"></p><p>super()代表的是父类的定义，不是对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2ffe68ad9332090ac8962d181e3988b9.png"></p><p><strong>重载运算符，则重写这些特殊方法就行</strong></p><p>说起重载，python不支持自增自减运算符</p><p><img src="D:/桌面/media/837d2d84e6058faf4d44bab587d2d989.png"></p><p><img src="D:/桌面/media/af2a15a4388e51b8c50074ed34cae3e7.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/bc2d539e6c1fc425621fbc40f7a99968.png"></p><p><img src="D:/桌面/media/e83c06af222ce2b98869cb8a8c0fbf04.png"></p><p><img src="D:/桌面/media/aa9a92fd27744840c7bd690ca9582a4e.png"></p><p>设计模式：工厂模式和单例模式。</p><p>单例模式常用的方法就是重写__new__()方法</p><p>异常处理</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/567a5f6a6d2dd4719b6e2212e67cb54b.png"><br><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b698d9cb91c6deeae18581ce9e73cf4a.png"></strong></p><p><strong>出现异常后，try语句里面异常后面的就不会执行了。except完成后，就接着执行except语句后面的语句</strong></p><p><strong><img src="D:/桌面/media/c161001982d0608ca7da756dfb603730.png"></strong></p><p><strong>先子类后父类，针对性地写代码</strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e605df63744dec248f83bb9fb2935ed0.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/51dc122f44d5c6dad955adcb063a525d.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a637fea850e68e326b198a6dcbba9e97.png"></strong></p><p><strong>return放到异常处理语句里面通常会发生意想不到的错误，一般不建议</strong></p><p><strong><img src="D:/桌面/media/69d0e7c17ddb38d79606ada48d8fa110.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b39f6b57edcd68fcd4b1a8aee7ad3380.png"></strong></p><p><strong>打开资源的时候用with比较方便，其他时间用finally更方便</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9722de82fa2b86c5f772d7a29cecb606.png"></strong></p><p><strong><img src="D:/桌面/media/d9adc2bceda871f9d7b7cc3d52ec9134.png"></strong></p><p><strong>打印到文件里面</strong><a href="https://www.runoob.com/python/python-func-open.html">Python open() 函数 | 菜鸟教程 (runoob.com)</a></p><p><strong><img src="D:/桌面/media/f331f0e07584fa2100dc15cd929e2604.png"></strong></p><p>**<br>**</p><p><strong>文件操作</strong></p><p><strong><img src="D:/桌面/media/97603811d560cb61623f087c3862950d.png"></strong></p><p><a href="https://blog.csdn.net/mahoon411/article/details/109097222">python 字符串前面加‘r’的作用(并举例说明)_python中r的用法_吮指原味张的博客-CSDN博客</a></p><p>r表明字符串不需要转义</p><p>最好都使用with处理文件资源（不需要close()）</p><p><strong>with xxx as x:……</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/63c9ea1a89f0de1ed9e139ee5acaa01f.png"></strong></p><p><strong><img src="D:/桌面/media/8cbdd9a380c148eaac64796999fc2f3c.png"></strong></p><p><strong>程序在写入文件的时候也是UTF-8</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/8ffb45ba4c0bab7f7291c2a481a6f664.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3e166495ff6df5e49daa1ded93ca2aa6.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2c5e4ab4f5d8a24e6de8fc5ea207d1e3.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6632b903c963856103b0664fe310efc4.png"></strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/9c862f20ee2979e7cf50c73da5dbf0ef.png"></strong></p><p><strong><img src="D:/桌面/media/cf053e96f9ec44f3c8238e50582ba5fe.png"></strong></p><p><strong>OS模块很重要，OS和OS.path</strong></p><p><strong><img src="D:/桌面/media/35600c157168e0205da3942420749677.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d49c362255c2f3d204b8c4b50263293e.png"></strong></p><p><strong>我们可以先调用mkdir（）创建目录，再open()创建文件。</strong></p><p><a href="https://www.runoob.com/python/python-func-repr.html">Python repr() 函数 | 菜鸟教程 (runoob.com)</a></p><p>**repr()的主要作用是将换行符等格式字符转化为转义字符输出<br>**print(repr(os.linesep))</p><p><strong>通过chdir()和mkdir()和makedirs()可以在任意已知目录创建目录（文件夹）</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a175eee504097075b7c370b99b5934bd.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1a26bbea91d7f4d8469015f217f43476.png"></strong></p><p><strong><img src="D:/桌面/media/8cd9c3402256e3e43732d9a5964db0ce.png"></strong></p><p><strong><img src="D:/桌面/media/2d162345cdcbab8d15ac2af2e358f059.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/19940b27caba1435eafd0c76a6e1e3f8.png"></strong></p><p><strong>shutil模块是可以直接压缩一个文件夹，zipfile提供了动态压缩的方法</strong></p><p>**<br>**</p><p><strong>练习：在当前目录下怎么创建多级目录</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/dfa036235cd99929437ea4ad6c9f25d1.png"></strong></p><p><strong>关键在于os.path.join()的使用，不要用r“\shuji\music\book”这种形式。而且不要在makedirs（）里面用相对路径，会被识别为“C：相对路径”。</strong></p><p>**<br>**</p><p><strong>练习（#重要#常用）：递归遍历目录树</strong></p><p><strong><img src="D:/桌面/media/05fd91c33a1a57b408281898d1ba9d14.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7e3a0b8a9052f91eb74f940e2052cef5.png"></strong></p><p><strong>API（文档首部）相当于先搭好一个框架，构建好。具体的实现不提及，最后搭好后编码实现。</strong></p><p><strong>有一些函数是不应该被外部调用的，最后变私有</strong></p><p><strong>在math里面很多函数是pass，是因为这个模块是用来链接C库的，C已经写好了，python直接拿来用。</strong></p><p><strong><img src="D:/桌面/media/201cd7bcc2fe2565b5e504874c70647e.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e1f818703598f4af1643370bd0a6a45c.png"></strong></p><p><strong>推荐from … import …,但不推荐from … import *。总是import一个模块，会让最后项目体积很臃肿。import后面是可以直接使用的，导入模块则 模块名.函数名，导入函数则 函数名。</strong></p><p><strong>动态导入（一般用不到，少见）<br><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a08422d3aa0f6f7a8a2c079e06a81b3d.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/796d86b5bad6b588c2463dce5c058826.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4d412c4a644c3e1a24d740c94b290352.png"></strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/0c404f4455dfafc531533f0ea72003ac.png"></strong></p><p><strong><img src="D:/桌面/media/6d13a317be7dd287ebb7a04ef9e31be7.png"></strong></p><p>**<br>**</p><p><strong>Tkinter学习（这个只适合最简单的，最好用PyQt）</strong></p><p><strong>但是很多窗口框架之类的思想是通用的</strong></p><p><a href="https://docs.python.org/zh-cn/3.11/library/tk.html">Tk图形用户界面(GUI) — Python 3.11.4 文档</a></p><p><a href="https://www.tcl.tk/man/tcl8.6/TkCmd/contents.html">Tk Commands (tcl.tk)</a></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b98aff805ddbb98dacbde454efb1c141.png"></strong></p><p><strong>按钮等组件都需要pack()装载到窗口里，pack()默认是流水线（垂直）装载。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/323160099463587c5a33d4310834b4d4.png"></strong></p><p><strong>用Label显示图像的时候，图片需要是全局的。</strong></p><p><strong>也可以将photo声明为self，实例参数。推荐声明为实例参数。</strong></p><p><strong>command参数赋值不加（）</strong></p><p><strong>label的很多功能是字典给的，label重载了“索引赋值”__setitem__函數。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/cc4348d9260290ce1b12bc8891e881cf.png"></strong></p><p><strong>Entry用来做单行文本框</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3bbc8395eb890d96c101ab7c3dbad584.png">注意绑定的函数一定要有一个参数event</strong></p><p>**<br>**</p><p><strong>练习（自制登录系统without数据库版）：</strong></p><p><strong>问题：一定要注意StringVar，要知道里面的内容应该用get()，不能直接和字符串比较</strong></p><p><strong><img src="D:/桌面/media/b26eb59e6de9d221c58e6b35e7a60ccf.png"></strong></p><p><strong>行从1开始，列从0开始</strong></p><p><strong>Canvas的原点是左上角，一般用对角线两个点。</strong></p><p><strong>grid（格子布局），pack（简单布局），place（坐标布局）</strong></p><p><strong>练习（自制扑克牌）</strong></p><p>关键在于bind_class()这个函数还有列表的使用</p><p><strong>command方式只适合简单情况，不涉及event对象。bind（）函数处理event对象。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1eda32faa3a7c506c5a80556956588d9.png"></strong></p><p><strong>还有很多具体函数什么的，看文件吧。</strong></p><p><strong>注意：颜色选择框函数askcolor()会返回一个列表[(rgb),颜色代表字符]，调用bg和fg的时候，参数一般是列表第二项“字符”</strong></p><p><strong><img src="D:/桌面/media/58e43ef161af6114361f6c54b5a94f8f.png"></strong></p><p><strong>注意一下这个快捷键的处理，lambda返回的是“函数的名字（暂时这样理解吧）”。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/98368a90b4e8186cdfccb332d8000e0d.png"></strong></p><p><strong>这种lambda实现了已有函数的传参</strong></p><p><strong><img src="D:/桌面/media/69beb7d10b276aae6a77ef600c44df0f.png"></strong></p><p><strong>需要这种形式的时候参考，这些函数不用很容易忘。</strong></p><p>**<br>**</p><p><strong>打包</strong></p><p><strong>在pyinstaller打包的时候，运行最后的exe总是弹出控制台，解决方法如下：</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/c0bd3fd85a82257d609a221b4ce3cb95.png"></strong></p><p><strong>-w有时候不好用，推荐方法一</strong></p><p>**<br>**</p><p><strong>Pygame没有学，以后或许可以了解一下，留个位置吧</strong></p><p>**<br>**</p><p><strong>并发编程</strong></p><p><a href="https://www.runoob.com/python3/python3-multithreading.html">Python3 多线程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://docs.python.org/zh-cn/3/library/threading.html">threading — 基于线程的并行 — Python 3.11.4 文档</a></p><p><strong><img src="D:/桌面/media/17bb1627c9ec9707d575236f024c3587.png"></strong></p><p><strong><img src="D:/桌面/media/d4897f63e60cdc922245e0e98a0b9a6b.png"></strong></p><p><strong><img src="D:/桌面/media/60a174956571aac30effd1e2b0761614.png"></strong></p><p><strong>容易忘，线程必须用start()启动</strong></p><p><strong>哪怕不声明线程，每个程序启动都会有一个主线程。</strong></p><p><strong>线程类一般重写__init__（）和run(),run()是start()后自动执行的</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a9805712cb6ba8e0ab88922942745d3f.png"></strong></p><p><strong>子线程①.join()就行了，主线程会等待这个子线程①</strong></p><p><strong>直接使用线程是</strong><a href="https://blog.csdn.net/chpllp/article/details/54381141">python多线程模块：threading使用方法（参数传递）_threading.thread 传入参数_chpllp的博客-CSDN博客</a></p><p><strong>通过类方式使用线程：</strong></p><p><strong><img src="D:/桌面/media/83cf6dee9f35e6c12d639aab7d0d5b02.png">子线程类的init只能用Thread，用super（）有问题。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/03583c6d70f1fad84c3a881deb1707af.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/83107a32b908af0517de1dbd869d3cf2.png"></strong></p><p><strong>setDaemon()已经被废弃了，现在直接修改“属性”就行</strong></p><p><strong>注意：必须先设置daemon才能start（），否则<img src="D:/桌面/media/78ff4f2647fe6cc0ffb7dc84ea701b51.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/670067e04d3c17704b584ffd4436cff5.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b7cb75dfd8556ebf5f1ff8801274b949.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/aa6b88fb9a0f56c97129549645b03d7f.png">这个锁的概念在数据库里比较详细</strong></p><p><strong><img src="D:/桌面/media/770b8df096790aa66762c9982422a7bf.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9837d98e798699acf620ef4eba1dfa13.png"><img src="D:/桌面/media/c77fc2dc50c7ccf4d997ac13c1853a85.png"></strong></p><p><strong>这个acquire和release是信号量的方法。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/5a2d15a46f7506800be8dc3f29e3fcfc.png">相当于tk的event对象</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/fc1f255d86521862732e2133980428c9.png"></strong></p><p><strong>生产者和消费者模式：</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9a19e21a0c1206b9236f5a5975d8aeaf.png">这个经常会见到的</strong></p><p><strong>进程的类方法使用和线程差不多</strong></p><p><strong>注意print(f“ada{arg}”)的使用</strong></p><p><strong>注意：进程间不能直接使用代码的全局变量，全局变量是主进程的，新建的几个进程是用不了的（堆内存和栈内存都不共享）</strong></p><p><strong>Manage管理器和Queue其实差不多，都是找一个内存空间，供所有进程存取。</strong></p><p><strong><img src="D:/桌面/media/b71ad6e10602e06ed734cafe9a7b30d2.png"></strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/249121b49b91bfc75f23350eba9c4e23.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d0714153f35a004281c8c8c7ce4b97be.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e5b98ad18581b788eb569efe01438de3.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4b2e0017f9dcdde4da4b6634a45814fa.png"></strong></p><p><strong><img src="D:/桌面/media/405fd07564cc2be747d31909d3f99c89.png"></strong></p><p>套接字编程</p><p><a href="https://geek-docs.com/python/python-tutorial/python-socket.html">Python 套接字教程|极客教程 (geek-docs.com)</a></p><p><a href="https://docs.python.org/zh-cn/3/howto/sockets.html">套接字编程指南 — Python 3.11.4 文档</a></p><p><strong><img src="D:/桌面/media/c5f9f6381b590e702b4e4bfcf922ddd7.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0e387551485169e715eec8a63a7a5740.png"></strong></p><p><strong><img src="D:/桌面/media/187a42cd4f8d3aeffbefbd96eb291ebf.png"></strong></p><p>TCP是有连接的，UDP是无连接的。所以connect函数是TCP的</p><p><img src="D:/桌面/media/187a42cd4f8d3aeffbefbd96eb291ebf.png"></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3c505e61f8728b922d7d4bc2d4ea663b.png"></strong></p><p><strong><img src="D:/桌面/media/c33e04ca419b6ccd8d452d4f8d5385a1.png"></strong></p><p><strong><img src="D:/桌面/media/ebeadcfc86331bea044c428a04d22d3d.png"></strong></p><p><strong>发送数据的时候，python3把字符串转化为byte，默认的网络助手的编码是gbk</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a83c5ea5af4243b9b0c790ae73607216.png"></strong></p><p><a href="https://blog.csdn.net/Z_Stand/article/details/102535706">C语言网络编程：accept函数详解_c accept_z_stand的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/cindy-cindy/p/8022009.html#:~:text=accept,%28%29%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%8C%E4%B8%8D%E5%90%8C%E4%BA%8E%E4%BB%A5%E4%B8%8Asocket%20%28%29%E8%BF%94%E5%9B%9E%E7%9A%84%E7%94%A8%E4%BA%8E%E7%9B%91%E5%90%AC%E5%92%8C%E6%8E%A5%E5%8F%97%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%9B%E4%B8%8E%E6%AD%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%98%AF%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%E6%96%B0%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8A%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E6%9D%A5%E5%AE%8C%E6%88%90%E7%9A%84%E3%80%82">Python中网络编程对socket accept函数的理解 - 小女子的测试之路 - 博客园 (cnblogs.com)</a></p><p><strong>发送数据的时候，python3把字符串转化为byte，默认的网络助手的编码是gbk</strong></p><p><strong>注意：绑定的参数是一个元组_addr（IP地址，端口号）</strong></p><p><strong>绑定bind的参数是_addr</strong></p><p><strong>recv_from和recv的参数是最大字节数，因为UDP和TCP接受信息不可能事先就知道从哪儿来的（接收全球信息），没有_addr参数。</strong></p><p><strong>send_to的参数要这个_addr，还要一个data（要转gbk）。send就不需要了，它是TCP的函数，已经建立好连接了，不用传参_addr</strong></p><p><strong>第一步都是建立socket对象，最后一步都是关闭这个socket对象。UDP服务端接下来就是绑定bind和接受消息recv_from，最后close。UDP客户端接下来就直接是发送消息sendto。TCP的服务端接下来就是绑定，监听listen（参数是套接字排队的最大连接数，即同一时刻最多允许几个套接字连接），一个阻塞accept（返回一个client_socket对象和信息），接收recv（用前面返回的client_socket对象接收，因为同一时刻可能会有多个客户端，用client_socket区分），发送是send（也是用client_socket进行通信），关闭(先关client_socket，再关server_socket)。TCP的客户端需要connect（连接一下，参数就是_addr元组，用自己创建的client_socket调用），然后recv和send跟服务端一样。</strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/c5a4cc61addd0078d359c6ea19c568fd.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b636da3f185f8f6759b6e111de4895f3.png"></strong></p><p><strong>高阶函数用函数当参数</strong></p><p><strong>注意，如果函数参数需要参数，则这样定义高阶函数</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/81f916a8b27754d5d4f16547c4d3decf.png"></strong></p><p><strong><img src="D:/桌面/media/2dc96d9a216380a4851dc1201f837e3f.png">实际上就是设置默认值的函数</strong></p><p><strong>例如：默认的int（）的base默认是10</strong></p><p><strong><img src="D:/桌面/media/77d643b897f7705e590c696b078f54bc.png">这样就把默认值从10变成了2</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d5d8fb00c863534089314bf63a85dd67.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/8828ca013db424b24ea008d2f0dad8f9.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/8a741d497008584d9aa72763c5d7efe6.png">闭包就是一个内部函数</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d0c2859c084cc88c930b2eee16786830.png"></strong></p><p><strong><img src="D:/桌面/media/7e0e94db24f8ba295c72d740966eb5ad.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/10921db4ce0a382876f0d7d8ee2371dc.png"></strong></p><p><strong><img src="D:/桌面/media/1756974674cd648eb2e1b35ef8c8c17a.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/412e08f6ff32b36214c2a2967126a4eb.png"></strong></p><p><strong><img src="D:/桌面/media/d7bb28e513aac1287f2434ba5828ddde.png">自由变量在外部栈帧消失后，由内部指向，所以不会被回收。自由变量不会污染其他程序，但是自由变量又有全局变量的好处。内部要修改自由变量的时候，要用nonlocal声明。</strong></p><p><strong>闭包是装饰器的基础</strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f84a29d4465d8e4296a50407001734c8.png"></strong></p><p><strong>这个使用更方便，不用也行（写循环）</strong></p><p><strong><img src="D:/桌面/media/5c9e5d388604ead3ed9bb7853d524481.png"></strong></p><p><strong>快速检验：</strong>print(list(map(lambda a,b:a+b,[1,2,3,4],[10,20,30])))</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/c2cb294883f8d5084128405af328a982.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b12977522c9f6acab2adf05930b6b52f.png"></strong></p><p><strong>reduce就是累积的调用，注意“一个序列”，“至少两个参数”，需要导入模块</strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/c9d0a488933197118cc20d292b30e856.png"></strong></p><p><strong>注意，传入的函数返回值必须是布尔值。</strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/afb0f3c88f956d0ee8211638f9fbda20.png"></strong></p><p><strong>实际上就是在函数参数前面一行加上@外部函数</strong></p><p><strong>一个函数可以有多个装饰器</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/bfe84a775041a006f652425d72be4d29.png">实际上就是说</strong></p><p><strong><img src="D:/桌面/media/336c3e414be4cf3f2710dc2f26fa3cdd.png">等于mylog(costlog(func1)).定义阶段先执行costlog再执行mylog。执行阶段先执行mylog再执行costlog</strong></p><p><strong>装饰器有参数的时候，直接<img src="D:/桌面/media/020269843604ed6e0658ac955c3b3f99.png">就行</strong></p><p><strong>注意一下，内部函数的邻近外部函数的参数应该是函数参数（我们一般写作func），最外层函数则不需要这个（如果最外层不是内部函数的邻近外层）。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/93407d69391a7cbdd765dfe60684d83a.png"></strong></p><p><strong><img src="D:/桌面/media/614f431f2e013aab0dbf65ab5a475a35.png"></strong></p><p><strong>不使用wraps的话，后续调用func的doc等是空的。</strong></p><p><strong>注意infunc（）一定要返回infunc</strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/a71bea50315b6bd2661f159d8d1fd821.png">最常见property，其他不常见。</strong></p><p><strong><img src="D:/桌面/media/3814c66b83692697ad7e3ab7beb5f7db.png">适合只有self参数的函数</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6576c13a242c11cc9ff9e5d553a89d6a.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b8d54002f864c43c45d57914f3e09a77.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/482f24e98ca8a6a09b571ff5ceaef263.png"></strong></p><p><strong><img src="D:/桌面/media/77e06b09e9f0b28bd1e41c52bc7ee1c7.png"><img src="D:/桌面/media/2ebd2630cfb76c684cfed5e91c1adaf2.png"></strong></p><p><strong>一般要将func函数参数初始化init为实例参数。</strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/81db23386040a2d474817c7e3fce89b2.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/361f6c97fc2c5a96f35922409d591f7e.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3853ae15dd091c836067c99dcd9c2bb1.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0bb363dee73c4c3ea0af2ccf3161cbbc.png"></strong></p><p><strong>生成器的例子，用圆括号</strong></p><p><strong><img src="D:/桌面/media/cc01e860a1a7d6f9df4de0afc1f79bd0.png"></strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/8881ca70dc9f5874b399c779cc5b2baa.png"></strong></p><p><strong>这个就触及了生成器的本质了</strong></p><p><strong><img src="D:/桌面/media/011fcbf6116b9ef47ec7fadae24fa8e1.png"></strong></p><p><strong>函数里面有一个yield类型对象，则函数就是生成器对象</strong></p><p><a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">python中yield的用法详解——最简单，最清晰的解释_python yield_冯爽朗的博客-CSDN博客</a></p><p>把yield理解为return就好，每次记录停留位置。</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6b3ee37d2363fad453f10b029d6d6c35.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6207dcdd960f94135e3092d80da7c442.png">例如这个就代表了两个语句。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/5b957086b366afaa10a0139c20b6489e.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7a5492b1087087e5e37f21f8f9098519.png"></strong></p><p><strong><img src="D:/桌面/media/2b071f5d71be22710c2d9298cec25028.png"></strong></p><p><strong><img src="D:/桌面/media/0d7a529883cdcd8d4d1d26195dcf3009.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/c67ab68631f13d1101f4b68a260c636f.png"></strong></p><p><strong>for循环就是调用iter（）将list，dict，str等转化为迭代器</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f200f4d23bdea2ce320efc66a4590fcd.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7dd6d8a841d2a15fcd80529c92ad6ff4.png"></strong></p><p><strong>这个倒是不怎么用</strong></p><p><strong>例子：</strong></p><p><strong><img src="D:/桌面/media/b56d814dfd9db7b77b8a993ac7010f54.png"></strong></p><p><a href="https://zhuanlan.zhihu.com/p/392519274">一文看懂python的迭代器和可迭代对象 - 知乎 (zhihu.com)</a></p><p><strong>python是动态的，可以动态添加、修改属性和方法。但是需要注意的是方法需要用到形如</strong></p><p><strong>cls1.func=types.MethondType(func1,cls1) ，而属性就可以直接赋值。</strong></p><p><strong>但是可以用__slots__关键字限制动态添加成员变量和成员方法。</strong></p><p>**<br>**</p><p><strong>正则表达式是使用标准库的re模块。用到可以查资料。</strong></p><p><strong><img src="D:/桌面/media/3b01e4cbc31af0e86153658d2a06ac23.png"></strong></p><p><strong>pattern就是正则表达式。</strong></p><p><strong>flags是标志位</strong></p><p><strong><img src="D:/桌面/media/a7d4691384e2ec14bd650a747adebdce.png"></strong></p><p>**<br>**</p><p><strong>关键在于正则表达式的书写</strong></p><p><strong><img src="D:/桌面/media/9d314434a7ae9e314ee2ecee3406235c.png"></strong></p><p><strong>还有就是一个限定符</strong></p><p><strong><img src="D:/桌面/media/2c1da7152391fa08d626e2ef326d2941.png"></strong></p><p><strong>由于\是转义字符，在正则表达式中总会引起不便，可以用r前缀转换为原生字符串。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f65f6f8a1c898b8802f6e83ac698bcfc.png"></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记</title>
      <link href="/2023/09/28/opengl-xue-xi-bi-ji/"/>
      <url>/2023/09/28/opengl-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>写在最前面，我的开发主要在VS2022上面，通过代码学程序，很多函数是不懂的。这个时候<strong>VS的快捷键F1就可以快速查看函数文档，很有用。</strong>（glut函数按F1查看不到）<a href="https://www.opengl.org/resources/libraries/glut/spec3/spec3.html">GLUT API, version 3 — GLUT API，版本3 (opengl.org)</a>这里是参考文档<br><a href="https://zhuanlan.zhihu.com/p/374920616">opengl新手教程（通俗易懂） - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/Wang_Dou_Dou_/article/details/121240714">OpenGL初学者入门——学习指南【共 9 篇文章】_opengl学习_一支王同学的博客-CSDN博客</a></p><p><a href="https://learnopengl.com/Getting-started/OpenGL">LearnOpenGL - OpenGL — 学习OpenGL- OpenGL</a></p><p><a href="https://learnopengl-cn.github.io/">主页 - LearnOpenGL CN (learnopengl-cn.github.io)</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/dbc430ed349a4411abcf3efba7409c5f.png" alt="img"></p><h5 id="以下是一些常用的OpenGL函数的清单，包括它们的用法和参数含义："><a href="#以下是一些常用的OpenGL函数的清单，包括它们的用法和参数含义：" class="headerlink" title="以下是一些常用的OpenGL函数的清单，包括它们的用法和参数含义："></a>以下是一些常用的OpenGL函数的清单，包括它们的用法和参数含义：</h5><h6 id="1-glClearColor-GLfloat-red-GLfloat-green-GLfloat-blue-GLfloat-alpha"><a href="#1-glClearColor-GLfloat-red-GLfloat-green-GLfloat-blue-GLfloat-alpha" class="headerlink" title="1. glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)"></a>1. <strong>glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)</strong></h6><ul><li>用法：设置背景清除颜色。</li><li>参数含义：<ul><li><code>red</code>：红色分量，取值范围为0.0到1.0。</li><li><code>green</code>：绿色分量，取值范围为0.0到1.0。</li><li><code>blue</code>：蓝色分量，取值范围为0.0到1.0。</li><li><code>alpha</code>：透明度分量，取值范围为0.0到1.0。</li></ul></li></ul><h6 id="2-glClear-GLbitfield-mask"><a href="#2-glClear-GLbitfield-mask" class="headerlink" title="2. glClear(GLbitfield mask)"></a>2. <strong>glClear(GLbitfield mask)</strong></h6><ul><li>用法：清除指定的缓冲区。</li><li>参数含义：<ul><li><code>mask</code>：要清除的缓冲区，可以是<code>GL_COLOR_BUFFER_BIT</code>（颜色缓冲区）、<code>GL_DEPTH_BUFFER_BIT</code>（深度缓冲区）、<code>GL_STENCIL_BUFFER_BIT</code>（模板缓冲区）的组合。</li></ul></li></ul><h6 id="3-glMatrixMode-GLenum-mode"><a href="#3-glMatrixMode-GLenum-mode" class="headerlink" title="3. glMatrixMode(GLenum mode)"></a>3. <strong>glMatrixMode(GLenum mode)</strong></h6><ul><li>用法：设置当前矩阵模式。</li><li>参数含义：<ul><li><code>mode</code>：矩阵模式，可以是<code>GL_MODELVIEW</code>（模型视图矩阵）、<code>GL_PROJECTION</code>（投影矩阵）、<code>GL_TEXTURE</code>（纹理矩阵）之一。</li></ul></li></ul><h6 id="4-glLoadIdentity"><a href="#4-glLoadIdentity" class="headerlink" title="4. glLoadIdentity()"></a>4. <strong>glLoadIdentity()</strong></h6><ul><li>用法：将当前矩阵重置为单位矩阵。</li></ul><h6 id="5-gluOrtho2D-GLdouble-left-GLdouble-right-GLdouble-bottom-GLdouble-top"><a href="#5-gluOrtho2D-GLdouble-left-GLdouble-right-GLdouble-bottom-GLdouble-top" class="headerlink" title="5. gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)"></a>5. <strong>gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)</strong></h6><ul><li>用法：设置正交投影矩阵。</li><li>参数含义：<ul><li><code>left</code>、<code>right</code>、<code>bottom</code>、<code>top</code>：视图体积的边界。</li></ul></li></ul><h6 id="6-glBegin-GLenum-mode-和-glEnd"><a href="#6-glBegin-GLenum-mode-和-glEnd" class="headerlink" title="6. glBegin(GLenum mode) 和 glEnd()"></a>6. <strong>glBegin(GLenum mode)</strong> 和 <strong>glEnd()</strong></h6><ul><li>用法：定义要绘制的图元的起始和结束。</li><li>参数含义：<ul><li><code>mode</code>：绘制的图元类型，如<code>GL_POINTS</code>（点）、<code>GL_LINES</code>（线段）、<code>GL_TRIANGLES</code>（三角形）等。</li></ul></li></ul><h6 id="7-glVertex2f-GLfloat-x-GLfloat-y"><a href="#7-glVertex2f-GLfloat-x-GLfloat-y" class="headerlink" title="7.  glVertex2f(GLfloat x, GLfloat y)"></a>7.  <strong>glVertex2f(GLfloat x, GLfloat y)</strong></h6><ul><li>用法：指定一个顶点坐标。</li><li>参数含义：<ul><li><code>x</code>、<code>y</code>：顶点的x和y坐标。</li></ul></li></ul><h6 id="8-glColor3f-GLfloat-red-GLfloat-green-GLfloat-blue"><a href="#8-glColor3f-GLfloat-red-GLfloat-green-GLfloat-blue" class="headerlink" title="8. glColor3f(GLfloat red, GLfloat green, GLfloat blue)"></a>8. <strong>glColor3f(GLfloat red, GLfloat green, GLfloat blue)</strong></h6><ul><li>用法：设置当前颜色。</li><li>参数含义：<ul><li><code>red</code>、<code>green</code>、<code>blue</code>：颜色的红、绿、蓝分量，取值范围为0.0到1.0。</li></ul></li></ul><h6 id="9-glPushMatrix-和-glPopMatrix"><a href="#9-glPushMatrix-和-glPopMatrix" class="headerlink" title="9. glPushMatrix() 和 glPopMatrix()"></a>9. <strong>glPushMatrix()</strong> 和 <strong>glPopMatrix()</strong></h6><ul><li>用法：保存和恢复当前矩阵状态。</li></ul><h6 id="10-glTranslatef-GLfloat-x-GLfloat-y-GLfloat-z"><a href="#10-glTranslatef-GLfloat-x-GLfloat-y-GLfloat-z" class="headerlink" title="10. glTranslatef(GLfloat x, GLfloat y, GLfloat z)"></a>10. <strong>glTranslatef(GLfloat x, GLfloat y, GLfloat z)</strong></h6><ul><li>用法：执行平移变换。</li><li>参数含义：<ul><li><code>x</code>、<code>y</code>、<code>z</code>：平移的距离。</li></ul></li></ul><h6 id="11-glRotatef-GLfloat-angle-GLfloat-x-GLfloat-y-GLfloat-z"><a href="#11-glRotatef-GLfloat-angle-GLfloat-x-GLfloat-y-GLfloat-z" class="headerlink" title="11. glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)"></a>11. <strong>glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)</strong></h6><ul><li>用法：执行旋转变换。</li><li>参数含义：<ul><li><code>angle</code>：旋转角度（度）。</li><li><code>x</code>、<code>y</code>、<code>z</code>：旋转轴的方向。</li></ul></li></ul><h6 id="12-glViewport-GLint-x-GLint-y-GLsizei-width-GLsizei-height"><a href="#12-glViewport-GLint-x-GLint-y-GLsizei-width-GLsizei-height" class="headerlink" title="12. glViewport(GLint x, GLint y, GLsizei width, GLsizei height)"></a>12. <strong>glViewport(GLint x, GLint y, GLsizei width, GLsizei height)</strong></h6><ul><li>用法：设置视口。</li><li>参数含义：<ul><li><code>x</code>、<code>y</code>：视口的左下角坐标。</li><li><code>width</code>、<code>height</code>：视口的宽度和高度。</li></ul></li></ul><p>这些函数是OpenGL中的一些基本函数，用于设置绘图状态、定义几何图元、执行变换和控制渲染行为。通过组合和调用这些函数，可以创建各种复杂的图形效果。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口宽度和高度</span></span><br><span class="line"><span class="type">int</span> windowWidth = <span class="number">800</span>;</span><br><span class="line"><span class="type">int</span> windowHeight = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 设置背景色为黑色</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT); <span class="comment">// 清除颜色缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制一个彩色三角形</span></span><br><span class="line">    <span class="built_in">glBegin</span>(GL_TRIANGLES);<span class="comment">//画点画线什么的都要用这里</span></span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); <span class="comment">// 设置当前绘制颜色为红色</span></span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">0.0</span>, <span class="number">0.5</span>); <span class="comment">// 第一个顶点坐标</span></span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>); <span class="comment">// 设置当前绘制颜色为绿色</span></span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">-0.5</span>, <span class="number">-0.5</span>); <span class="comment">// 第二个顶点坐标</span></span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 设置当前绘制颜色为蓝色</span></span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">0.5</span>, <span class="number">-0.5</span>); <span class="comment">// 第三个顶点坐标</span></span><br><span class="line">    <span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glFlush</span>(); <span class="comment">// 刷新缓冲区，绘制图形</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口大小变化回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reshape</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> </span>{</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height); <span class="comment">// 设置视口，充满整个窗口</span></span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_PROJECTION);</span><br><span class="line">    <span class="built_in">glLoadIdentity</span>();<span class="comment">//glLoadIdentity() 是OpenGL中的一个函数，用于将当前的矩阵重置为单位矩阵。单位矩阵是一个特殊的矩阵，对于矩阵乘法操作，它是一个“中性元素”。当你调用 glLoadIdentity() 时，它会将当前矩阵设置为单位矩阵，即没有任何变换或投影应用在对象上。</span></span><br><span class="line">    <span class="built_in">gluOrtho2D</span>(<span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>); <span class="comment">// 设置正交投影矩阵，范围为[-1, 1]在X和Y轴上</span></span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_MODELVIEW);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv); <span class="comment">// 初始化GLUT</span></span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_SINGLE | GLUT_RGBA); <span class="comment">// 设置显示模式，单缓冲区</span></span><br><span class="line">    <span class="built_in">glutInitWindowSize</span>(windowWidth, windowHeight); <span class="comment">// 设置窗口尺寸</span></span><br><span class="line">    <span class="built_in">glutCreateWindow</span>(<span class="string">"OpenGL Template"</span>); <span class="comment">// 创建窗口并设置标题</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(); <span class="comment">// 初始化OpenGL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(display); <span class="comment">// 设置渲染函数</span></span><br><span class="line">    <span class="built_in">glutReshapeFunc</span>(reshape); <span class="comment">// 设置窗口大小变化回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glutMainLoop</span>(); <span class="comment">// 进入OpenGL主循环，等待用户交互和渲染</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><a href="https://blog.csdn.net/aa941096979/article/details/50843596">OpenGL 解析glBegin()_Hi_乌龟的博客-CSDN博客</a>主要是看mode</p><p>glut参考链接[<a href="https://blog.csdn.net/qq_39377889/article/details/126946503">OpenGL笔记]glut入门（1）_glut opengl_Binarydog_Lee的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/deniece1/article/details/102642934">GLUT及其函数的用法整理_glutcreatewindow用法_deniece1的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/2303_77480410/article/details/130011521">opengl-glut(内含总结的学习资源)_glut文档_Osatnb.c的博客-CSDN博客</a></p><p>glut现在已经不是一个流行的窗口管理选择，或者说已经被弃用，但是在示例中还是经常能看见。</p><p>经过比较，感觉还是glut更方便。(⊙o⊙)…</p><p>由于不会深入研究openGL，后面统一使用glut</p><h3 id="glutSwapBuffers-与双缓冲区"><a href="#glutSwapBuffers-与双缓冲区" class="headerlink" title="glutSwapBuffers 与双缓冲区"></a><code>glutSwapBuffers</code> 与双缓冲区</h3><p><code>glutSwapBuffers</code> 是 GLUT（OpenGL Utility Toolkit）库中的一个函数，通常在使用双缓冲区（double buffering）时使用。它用于在绘制图形完成后，交换前后缓冲区的内容，以实现平滑的图形更新。下面是对 <code>glutSwapBuffers</code> 函数的中文详解：</p><ol><li><p><strong>缓冲区（Buffer）</strong>：在计算机图形中，缓冲区是内存中的特定区域，用于存储图像数据。常见的缓冲区类型包括前缓冲区（front buffer）和后缓冲区（back buffer）。</p></li><li><p><strong>双缓冲区（Double Buffering）</strong>：双缓冲区是一种图形绘制技术，它使用两个缓冲区来减少屏幕闪烁和提高图形渲染的效果。一个缓冲区用于绘制图像（后缓冲区），另一个缓冲区用于显示（前缓冲区）。这允许在后缓冲区中绘制图像，然后一次性将其显示在屏幕上，减少了用户可见的渲染过程。</p></li><li><p><strong>glutSwapBuffers 函数</strong>：<code>glutSwapBuffers</code> 是 GLUT 库提供的函数之一，它用于切换前后缓冲区，即将后缓冲区的内容复制到前缓冲区，使得用户能够看到刚刚绘制的图像。</p></li><li><p><strong>使用场景</strong>：<code>glutSwapBuffers</code> 通常在绘制完成后（例如，在 <code>display</code> 回调函数中）调用，以实现图像的平滑更新。在单缓冲区模式下，你会直接绘制在屏幕上，这可能会导致图像闪烁和不稳定。双缓冲区允许你预先绘制一个完整的图像，然后在用户看到之前交换缓冲区，以避免这些问题。</p></li><li><p><strong>使用示例</strong>：通常的用法如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glutSwapBuffers</span>();</span><br></pre></td></tr></tbody></table></figure><p>这会将后缓冲区的内容交换到前缓冲区，使绘制的图形变得可见。</p></li></ol><p>总之，<code>glutSwapBuffers</code> 函数是用于在双缓冲区中实现平滑图形更新的关键函数。通过在绘制完成后调用它，你可以确保用户看到的图形是完整和稳定的，减少了屏幕闪烁和不完整图像的问题。这在交互式图形应用程序和游戏开发中特别有用。</p><h3 id="什么时候用glutSwapBuffers，什么时候用glFlush？"><a href="#什么时候用glutSwapBuffers，什么时候用glFlush？" class="headerlink" title="什么时候用glutSwapBuffers，什么时候用glFlush？"></a>什么时候用<code>glutSwapBuffers</code>，什么时候用<code>glFlush</code>？</h3><p><code>glutSwapBuffers</code> 和 <code>glFlush</code> 都是用于刷新绘图窗口的函数，但它们的使用场景和行为略有不同。</p><ol><li><p><strong>glutSwapBuffers</strong>：</p><ul><li><strong>双缓冲区</strong>：<code>glutSwapBuffers</code> 主要用于双缓冲区渲染模式。在双缓冲区中，你绘制图像在后缓冲区中，然后使用 <code>glutSwapBuffers</code> 将后缓冲区的内容切换到前缓冲区，以使其在屏幕上可见。</li><li><strong>典型用途</strong>：通常，在使用双缓冲区时，<font color="orange">在绘制完成后，你会调用 <code>glutSwapBuffers</code> 来刷新窗口，以显示绘制的图像</font>。</li></ul></li><li><p><strong>glFlush</strong>：</p><ul><li><strong>单缓冲区</strong>：<code>glFlush</code> 适用于单缓冲区渲染模式，其中你直接绘制到前缓冲区，而不涉及后缓冲区。**<font color="green">在单缓冲区模式中，图像将立即绘制到屏幕上。</font>**</li><li><strong>典型用途</strong>：<code>glFlush</code> 通常用于单缓冲区模式，当你需要立即将图像绘制到屏幕上时，可以使用 <code>glFlush</code>。它会立即刷新图形缓冲区。</li></ul></li></ol><p><strong>选择使用哪一个函数取决于你的渲染需求</strong>：</p><ul><li>如果你使用双缓冲区，通常使用 <code>glutSwapBuffers</code> 以确保绘制的图像在用户可见之前被交换到前缓冲区。</li><li>如果你使用单缓冲区或者需要实时渲染效果，你可以使用 <code>glFlush</code> 以立即将图像绘制到屏幕上。</li></ul><p>请根据你的应用程序的渲染模式和性能要求来选择合适的函数。在许多情况下，使用双缓冲区和 <code>glutSwapBuffers</code> 会提供更流畅的图形更新，特别是对于需要避免图像闪烁的应用程序。</p><h3 id="怎么确定是单缓冲区还是双缓冲区？"><a href="#怎么确定是单缓冲区还是双缓冲区？" class="headerlink" title="怎么确定是单缓冲区还是双缓冲区？"></a>怎么确定是单缓冲区还是双缓冲区？</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glutInitDisplayMode</span>(GLUT_RGB | GLUT_SINGLE);<span class="comment">//单缓冲区</span></span><br><span class="line"><span class="built_in">glutInitDisplayMode</span>(GLUT_RGB | GLUT_DOUBLE);<span class="comment">//双缓冲区</span></span><br><span class="line"><span class="comment">//这个通常写在main函数里面</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> VS2022 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/27/hello-world/"/>
      <url>/2023/09/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
