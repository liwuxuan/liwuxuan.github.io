<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法导论第22章和第23章答案</title>
      <link href="/2023/11/01/suan-fa-dao-lun-di-22-zhang-he-di-23-zhang-da-an/"/>
      <url>/2023/11/01/suan-fa-dao-lun-di-22-zhang-he-di-23-zhang-da-an/</url>
      
        <content type="html"><![CDATA[<blockquote><p>深度优先森林将图的边分为树边、向后边、向前边和交叉边。宽度优先树还可以用于将从搜索源可到达的边分类为相同的四个类别。</p><p>**A.**证明在无向图的广度优先搜索中，以下性质成立：</p><ol><li>没有后边缘也没有前边缘。</li><li>对于每个树边$(u, v)$，我们有$v.d = u.d + 1$。</li><li>对于每个交叉边$(u, v)$，我们有$v.d = u.d$或$v.d = u.d + 1$。</li></ol><p><strong>乙。</strong>证明在有向图的广度优先搜索中，以下性质成立：</p><ol><li>没有向前的边。</li><li>对于每个树边$(u, v)$，我们有$v.d = u.d + 1$。</li><li>对于每个交叉边缘$(u, v)$，我们有$v.d \le u.d + 1$。</li><li>对于每个后沿$(u, v)$，我们有$0 \le v.d \le u.d$。</li></ol></blockquote><p><strong>A.</strong></p><ol><li><p>如果我们找到一条后边，这意味着有两个顶点，一个是另一个的后代，但已经有一条从祖先到子代的路径，这条路径不涉及在树中向上移动。这是一个矛盾，因为 BFS 树中唯一的子节点是那些只有一条边的子节点，这意味着不可能有任何其他路径到达该子节点，因为这将使其超过一条边。为了看到没有前沿，我们做了一个类似的过程。向前的边意味着从一个给定的顶点，我们注意到它有一个已经被处理过的子节点，但这不可能发生，因为所有的子节点都只有一条边的距离，并且对于已经被处理过的顶点，它需要先经过其他一些顶点。</p></li><li><p>如果边到达尚未考虑的顶点，则将其放置在要处理的列表上。这意味着从该顶点到根的路径必须至少等于到当前顶点的距离加上$1$。最多也是这样，因为我们可以只取一条路径，这条路径包括到当前顶点并取其到根的路径。</p></li><li><p>我们知道，交叉边不能深入到小于 1 的深度，否则在处理前面的元素时，它将被用作树边。它也不能去一个深度超过一个的顶点，因为我们不会已经处理了一个离根很远的顶点。由于交叉边中顶点的深度不能超过一个，因此可以通过交换和$v$的$u$角色来得出结论，我们可以这样做，因为边是无序的。</p></li></ol><p><strong>乙。</strong></p><ol><li><p>要获得前向边，我们需要已经使用多条边处理了一个顶点，即使存在使用一条边到达该顶点的路径。由于广度优先搜索总是首先考虑较短的路径，因此这是不可能的。</p></li><li><p>假设这$(u, v)$是一条树边。那么，这意味着存在一条长度$u.d + 1$为的从根到$v$的路径，只需将其附加$(u, v)$到从根到$u$的路径即可。为了看到没有更短的路径，我们只是注意到我们会更快地处理$v$，所以如果有的话，目前不会有树边。</p></li><li><p>要看到这一点，我们所需要做的就是注意到有一些从根到$v$的路径，其长度$u.d + 1$是通过附加$(u, v)$到$v.d$而获得的。由于存在该长度的路径，因此它用作从根到$v$的所有此类路径的最小长度的上限。</p></li><li><p>这是微不足道的$0 \le v.d$，因为不可能有一条从根到$v$负长度的路径。更有趣的不平等是$v.d \le u.d$。我们知道有一条从$v$到$u$的路径，由树的边组成，这是后沿的$(u, v)$定义属性。这意味着它$v, v_1, v_2, \dots, v_k, u$是这条路径（它是唯一的，因为树边形成了一棵树）。那么，我们有那个$u.d = v_k.d + 1 = v_{k − 1}.d + 2 = \cdots = v_1.d + k = v.d + k + 1$。所以，我们有那个$u.d &gt; v.d$。事实上，我们刚刚展示了我们有更有力的结论，那就是$0 \le v.d &lt; u.d$。</p></li></ol><blockquote><p>设$G = (V, E)$是一个连通的无向图。OF**<em>关节点</em><strong>$G$是其移除断开$G$的顶点。</strong><em>桥</em><strong>的$G$是其移除断开$G$的边。A</strong><em>双连接组件</em>**OF$G$是一个极大边集，使得集合中的任意两条边都位于一个公共的简单圈上。图 22.10 说明了这些定义。我们可以使用深度优先搜索来确定关节点、桥和双连接组件。设$G_\pi = (V, E_\pi)$是的$G$深度优先树。</p><p>**A.**证明的根$G_\pi$是的$G$关节点当且仅当它在中$G_\pi$至少有两个子根。</p><p><strong>乙。</strong>设$v$是的$G_\pi$非根顶点。证明$v$是的关节点$G$，当且仅当$v$有一个子节点$s$，使得没有从$s$的后沿或到的$v$正确祖先的$s$任何后代。</p><p>**C.**让。</p><p>$$<br>v.low = \min<br>\begin{cases}<br>v.d, \\<br>w.d:(u,w) \text{ is a back edge for some descendant } u \text{ of } v.<br>\end{cases}<br>$$</p><p>演示如何及时计算$v.low$所有顶点$v \in V$$O(E)$。</p><p>**D.**演示如何及时计算所有关节点$O(E)$。</p><p>**E.**证明的$G$边是桥当且仅当它不位于的$G$任何简单圈上。</p><p>**F.**展示如何计算时间的$G$$O(E)$所有桥梁。</p><p>**G.**证明的双连通分支$G$划分的$G$非桥边。</p><p>**H.**给出一个$O(E)$时间算法，用一个正整数$e.bcc$标记的$G$每条边$e$，使得$e.bcc = e’.bcc$当且仅当$e$和$e’$在同一个双连通分量中。</p></blockquote><p>**A.**首先假设的$G_\pi$根$r$是一个关节点。则从中$G$删除$r$将导致图形断开连接，因此$r$中$G$至少$2$有个子项。如果$r$中$G_\pi$只有一个子元素$v$，则必须有一条$v$到其他每个子元素的$r$路径。由于删除$r$断开了图，因此必须存在顶点$u$和$w$，以便从$u$到$w$的唯一路径包含$r$。</p><p>若要从$u$到达$r$，路径必须首先到达的$r$一个子项。此子项通过不包含$r$的路径连接到$v$。</p><p>要到达$w$，路径还必须通过它的一个子级离开$r$，该子级也可以通过$v$到达。这意味着有一条$u$$w$不包含$r$矛盾的路径。</p><p>现在假设$r$至少有两个孩子$u$，并且$v$在$G_\pi$。则不存在不经过$r$的从$u$到$v$$G$的路径，否则$u$将是的$v$祖先。因此，移除$r$断开了组件包含$u$和组件包含$v$，因此$r$是一个关节点。</p><p><strong>乙。</strong>假设$v$是的$G_\pi$非根顶点，并且$v$有一个子顶点$s$，使得的后代都$s$$s$没有到的正确祖先$v$的后边。设$r$为的$v$祖先，并从$G$其移除$v$。由于我们是在无向的情况下，图中唯一的边是树边或后边，这意味着与$s$关联的每条边都会将我们带到的$s$后代，并且没有后代具有后边，因此在任何时候我们都不能通过取边来向上移动树。因此$r$是不可到达的$s$，所以图形是断开的，并且$v$是一个关节点。</p><p>现在假设，对于的$v$每个子代，都存在该子代的一个后代，该后代具有到的正确祖先$v$的后沿。从.中删除$v$$G$。的$v$每个子树都是连通分支。在一个给定的子树中，找到一个顶点，该顶点有一条到的正确祖先$v$的后边。因为不是的$v$后代的顶点的集合$T$形成了一个连通分量，所以的每个子树$v$都是连通$T$的。因此，在删除 So$v$后，图形仍保持连接，$v$不是关节点。</p><p>**C.**由于$v$在其所有后代之前被发现，因此唯一可能影响$v.low$的后边缘是从的$v$后代到的正确祖先$v$的后边缘。如果我们知道$u.low$的$v$每个孩子$u$，那么我们就可以很容易地计算$v.low$，因为所有的信息都被编码在它的后代中。</p><p>因此，我们可以递归地写出算法：如果$v$是中的$G_\pi$叶子，则$v.low$是的最小值，$v.d$$w.d$其中$(v, w)$是后沿。如果$v$不是叶，$v$则是的最小值$v.d$，$w.d$其中$(v, w)$是后边缘，并且$u.low$，其中$u$是的$v$子级。计算$v.low$顶点的次数是线性的。顶点度数之和是边数的两倍，因此总运行时间为$O(E)$。</p><p>**D.**首先应用部分（C）$O(E)$的算法来计算$v.low$所有$v \in V$。如果$v.low$=$v.d$当且仅当的$v$后代都不具有的正确祖先$v$的后边缘时，当且仅当$v$不是关节点时。</p><p>因此，我们只需要检查$v.low$与$v.d$在恒定时间内决定是否$v$是一个关节点，所以运行时是$O(E)$。</p><p>**E.**一条边$(u, v)$位于一个简单圈上，当且仅当至少存在一条从$u$到$v$的路径不包含该边$(u, v)$，当且仅当移除$(u, v)$不会断开图，当且只当$(u, v)$不是桥。</p><p>**F.**一条边$(u, v)$位于无向图中的一个简单圈上，当且仅当它的两个端点都是关节点，或者它的一个端点是关节点，另一个端点是度$1$顶点。还有一种特殊情况，即只有一条边的关联顶点都是度$1$。我们可以在恒定时间内检查这种情况。由于我们可以计算中的$O(E)$所有关节点，并且我们可以在常数时间内确定顶点是否具有度数$1$，因此我们可以运行部分（d）中的算法，然后在常数时间内确定每条边是否是桥，这样我们就可以及时找到所有的$O(E)$桥。</p><p>**G.**很明显，每个非桥边都在某个双连通分量中，因此我们需要证明如果$C_1$和$C_2$是不同的双连通分量，则它们不包含公共边。相反，假设$(u, v)$在$C_1$和$C_2$中都有。</p><p>设$(a, b)$为中的$C_1$任意边，且$(c, d)$为中的$C_2$任意边。</p><p>然后$(a, b)$位于一个简单的循环$(u, v)$上，由路径组成</p><p>$$a, b, p_1, \ldots, p_k, u, v, p_{k + 1}, \ldots, p_n, a.$$</p><p>Similarly, $(c, d)$ lies on a simple cycle with $(u, v)$ consisting of the path</p><p>$$C，d，Q_1，\ldots，Q_m，u，V，Q_{m+1}，\ldots，Q_l，C.$$</p><p>这意味着</p><p>$$a, b, p_1, \ldots, p_k, u, q_m, \ldots, q_1, d, c, q_l , \ldots, q_{m + 1}, v, p_{k + 1}, \ldots, p_n,$$</p><p>是一个包含$(a, b)$和$(c, d)$的简单循环，是一个矛盾。因此，双连接组件形成了一个分区。</p><p>使用部分（f）中描述的算法及时**H.**定位所有桥边缘$O(E)$。从中$E$删除每个网桥。双连通组件现在只是连通组件中的边。假设已经这样做了，运行下面的算法，该算法显然在中$O(|E|)$运行，其中$|E|$是最初在中$G$的边数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VISIT-<span class="built_in">BCC</span>(G, u, k)</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">for</span> each v ∈ G.Adj[u]</span><br><span class="line">        (u, v).bcc = k</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            VISIT-<span class="built_in">BCC</span>(G, v, k)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>强连通有向图$G = (V, E)$**<em>欧拉之旅</em>**中的圈是恰好遍历每个边一次的$G$圈，尽管它可能不止一次访问一个顶点。</p><p>当且仅当$\text{in-degree}(v) = \text{out-degree}(v)$对于每个顶点$v \in V$，**A.**显示$G$具有 Euler 环游。</p><p><strong>乙。</strong>描述一个$O(E)$时间算法来查找 Euler 路径$G$（如果存在）。（$\textit{提示：}$merge edge-disjoint cycles.）</p></blockquote><p>**A.**首先，我们将证明每个顶点的入度必须等于出度。假设有一个顶点 V，这两个顶点不相等，假设$\text{in-degree}(v) - \text{out-degree}(v)$。请注意，我们可以假设 In 度更大，否则我们只需查看向后遍历循环的转置图。如果$v$是列出的循环的开始，只需将开始和结束顶点移动到循环上的任何其他顶点。然后，在我们进行$v$的任何循环中，我们必须通过$v$一定的次数，特别是，在我们通过一次之后，未使用的边的数量$v$为零，然而，仍然有未使用的边需要使用。这意味着没有希望使用这些，而仍然是一个旅游，因为我们将永远无法逃脱$v$，并回到旅游开始的顶点。现在，我们证明了每个顶点的入度和出度相等就足够了。为了做到这一点，我们将把问题稍微一般化，以便它更适合于归纳方法。也就是说，我们将证明，对于每个有两个顶点$v$的图$G$，并且$u$所有顶点都有相同的入度和出度，除了入度比出度大$u$一，$v$那么就有一条从$v$到$u$的欧拉路径。如果我们选择$u = v$图中的任何顶点，这显然与原始语句一致。我们现在对边的数量进行归纳。如果只有一条边，那么只取这条边就是欧拉之旅。然后，假设我们从$v$它开始，并取它的任何边。考虑通过移除该边而获得的图，它归纳地包含一个欧拉路径，我们可以将其后挂到我们要离开$v$的边。</p><p><strong>乙。</strong>为了真正得到欧拉回路，我们可以任意走任何我们想走的路，只要我们不重复一条边，我们就一定会得到一个有效的欧拉回路。这是在下面的算法中实现的，$\text{EULER-TOUR}(G)$这需要时间$O(|E|)$。它之所以有这样的运行时间，是因为 for 循环将为每条边运行，并且需要恒定的时间量。此外，初始化每个边的颜色的过程将花费与边的数量成比例的时间。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EULER-<span class="built_in">TOUR</span>(G)</span><br><span class="line">    <span class="function">color all edges WHITE</span></span><br><span class="line"><span class="function">    <span class="title">let</span> <span class="params">(v, u)</span> be any edge</span></span><br><span class="line"><span class="function">    let L be a list containing v</span></span><br><span class="line"><span class="function">    <span class="keyword">while</span> there is some WHITE <span class="title">edge</span> <span class="params">(v, w)</span> coming out of v</span></span><br><span class="line"><span class="function">        <span class="title">color</span> <span class="params">(v, w)</span> BLACK</span></span><br><span class="line"><span class="function">        v </span>= w</span><br><span class="line">        append v to L</span><br></pre></td></tr></tbody></table></figure><blockquote><p>设$G = (V, E)$是一个有向图，其中每个顶点$u \in V$都标有集合$\{1, 2, \ldots, |V|\}$中的唯一整数$L(U)$。对于每个顶点$u \in V$，设$R(u) = \{v \in V: u \leadsto v \}$为可到达$u$的顶点的集合。定义$\min(u)$为标签最小的顶点$R(u)$，即，$\min(u)$是满足以下条件$L(v) = \min \{L(w): w \in R(u) \}$的顶点$v$。给出$O(V + E)$计算$\min(u)$所有顶点$u \in V$的时间算法。</p></blockquote><p>**1.**计算分量图$G^{\text{SCC}}$（以便从图$G$中删除简单圈），并用其中$G^{\text{SCC}}$顶点的最小标签标记中的$G^{\text{SCC}}$每个顶点。根据第 22.5 章，该过程的时间复杂度为$O(V + E)$。</p><p>**2.**在上$G^{\text{SCC}}$，执行以下算法。请注意，如果我们记住这个函数，它将在大多数$V + E$情况下被调用。其时间复杂度也$O(V + E)$是。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">REACHABILITY</span>(u)</span><br><span class="line">    u.min = u.label</span><br><span class="line">    <span class="keyword">for</span> each v ∈ Adj[u]</span><br><span class="line">        u.min = <span class="built_in">min</span>(u.min, <span class="built_in">REACHABILITY</span>(v))</span><br><span class="line">    <span class="keyword">return</span> u.min</span><br></pre></td></tr></tbody></table></figure><p>**3.**回到 Graph$G$，On Graph$G$的$\min(u)$值是 On Graph$G^{\text{SCC}}$的$\min(u.scc)$值。</p><p><strong>替代解决方案：</strong>转置图形。调用$\text{DFS}$，但在的$\text{DFS}$主循环中，按顶点的标签顺序考虑顶点。$\text{DFS-VISIT}$在子例程中，在发现新节点时，我们将其$\text{min}$设置为其根的标签。</p><h2 id="22-1-1"><a href="#22-1-1" class="headerlink" title="22.1-1"></a>22.1-1</h2><blockquote><p>给定一个有向图的邻接表表示，计算每个顶点的$\text{out-degree}$需要多长时间？计算$\text{in-degree}$S 需要多长时间？</p></blockquote><ul><li><p>计算每个顶点的$\text{out-degree}$时间为</p><p>  $$\sum_{v \in V}O(\text{out-degree}(v)) = O(|E| + |V|),$$</p><p>  这很显然</p></li><li><p>至于$\text{in-degree}$,我们必须扫描所有邻接表，并记录每个顶点被指向的次数。因此，时间复杂度也是 $O(|E|+|V|)$，因为我们要访问所有节点和边。</p></li></ul><h2 id="22-1-2"><a href="#22-1-2" class="headerlink" title="22.1-2"></a>22.1-2</h2><blockquote><p>给出一棵顶点为 $7$ 的完整二叉树的邻接表。给出等价的邻接矩阵表示法。假设顶点的编号从$1$到$7$，就像二叉堆一样。</p></blockquote><ul><li><p><strong>Adjacency-list representation</strong></p><p>  $$<br>  \begin{aligned}<br>  1 &amp; \to 2 \to 3 \\<br>  2 &amp; \to 1 \to 4 \to 5 \\<br>  3 &amp; \to 1 \to 6 \to 7 \\<br>  4 &amp; \to 2 \\<br>  5 &amp; \to 2 \\<br>  6 &amp; \to 3 \\<br>  7 &amp; \to 3<br>  \end{aligned}<br>  $$</p></li><li><p><strong>Adjacency-matrix representation</strong></p><p>  $$<br>  \begin{array}{c|ccccccc|}<br>&amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 \\<br>  \hline<br>  1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  2 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\<br>  3 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\<br>  4 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  5 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  6 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  7 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  \hline<br>  \end{array}<br>  $$</p></li></ul><h2 id="22-1-3"><a href="#22-1-3" class="headerlink" title="22.1-3"></a>22.1-3</h2><blockquote><p>有向图$G = (V, E)$的**<em>转置</em>**是图$G^\text T = (V, E^\text T)$，其中$E^\text T = \{(v, u) \in V \times V: (u, v) \in E \}$。因此，$G^\text T$它$G$的所有边都颠倒了。描述从$G$计算$G^\text T$的有效算法，用于的$G$邻接表和邻接矩阵表示。分析算法的运行时间。</p></blockquote><ul><li><p><strong>邻接表表示</strong></p><p>  假设原始邻接表为$Adj$。</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let Adj<span class="number">'</span>[<span class="number">1.</span>.|V|] be a <span class="keyword">new</span> adjacency list of the transposed G^T</span><br><span class="line"><span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ Adj[u]</span><br><span class="line">        <span class="built_in">INSERT</span>(Adj<span class="number">'</span>[v], u)</span><br></pre></td></tr></tbody></table></figure><p>  时间复杂度：$O(|E| + |V|)$。</p></li><li><p><strong>邻接矩阵表示</strong></p><p>  通过查看对角线上方的每个条目，并将其与对角线下方出现的条目交换，来转置原始矩阵。</p><p>  时间复杂度：$O(|V|^2)$。</p></li></ul><h2 id="22-1-4"><a href="#22-1-4" class="headerlink" title="22.1-4"></a>22.1-4</h2><blockquote><p>给定多重图$G = (V, E)$的邻接表表示，描述$O(V + E)$计算“等价”无向图的邻接表表示的时间算法$G’ = (V, E’)$，其中$E’$由两个顶点之间的所有多条边替换为一条边并删除所有自环的边$E$组成。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EQUIVALENT-UNDIRECTED-GRAPH</span><br><span class="line">    let Adj<span class="number">'</span>[<span class="number">1.</span>.|V|] be a <span class="keyword">new</span> adjacency list</span><br><span class="line">    let A be a <span class="number">0</span>-initialized array of size |V|</span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        <span class="keyword">for</span> each v ∈ Adj[u]</span><br><span class="line">            <span class="keyword">if</span> v != u &amp;&amp; A[v] != u</span><br><span class="line">                A[v] = u</span><br><span class="line">                <span class="built_in">INSERT</span>(Adj<span class="number">'</span>[u], v)</span><br></pre></td></tr></tbody></table></figure><p>请注意$A$，在内部 for 循环的每次迭代之前，不包含任何具有值$u$的元素。这就是为什么我们使用$A[v] = u$在内部 for 循环中标记边$(u, v)$的存在。因为我们在邻接表$Adj$$|V| + |E|$中查找时间，所以时间复杂度是$O(|V| + |E|)$。</p><h2 id="22-1-5"><a href="#22-1-5" class="headerlink" title="22.1-5"></a>22.1-5</h2><blockquote><p>有向图$G = (V, E)$的**<em>正方形</em>**是使得$(u, v) \in E^2$当且仅当$G$包含一条在和$v$之间最多有两条边$u$的路的图$G^2 = (V, E^2)$。描述计算$G^2$$G$的邻接表和邻接矩阵表示的$G$有效算法。分析算法的运行时间。</p></blockquote><ul><li><p><strong>邻接表表示</strong></p><p>  为了从的$G$邻接表表示$Adj$进行计算$G^2$，我们对每个$Adj[u]$执行以下操作：</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each v ∈ Adj[u]</span><br><span class="line">    <span class="built_in">INSERT</span>(Adj2[u], v)</span><br><span class="line">    <span class="keyword">for</span> each w ∈ Adj[v]</span><br><span class="line">        <span class="comment">// edge(u, w) ∈ E^2</span></span><br><span class="line">        <span class="built_in">INSERT</span>(Adj2[u], w)</span><br></pre></td></tr></tbody></table></figure><p>  其中$Adj2$是的$G^2$邻接表表示。对于我们扫描的最多$|V|$顶点中的$Adj$每条边，我们及时$O(|V||E|)$计算$Adj2$。</p><p>  在我们计算$Adj2$之后，我们必须从列表中删除重复的边。删除重复的边是在中完成$O(V + E’)$的，其中$E’ = O(VE)$是中$Adj2$的边数，如练习 22.1-4 所示。因此，总运行时间为</p><p>  $$O（VE）+O（V+VE）=O（VE）。$$</p><p>  但是，如果原始图$G$包含自环，我们应该修改算法，以便不删除自环。</p></li><li><p><strong>邻接矩阵表示</strong></p><p>  设$A$表示的$G$邻接矩阵表示。的邻接矩阵表示$G^2$是的$A$平方。计算$A^2$可以及时$O(V^3)$完成（理论上甚至更快；例如，Strassen 的算法将在中$O(V^{\lg 7})$计算$A^2$。</p></li></ul><h2 id="22-1-6"><a href="#22-1-6" class="headerlink" title="22.1-6"></a>22.1-6</h2><blockquote><p>大多数将邻接矩阵表示作为输入的图算法都需要时间$\Omega(V^2)$，但也有一些例外。展示如何确定一个有向图$G$是否包含**<em>通用水槽</em>**$-$一个在时间上$O(V)$具有$\text{in-degree}$$|V| - 1$和$\text{out-degree}$$0$$-$的顶点，给定一个邻接矩阵$G$。</p></blockquote><p>从检查邻接矩阵中的位置$(1, 1)$开始。当检查位置$(i, j)$时，</p><ul><li>如果遇到 A$1$，则检查位置$(i + 1, j)$，并</li><li>如果$0$遇到，请检查位置$(i, j + 1)$。</li></ul><p>一旦或$i$$j$等于$|V|$，则终止。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IS-CONTAIN-UNIVERSAL-<span class="built_in">SINK</span>(M)</span><br><span class="line">    i = j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; |V| <span class="keyword">and</span> j &lt; |V|</span><br><span class="line">        <span class="comment">// There's an out-going edge, so examine the next row</span></span><br><span class="line">        <span class="keyword">if</span> M[i, j] == <span class="number">1</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="comment">// There's no out-going edge, so see if we could reach the last column of current row</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> M[i, j] == <span class="number">0</span></span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">    check <span class="keyword">if</span> vertex i is a universal sink</span><br></pre></td></tr></tbody></table></figure><p>如果一个图包含一个通用汇点，那么它一定在顶点$i$。</p><p>为了看到这一点，假设顶点$k$是一个通用汇点。因为$k$是一个通用接收器，所以行$k$将用$0$“S ”填充，列$k$将用$1$“S ”填充，除了用“A$0$”填充的$M[k, k]$。最后，一旦行$k$被命中，算法将继续增加列$j$，直到$j = |V|$。</p><p>为了确保最终命中行$k$，请注意，一旦到达列$k$，算法将继续递增$i$，直到到达为止$k$。</p><p>该算法在中$O(V)$运行，并在中$O(V)$检查顶点$i$是否为通用接收器。因此，总运行时间为$O(V) + O(V) = O(V)$。</p><h2 id="22-1-7"><a href="#22-1-7" class="headerlink" title="22.1-7"></a>22.1-7</h2><blockquote><p>没有自环的有向图$G = (V, E)$的**<em>关联矩阵</em>**是一个$|V| \times |E|$矩阵$B = (b_{ij})$，使得</p><p>$$<br>b_{ij} =<br>\begin{cases}<br>-1 &amp; \text{if edge $j$ leaves vertex $i$}, \\<br> 1 &amp; \text{if edge $j$ enters vertex $i$}, \\<br> 0 &amp; \text{otherwise}.<br>\end{cases}<br>$$</p><p>描述矩阵乘积$BB^\text T$的元素表示什么，其中$B^\text T$是的$B$转置。</p></blockquote><p>$$BB^\text T(i, j) = \sum\limits_{e \in E}b_{ie} b_{ej}^\text T = \sum\limits_{e \in E} b_{ie}b_{je}.$$</p><ul><li>If $i = j$, then $b_{ie} b_{je} = 1$ (it is $1 \cdot 1$ or $(-1) \cdot (-1)$) whenever $e$ enters or leaves vertex $i$, and $0$ otherwise.</li><li>If $i \ne j$, then $b_{ie} b_{je} = -1$ when $e = (i, j)$ or $e = (j, i)$, and $0$ otherwise.</li></ul><p>Thus,</p><p>$$<br>BB^\text{T}(i, j) =<br>\begin{cases}<br>\text{degree of } i = \text{in-degree} + \text{out-degree} &amp; \text{if } i = j, \\<br>-\text{(number of edges connecting } i \text{ and } j) &amp; \text{if } i \ne j.<br>\end{cases}<br>$$</p><h2 id="22-1-8"><a href="#22-1-8" class="headerlink" title="22.1-8"></a>22.1-8</h2><blockquote><p>假设每个数组条目$Adj[u]$不是链表，而是包含顶点$v$的哈希表$(u, v) \in E$。如果所有边查找的可能性相等，则确定边是否在图中的预期时间是多少？这个方案有什么缺点？为解决这些问题的每个边列表建议一个替代数据结构。与哈希表相比，你的替代方案是否有缺点？</p></blockquote><p>预期的查找时间为$O(1)$，但在最坏的情况下可能需要$O(|V|)$。</p><p>如果我们首先对每个邻接表中的顶点进行排序，则我们可以执行二分搜索，以便最坏情况的查找时间为$O(\lg |V|)$，但这具有更差的预期查找时间的缺点。</p><h2 id="22-2-1"><a href="#22-2-1" class="headerlink" title="22.2-1"></a>22.2-1</h2><blockquote><p>使用顶点$3$作为源，显示在图 22.2（a）的有向图上运行宽度优先搜索得到的$d$和$\pi$值。</p></blockquote><p>$$<br>\begin{array}{c|cccccc}<br>\text{vertex} &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\<br>\hline<br>d &amp; \infty &amp; 3 &amp; 0 &amp; 2 &amp; 1 &amp; 1 \\<br>\pi &amp; \text{NIL} &amp; 4 &amp; \text{NIL} &amp; 5 &amp; 3 &amp; 3<br>\end{array}<br>$$</p><h2 id="22-2-2"><a href="#22-2-2" class="headerlink" title="22.2-2"></a>22.2-2</h2><blockquote><p>使用顶点$u$作为源，显示在图 22.3 的无向图上运行宽度优先搜索得到的$d$和$\pi$值。</p></blockquote><p>$$<br>\begin{array}{c|cccccc}<br>\text{vertex} &amp; r &amp; s &amp; t &amp; u &amp; v &amp; w &amp; x &amp; y \\<br>\hline<br>d &amp; 4 &amp; 3 &amp; 1 &amp; 0 &amp; 5 &amp; 2 &amp; 1 &amp; 1 \\<br>\pi &amp; s &amp; w &amp; u &amp; \text{NIL} &amp; r &amp; t &amp; u &amp; u<br>\end{array}<br>$$</p><h2 id="22-2-3"><a href="#22-2-3" class="headerlink" title="22.2-3"></a>22.2-3</h2><blockquote><p>通过论证如果删除第 5 行和第 14 行，该$\text{BFS}$过程将产生相同的结果，表明使用单个位来存储每个顶点颜色就足够了。</p></blockquote><p>出于教学目的，教科书引入了$\text{GRAY}$颜色，以区分$\text{GRAY}$节点（入队）和$\text{BLACK}$节点（出队）。</p><p>因此，使用单个位来存储每个顶点颜色就足够了。</p><h2 id="22-2-4"><a href="#22-2-4" class="headerlink" title="22.2-4"></a>22.2-4</h2><blockquote><p>如果我们用邻接矩阵来表示它的输入图，并修改算法来处理这种形式的输入，那么它的运行时间$\text{BFS}$是多少？</p></blockquote><p>迭代所有边的时间变为$O(V^2)$$O(E)$。因此，运行时间为$O(V + V^2) = O(V^2)$。</p><h2 id="22-2-5"><a href="#22-2-5" class="headerlink" title="22.2-5"></a>22.2-5</h2><blockquote><p>论证在广度优先搜索中，分配给顶点$u$的值$u.d$与顶点在每个邻接表中出现的顺序无关。以图 22.3 为例，说明由$\text{BFS}$计算的宽度优先树可以依赖于邻接表中的排序。</p></blockquote><p>首先，我们将展示分配给顶点的值$d$与条目在邻接表中出现的顺序无关。为了证明这一点，我们依赖于定理 22.5，它证明了的$\text{BFS}$正确性。特别地，该定理指出，$v.d = \delta(s, v)$在的$\text{BFS}$终止处。因为$\delta(s, v)$是基础图的属性，所以对于图的任何邻接表表示（包括邻接表的任何重新排序），$\delta(s, v)$都不会改变。由于这些$d$值对于邻接表的任何排序都是相等$\delta(s, v)$的并且$\delta(s, v)$是不变的，$d$因此也不依赖于邻接表的排序。</p><p>现在，为了说明这$\pi$确实依赖于邻接表的排序，我们将使用图 22.3 作为指导。</p><p>首先，我们注意到，在给定的计算过程中，我们在邻接表$w$中有，$t$在前面$x$。此外，在制定的程序中，我们有$u.\pi = t$。</p><p>现在，假设我们在的$w$邻接表中有$x$前导$t$。然后，它将被添加到队列之前$t$，这意味着在我们有机会处理的子代$t$之前，它将$u$作为它的子代。这将意味着$u.\pi = x$在邻接表$w$的这种不同排序中。</p><h2 id="22-2-6"><a href="#22-2-6" class="headerlink" title="22.2-6"></a>22.2-6</h2><blockquote><p>给出一个有向图$G = (V, E)$的例子，一个源顶点$s \in V$和一组树边$E_\pi \subseteq E$，使得对于每个顶点$v \in V$，图$(V, E_\pi)$中从$s$到$v$的唯一简单路径是中$G$的最短路径，但无论顶点在每个邻接表中如何排序，都不能通过运行$\text{BFS}$$G$产生边$E_\pi$的集合。</p></blockquote><p>设$G$为第一幅图中所示的图形，$G_\pi = (V, E_\pi)$为第二幅图中所示的图形，$s$为源顶点。</p><p>我们可以看到，$E_\pi$在上$G$运行 BFS 将永远不会产生。</p><center>![](../img/22.2-6-2.png) ![](../img/22.2-6-1.png)</center><ul><li>如果$y$在中$Adj[s]$位于前面$v$。我们将在之前$v$离开队列$y$，所以$u.\pi$和$x.\pi$都$y$是。然而，事实并非如此。</li><li>如果$v$在$Adj[s]$前面$y$。我们将在之前$y$出队$v$，所以$u.\pi$和$x.\pi$都$v$是，这也是不正确的。</li></ul><p>尽管如此，中$G_\pi$从$s$到任何顶点的唯一简单路径是中的$G$最短路径。</p><h2 id="22-2-7"><a href="#22-2-7" class="headerlink" title="22.2-7"></a>22.2-7</h2><blockquote><p>职业摔跤手有两种类型：“娃娃脸”（“好人”）和“高跟鞋”（“坏人”）。在任何一对职业摔跤手之间，可能有也可能没有竞争。假设我们有$n$职业摔跤手，我们有一$r$组有竞争关系的摔跤手。给出一个$O(n + r)$时间算法，该算法确定是否可以将一些摔跤手指定为娃娃脸，而将其余的摔跤手指定为脚跟，以便每次比赛都是在娃娃脸和脚跟之间进行。如果有可能执行这样的指定，你的算法应该产生它。</p></blockquote><p>这个问题基本上只是两种颜色的混淆版本。我们将尝试用“娃娃脸”和“脚跟”这两种颜色来给这张竞争图的顶点着色。没有两个娃娃脸和两个高跟鞋有竞争，就等于说颜色是合适的。对于两种颜色，我们对每个连通分量执行广度优先搜索，以获得每个顶点的$d$值。然后，我们给所有的奇数一个颜色说“脚跟”，所有的偶数 d 值一个不同的颜色。我们知道，在这个着色失败的地方，没有其他着色会成功，因为如果我们给出任何其他着色，我们会得到一个顶点$v$具有相同的颜色，$v.\pi$$v$并且$v.\pi$它们的$d$值必须具有不同的奇偶性。因为我们知道没有更好的着色，所以我们只需要检查每条边，看看这种着色是否有效。如果每条边都能正常工作，则可以找到一个指定，如果单个边失败，则不可能找到指定。由于 BFS$O(n + r)$和检查都需要$O(r)$时间，因此总运行时间为$O(n + r)$。</p><h2 id="22-2-8-star"><a href="#22-2-8-star" class="headerlink" title="22.2-8$\star$"></a>22.2-8$\star$</h2><blockquote><p>树$T = (V, E)$的**<em>直径</em>**定义为$\max_{u,v \in V} \delta(u, v)$，即，树中所有最短路径距离中的最大值。给出一个计算树直径的有效算法，并分析该算法的运行时间。</p></blockquote><p>假设 A 和 B 是树中达到直径的路径的端点，并且不失一般性地假设$a$和$b$是达到直径的唯一对。设$s$为中的$T$任意顶点。我们声称，一个单一$\text{BFS}$的结果将返回一个$a$或$b$（或两者）作为距离$s$最大的顶点。</p><p>为了看到这一点，假设与此相反，另一个顶点$x$显示为最远$s$。（请注意，$x$不能在从$a$到$b$的路径上，否则我们可以扩展）。那我们有</p><p>$$d(s, a) &lt; d(s, x)$$</p><p>and</p><p>$$d（s，B） &lt;d（s，X）。$$</p><p>让$c$表示从$a$到$b$最小化$d(s, c)$的路径上的顶点。既然图实际上是一棵树，我们必须有</p><p>$$d(s, a) = d(s, c) + d(c, a)$$</p><p>and</p><p>$$D（S，B）=D（S，C）+D（C，B）。$$</p><p>（如果有另一条路，我们可以形成一个循环）。利用上面提到的三角不等式、不等式和等式，我们必须</p><p>$$<br>\begin{aligned}<br>d(a, b) + 2d(s, c) &amp; = d(s, c) + d(c, b) + d(s, c) + d(c, a) \\<br>                   &amp; &lt; d(s, x) + d(s, c) + d(c, b).<br>\end{aligned}<br>$$</p><p>我声称$d(x, b) = d(s, x) + d(s, b)$。如果不是，那么根据三角不等式，我们必须有一个严格的小于。换句话说，有一些从$x$到$b$的路径没有经过$c$。这给出了矛盾，因为它意味着存在通过连接这些路径而形成的循环。那我们有</p><p>$$d（a，B） &lt;d（a，B）+2D（s，C） &lt;d（X，B）。$$</p><p>因为假设$d(a, b)$在所有对中是最大的，所以我们有一个矛盾。因此，由于树有$|V| - 1$边，我们可以运行$\text{BFS}$一次$O(V)$来获得其中一个顶点，该顶点是图中包含的最长简单路径的端点。再次运行$\text{BFS}$将告诉我们另一个在哪里，这样我们就可以解决树$O(V)$的直径问题。</p><h2 id="22-2-9"><a href="#22-2-9" class="headerlink" title="22.2-9"></a>22.2-9</h2><blockquote><p>设$G = (V, E)$是一个连通的无向图。给出一个$O(V + E)$时间算法来计算一条路径$G$，该路径在每个方向上恰好遍历每条边$E$一次。描述一下，如果给你大量的便士，你如何能找到走出迷宫的路。</p></blockquote><p>首先，该算法计算图的最小生成树。请注意，这可以使用第 23 章的程序来完成。也可以通过执行广度优先搜索，并限制到和$v.\pi$之间$v$的边缘来完成$v$。为了避免重复计算边，请事先确定顶点的顺序$\le$。然后，我们将通过调用$\text{MAKE-PATH}(s)$构造步骤序列，其中$s$是用于$\text{BFS}$的根。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MAKE-<span class="built_in">PATH</span>(u)</span><br><span class="line">    <span class="keyword">for</span> each v ∈ Adj[u] but <span class="keyword">not</span> in the tree such that u ≤ v</span><br><span class="line">        go to v <span class="keyword">and</span> back to u</span><br><span class="line">    <span class="keyword">for</span> each v ∈ Adj[u] but <span class="keyword">not</span> equal to u.π</span><br><span class="line">        go to v</span><br><span class="line">        perform the path proscribed by MAKE-<span class="built_in">PATH</span>(v)</span><br><span class="line">    go to u.π</span><br></pre></td></tr></tbody></table></figure><h2 id="22-3-1"><a href="#22-3-1" class="headerlink" title="22.3-1"></a>22.3-1</h2><blockquote><p>使用行和列标签$\text{WHITE}$、$\text{GRAY}$和$\text{BLACK}$制作$3$-by-$3$ 图表。在每个单元$(i, j)$中，指示在有向图的深度优先搜索期间的任何点处，是否可以存在从颜色$i$顶点到颜色$j$顶点的边。对于每个可能的边，指出它可以是什么类型的边。为无向图的深度优先搜索制作第二个这样的图表。</p></blockquote><p>根据定理 22.7（括号定理），顶点$u$间隔与$v$的关系有 3 种情况：</p><ul><li>$[u.d, u.f]$并且$[v.d, v.f]$是完全分离的，</li><li>$[u.d, u.f] \subset [v.d, v.f]$，以及</li><li>$[v.d, v.f] \subset [u.d, u.f]$。</li></ul><p>我们根据这个定理来判断可能性。</p><ul><li><p>对于<strong>有向图</strong>，我们可以使用练习 22.3-5 给出的边缘分类来简化问题。</p><p>  $$<br>  \begin{array}{c|ccc}<br>  from \diagdown to &amp; \text{WHITE}         &amp; \text{GRAY}                &amp; \text{BLACK} \\<br>  \hline<br>  \text{WHITE}      &amp; \text{All kinds}     &amp; \text{Cross, Back}         &amp; \text{Cross} \\<br>  \text{GRAY}       &amp; \text{Tree, Forward} &amp; \text{Tree, Forward, Back} &amp; \text{Tree, Forward, Cross} \\<br>  \text{BLACK}      &amp; -                    &amp; \text{Back}                &amp; \text{All kinds}<br>  \end{array}<br>  $$</p></li><li><p>对于<strong>无向图</strong>，从有向图开始，我们移除前向边和交叉边，并且</p><ul><li>当存在后边缘时，我们添加树边缘；</li><li>当一条树边存在时，我们添加一条后边。</li></ul><p>  这是正确的，原因如下：</p><ol><li>定理 22.10：在无向图$G$的深度优先搜索中，的$G$每条边要么是树，要么是后边。所以只有树和后沿。</li><li>如果$(u, v)$从$u$的角度看是一条树边，$(u, v)$那么从$v$的角度看也是一条后边。</li></ol><p>  $$<br>  \begin{array}{c|ccc}<br>  from \diagdown to &amp; \text{WHITE}      &amp; \text{GRAY}       &amp; \text{BLACK} \\<br>  \hline<br>  \text{WHITE}      &amp; -                 &amp; \text{Tree, Back} &amp; \text{Tree, Back} \\<br>  \text{GRAY}       &amp; \text{Tree, Back} &amp; \text{Tree, Back} &amp; \text{Tree, Back} \\<br>  \text{BLACK}      &amp; \text{Tree, Back} &amp; \text{Tree, Back} &amp; -<br>  \end{array}<br>  $$</p></li></ul><h2 id="22-3-2"><a href="#22-3-2" class="headerlink" title="22.3-2"></a>22.3-2</h2><blockquote><p>在图 22.6 中显示深度优先搜索是如何工作的。假设$\text{DFS}$过程的第 5-7 行的<strong>为了</strong>循环按字母顺序考虑顶点，并假设每个邻接表按字母顺序排序。显示每个顶点的发现和完成时间，并显示每条边的分类。</p></blockquote><p>下表给出了图中每个 Vetex 的发现时间和完成时间。</p><p>请参见<a href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3.cpp">C++ demo</a>。</p><p>$$<br>\begin{array}{ccc}<br>\text{Vertex} &amp; \text{Discovered} &amp; \text{Finished} \\<br>\hline<br>q &amp;  1 &amp; 16 \\<br>r &amp; 17 &amp; 20 \\<br>s &amp;  2 &amp;  7 \\<br>t &amp;  8 &amp; 15 \\<br>u &amp; 18 &amp; 19 \\<br>v &amp;  3 &amp;  6 \\<br>w &amp;  4 &amp;  5 \\<br>x &amp;  9 &amp; 12 \\<br>y &amp; 13 &amp; 14 \\<br>z &amp; 10 &amp; 11<br>\end{array}<br>$$</p><ul><li><strong>树边缘：</strong> $(q, s)$，，，，，，，。$(s, v)$$(v, w)$$(q, t)$$(t, x)$$(x, z)$$(t, y)$$(r, u)$</li><li><strong>后边缘：</strong> $(w, s)$，，。$(z, x)$$(y, q)$</li><li><strong>前进边：</strong> $(q, w)$。</li><li><strong>交叉边缘：</strong> $(r, y)$，。$(u, y)$</li></ul><h2 id="22-3-3"><a href="#22-3-3" class="headerlink" title="22.3-3"></a>22.3-3</h2><blockquote><p>显示图 22.4 中深度优先搜索的括号结构。</p></blockquote><p>图 22.4 的深度优先搜索的括号结构是$(u(v(y(xx)y)v)u)(w(zz)w)$。</p><h2 id="22-3-4"><a href="#22-3-4" class="headerlink" title="22.3-4"></a>22.3-4</h2><blockquote><p>通过论证如果删除的$\text{DFS-VISIT}$第 3 行，该$\text{DFS}$过程将产生相同的结果，表明使用单个位来存储每个顶点颜色就足够了。</p></blockquote><p>将第 3 行更改为 <code>color = BLACK</code> 并删除第 8 行。然后，算法将产生相同的结果。</p><h2 id="22-3-5"><a href="#22-3-5" class="headerlink" title="22.3-5"></a>22.3-5</h2><blockquote><p>显示 Edge$(u, v)$为</p><p>**A.**树边或前向边当且仅当$u.d &lt; v.d &lt; v.f &lt; u.f$，</p><p><strong>乙。</strong>后边缘当且仅当$v.d \le u.d &lt; u.f \le v.f$，且</p><p>**C.**交叉边当且仅当$v.d &lt; v.f &lt; u.d &lt; u.f$。</p></blockquote><p><strong>A.</strong>$u$是的$v$祖先。</p><p><strong>乙。</strong>$u$是的$v$后代。</p><p>以前$u$<strong>C.</strong>$v$访问过。</p><h2 id="22-3-6"><a href="#22-3-6" class="headerlink" title="22.3-6"></a>22.3-6</h2><blockquote><p>证明在无向图中，根据在深度优先搜索期间是否$(u, v)$首先遇到或$(v, u)$将边$(u, v)$分类为树边或后边等价于根据分类方案中四种类型的顺序对其进行分类。</p></blockquote><p>根据定理 22.10，无向图的每条边要么是树边，要么是后边。首先，假设这$v$是通过探索边缘$(u, v)$首先发现的。那么根据定义，$(u, v)$是一条树边。而且，$(u, v)$一定是以前$(v, u)$发现过的，因为一旦$(v, u)$被探索，$v$就一定会被发现。现在假设它$v$不是第一个被发现$(u, v)$的。那么它必须被一些人$r\ne u$发现$(r, v)$。如果$u$还没有被发现，那么如果$(u, v)$首先被探索，它一定是一个后沿，因为$v$它是的$u$祖先。如果$u$已被发现，则$u$是的$v$祖先，因此$(v, u)$是后沿。</p><h2 id="22-3-7"><a href="#22-3-7" class="headerlink" title="22.3-7"></a>22.3-7</h2><blockquote><p>重写该过程$\text{DFS}$，使用堆栈来消除递归。</p></blockquote><p>请参见<a href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-7/22.3-7.cpp">C++ demo</a>。</p><p>另外，请参阅本文<a href="https://github.com/walkccc/CLRS/issues/329">issue</a>中的<a href="https://github.com/i-to">@i-to</a>讨论。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DFS-<span class="built_in">STACK</span>(G)</span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.π = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE</span><br><span class="line">            DFS-VISIT-<span class="built_in">STACK</span>(G, u)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DFS-VISIT-<span class="built_in">STACK</span>(G, u)</span><br><span class="line">    S = Ø</span><br><span class="line">    <span class="built_in">PUSH</span>(S, u)</span><br><span class="line">    time = time + <span class="number">1</span>             <span class="comment">// white vertex u has just been discovered</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">while</span> !STACK-<span class="built_in">EMPTY</span>(S)</span><br><span class="line">        u = <span class="built_in">TOP</span>(S)</span><br><span class="line">        v = FIRST-WHITE-<span class="built_in">NEIGHBOR</span>(G, u)</span><br><span class="line">        <span class="keyword">if</span> v == NIL</span><br><span class="line">            <span class="comment">// u's adjacency list has been fully explored</span></span><br><span class="line">            <span class="built_in">POP</span>(S)</span><br><span class="line">            time = time + <span class="number">1</span></span><br><span class="line">            u.f = time</span><br><span class="line">            u.color = BLACK     <span class="comment">// blackend u; it is finished</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// u's adjacency list hasn't been fully explored</span></span><br><span class="line">            v.π = u</span><br><span class="line">            time = time + <span class="number">1</span></span><br><span class="line">            v.d = time</span><br><span class="line">            v.color = GRAY</span><br><span class="line">            <span class="built_in">PUSH</span>(S, v)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FIRST-WHITE-<span class="built_in">NEIGHBOR</span>(G, u)</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ G.Adj[u]</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">    <span class="keyword">return</span> NIL</span><br></pre></td></tr></tbody></table></figure><h2 id="22-3-8"><a href="#22-3-8" class="headerlink" title="22.3-8"></a>22.3-8</h2><blockquote><p>给出一个猜想的反例，如果一个有向图$G$包含一条从$u$到$v$的路径，并且如果$u.d &lt; v.d$在深度优先搜索$G$中，那么$v$在深度优先森林中产生的是的后代$u$。</p></blockquote><p>考虑一个图，其$3$顶点$u$为、$v$和$w$，边$(w, u)$为、$(u, w)$和$(w, v)$。假设$\text{DFS}$首先探索$w$，并且该$w$邻接表之前$v$有$u$。我们接下来发现$u$。唯一的相邻顶点是$w$，但$w$已经是灰色的，因此$u$完成。因为$v$还不是的后代$u$，并且$u$已经完成，所以$v$永远不能成为的$u$后代。</p><h2 id="22-3-9"><a href="#22-3-9" class="headerlink" title="22.3-9"></a>22.3-9</h2><blockquote><p>给出一个猜想的反例：如果一个有向图$G$包含一条从$u$到$v$的路径，那么任何深度优先搜索的结果都是$v.d \le u.f$。</p></blockquote><p>考虑顶点$\{1, 2, 3\}$上的有向图，并且具有边$(1, 2)$，$(1, 3)$$(2, 1)$则存在从$2$到$3$的路径。然而，如果我们在之前$3$开始一个$\text{DFS}$AT$1$和过程$2$，我们将得到$2.f = 3 &lt; 4 = 3.d$一个给定猜想的反例。</p><h2 id="22-3-10"><a href="#22-3-10" class="headerlink" title="22.3-10"></a>22.3-10</h2><blockquote><p>修改深度优先搜索的伪代码，以便打印出有向图$G$中的每条边及其类型。如果$G$是未定向的，则显示需要进行的修改（如果有）。</p></blockquote><p>如果$G$是非定向的，我们不需要做任何修改。</p><p>请参见<a href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-10/22.3-10.cpp">C++ demo</a>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DFS-VISIT-<span class="built_in">PRINT</span>(G, u)</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ G.Adj[u]</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            print <span class="string">"(u, v) is a tree edge."</span></span><br><span class="line">            v.π = u</span><br><span class="line">            DFS-VISIT-<span class="built_in">PRINT</span>(G, v)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> v.color == GRAY</span><br><span class="line">            print <span class="string">"(u, v) is a back edge."</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> v.d &gt; u.d</span><br><span class="line">            print <span class="string">"(u, v) is a forward edge."</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            print <span class="string">"(u, v) is a cross edge."</span></span><br><span class="line">    u.color = BLACK</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time</span><br></pre></td></tr></tbody></table></figure><h2 id="22-3-11"><a href="#22-3-11" class="headerlink" title="22.3-11"></a>22.3-11</h2><blockquote><p>解释有向图的顶点$u$如何在深度优先树中结束，该树只$u$包含，即使$u$在中$G$既有传入边也有传出边。</p></blockquote><p>假设我们在顶点$\{1, 2, 3\}$上有一个有向图，并且有边$(1, 2)$和$(2, 3)$。然后，$2$具有传入边和传出边。</p><p>如果我们选择我们的第一个根$3$，那将是在它自己的$\text{DFS}$树上。然后，我们选择我们的第二个根$2$，因为它指向的唯一东西已经被标记了$\text{BLACK}$，我们不会探索它。然后，选择最后一个根$1$，我们不会破坏树中$\text{DFS}$的事实，$2$即使它既有传入边又有传出边$G$。</p><h2 id="22-3-12"><a href="#22-3-12" class="headerlink" title="22.3-12"></a>22.3-12</h2><blockquote><p>表明我们可以使用无向图$G$的深度优先搜索来识别的$G$连通分量，并且深度优先森林包含与$G$连通分量一样多的树。更准确地说，展示如何修改深度优先搜索，以便为每个顶点$v$分配一个介于和$k$之间的整数标签$v.cc$$1$，其中$k$是的连通分量$G$的数量，使得$u.cc = v.cc$当且仅当$u$和$v$在同一连通分量中。</p></blockquote><p>修改工作如下：每次<strong>如果</strong>在中$\text{DFS-CC}$满足第 8 行的-条件时，我们在森林中有一个树的新根，因此我们将其$cc$标签更新为新值$k$。在对$\text{DFS-VISIT-CC}$的递归调用中，我们总是更新后代的连通分量，使其与祖先的连通分量一致。</p><p>请参见<a href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-12/22.3-12.cpp">C++ demo</a>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DFS-<span class="built_in">CC</span>(G)</span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.π = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    cc = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE</span><br><span class="line">            u.cc = cc</span><br><span class="line">            cc = cc + <span class="number">1</span></span><br><span class="line">            DFS-VISIT-<span class="built_in">CC</span>(G, u)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DFS-VISIT-<span class="built_in">CC</span>(G, u)</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ G.Adj[u]</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            v.cc = u.cc</span><br><span class="line">            v.π = u</span><br><span class="line">            DFS-VISIT-<span class="built_in">CC</span>(G, v)</span><br><span class="line">    u.color = BLACK</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time</span><br></pre></td></tr></tbody></table></figure><h2 id="22-3-13-star"><a href="#22-3-13-star" class="headerlink" title="22.3-13$\star$"></a>22.3-13$\star$</h2><blockquote><p>有向图$G = (V, E)$是指**<em>单连通的</em>**$u \leadsto v$对于所有顶点$u, v \in V$最多$G$包含一条从$u$到$v$的简单路径。给出了一个判定有向图是否单连通的有效算法。</p></blockquote><p>这是可以及时$O(|V||E|)$完成的。为此，首先执行顶点的拓扑排序。然后，我们将包含每个顶点的祖先$in\text-degree$$0$列表。我们按照从较早的顶点开始的拓扑顺序为每个顶点计算这些列表。</p><p>然后，如果我们曾经有一个顶点，在它的两个直接父节点的列表中出现了相同度数$0$的顶点，我们就知道这个图不是单连通的。然而，如果在每一步我们都有，在每一步所有的父节点都有不相交的度点集$0$作为祖先，则图是单连通的。由于对于每个顶点，所需的时间量受顶点数乘以特定顶点的$in\text-degree$限制，因此总运行时间受限制$O(|V||E|)$。</p><h2 id="22-4-1"><a href="#22-4-1" class="headerlink" title="22.4-1"></a>22.4-1</h2><blockquote><p>在练习 22.3-2 的假设下，显示在图 22.8 的 DAG 上运行时产生$\text{TOPOLOGICAL-SORT}$的顶点排序。</p></blockquote><p>我们表演的$\text{DFS}$开始和结束时间是</p><p>$$<br>\begin{array}{ccc}<br>\text{label} &amp; d &amp; f \\<br>\hline<br>m &amp; 1  &amp; 20 \\<br>q &amp; 2  &amp; 5  \\<br>t &amp; 3  &amp; 4  \\<br>r &amp; 6  &amp; 19 \\<br>u &amp; 7  &amp; 8  \\<br>y &amp; 9  &amp; 18 \\<br>v &amp; 10 &amp; 17 \\<br>w &amp; 11 &amp; 14 \\<br>z &amp; 12 &amp; 13 \\<br>x &amp; 15 &amp; 16 \\<br>n &amp; 21 &amp; 26 \\<br>o &amp; 22 &amp; 25 \\<br>s &amp; 23 &amp; 24 \\<br>p &amp; 27 &amp; 28<br>\end{array}<br>$$</p><p>因此，通过按完成时间的降序读取条目，我们得到了序列$p, n, o, s, m, r, y, v, x, w, z, u, q, t$。</p><h2 id="22-4-2"><a href="#22-4-2" class="headerlink" title="22.4-2"></a>22.4-2</h2><blockquote><p>给出一个线性时间算法，该算法将一个有向无环图$G = (V, E)$和两个顶点$s$和$t$作为输入，并返回中$G$从$s$到$t$的简单路径的数目。例如，图 22.8 的有向无环图恰好包含四条从顶点$p$到顶点$v: pov$的简单路径、$poryv$、$posryv$和$psryv$。（你的算法只需要计算简单路径，而不是列出它们。）</p></blockquote><p>该算法的工作原理如下。节点$u$的属性$u.paths$告诉从$u$到$v$的简单路径的数量，我们假设$v$在整个过程中是固定的。首先，应进行拓扑排序，并列出之间$u$的顶点，$v$如$\{v[1], v[2], \dots, v[k - 1]\}$。为了计算路径的数量，我们应该从$v$到$u$构造一个解决方案。让我们调用$u$AS$v[0]$和$v$AS$v[k]$，以避免重叠子问题，应该记住和$u$之间$v_k$的路径数量，并将其用作$k$减少到$0$。只有用这种方法我们才能解决这个问题$\Theta(V + E)$。</p><p>只有当图使用邻接矩阵时，自底向上的迭代版本才是可能的，因此$u$可以及时确定$O(1)$是否$v$邻接。但是建立一个邻接矩阵是要花钱$\Theta(|V|^2)$的，所以没关系。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-<span class="built_in">PATHS</span>(G, u, v)</span><br><span class="line">    TOPO-<span class="built_in">SORT</span>(G)</span><br><span class="line">    let {v[<span class="number">1</span>], v[<span class="number">2</span>]..v[k - <span class="number">1</span>]} be the vertex between u <span class="keyword">and</span> v</span><br><span class="line">    v[<span class="number">0</span>] = u</span><br><span class="line">    v[k] = v</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">0</span> to k - <span class="number">1</span></span><br><span class="line">        DP[j] = ∞</span><br><span class="line">    DP[k] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> SIMPLE-PATHS-<span class="built_in">AID</span>(G, DP, <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-PATHS-<span class="built_in">AID</span>(G, DP, i)</span><br><span class="line">    <span class="keyword">if</span> i &gt; k</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> DP[i] != ∞</span><br><span class="line">        <span class="keyword">return</span> DP[i]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       DP[i] = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> v[m] in G.adj[v[i]] <span class="keyword">and</span> <span class="number">0</span> &lt; m ≤ k</span><br><span class="line">            DP[i] += SIMPLE-PATHS-<span class="built_in">AID</span>(G, DP, m)</span><br><span class="line">       <span class="keyword">return</span> DP[i]</span><br></pre></td></tr></tbody></table></figure><h2 id="22-4-3"><a href="#22-4-3" class="headerlink" title="22.4-3"></a>22.4-3</h2><blockquote><p>给出一个确定给定的无向图$G = (V, E)$是否包含圈的算法。你的算法应该及时运行$O(V)$，独立于$|E|$。</p></blockquote><p>无向图是无环的（即，一个森林）当且仅当DFS不产生后边缘。由于后边是深度优先树中连接顶点u和祖先v的边（u，v），所以没有后边意味着只有树的边，所以没有循环。</p><p>所以我们可以简单地运行DFS。如果找到一个后沿，则有一个循环。复杂度是O（V）而不是O（E + V）。既然有后沿，一定要先发现后看|V|明显的边缘这是因为在无环（无向）森林中，|E| ≤ |V|-1</p><h2 id="22-4-4"><a href="#22-4-4" class="headerlink" title="22.4-4"></a>22.4-4</h2><blockquote><p>证明或反驳：如果一个有向图$G$包含圈，那么$\text{TOPOLOGICAL-SORT}(G)$产生一个顶点排序，使与产生的排序不一致的“坏”边的数量最小化。</p></blockquote><p>这不是真的。考虑由顶点$a, b, c$和$d$组成的图$G$。假设边为$(a, b)$、$(b, c)$、$(a, d)$、$(d, c)$和$(c, a)$。假设我们从顶点$c$开始$\text{DFS}$$\text{TOPOLOGICAL-SORT}$。假设$b$在的$a$邻接表中出现在之前$d$，则完成时间从最晚到最早的顺序为$c, a, d, b$。</p><p>在这种情况下，“坏”边是$(b, c)$和$(d, c)$。然而，如果我们在$a, b, d, c$那时订购它们，唯一不好的边缘将是$(c, a)$。因此$\text{TOPOLOGICAL-SORT}$并不总是最小化“坏”边的数量。</p><h2 id="22-4-5"><a href="#22-4-5" class="headerlink" title="22.4-5"></a>22.4-5</h2><blockquote><p>在有向无环图$G = (V, E)$上执行拓扑排序的另一种方法是重复查找的$\text{in-degree}$$0$顶点，输出该顶点，并从图中删除该顶点及其所有引出边。解释如何实现这个想法，以便它及时$O(V + E)$运行。如果$G$有循环，这个算法会发生什么？</p></blockquote><p>首先，运行DFS或BFS来计算O（V+E）时间内每个点的进出，然后在删除边时维护此信息。每次输入为0的一条，点击删除边并保持信息，所以有E条边和V点，所以O（V）输出和O（E）删除。所以总的运行时间是O（V+E）。）</p><p>如果图有环，那么有时可能没有度数为零的点。</p><h2 id="22-5-1"><a href="#22-5-1" class="headerlink" title="22.5-1"></a>22.5-1</h2><blockquote><p>如果添加一条新边，图的强连通分支的数目如何改变？</p></blockquote><p>它可以保持不变，也可以减少。要了解保持不变的可能性，只需假设向循环添加一些边。为了看到减少是可能的，假设你的原始图在三个顶点上，并且只是一条通过所有顶点的路径，并且添加的边将这条路径完成为一个循环。要看到它不能增加，请注意添加边不能删除以前存在的任何路径。</p><p>因此，如果$u$和$v$在原始图中处于相同的连通分量中，则在两个方向上都存在从一个到另一个的路径。添加边不会干扰这两条路径，因此我们知道，$u$$v$添加边后，图中仍将保持不变$\text{SCC}$。由于没有组件可以分开，这意味着它们的数量不能增加，因为它们形成了顶点集合的划分。</p><h2 id="22-5-2"><a href="#22-5-2" class="headerlink" title="22.5-2"></a>22.5-2</h2><blockquote><p>在图 22.6 的图表上显示程序$\text{STRONGLY-CONNECTED-COMPONENTS}$如何工作。具体来说，显示第 1 行中计算的完成时间和第 3 行中生成的森林。假设的$\text{DFS}$第 5–7 行的循环按字母顺序考虑顶点，并且邻接表按字母顺序。</p></blockquote><p>在练习 22.3-2 中计算每个顶点的完成时间。这片森林由 5 棵树组成，每棵树都是一条链。我们将按从根到叶的顺序列出每棵树的顶点：$r$、$u$、$q - y - t$、$x - z$和$s - w - v$。</p><h2 id="22-5-3"><a href="#22-5-3" class="headerlink" title="22.5-3"></a>22.5-3</h2><blockquote><p>培根教授声称，如果在第二次深度优先搜索中使用原始（而不是转置）图，并按完成时间的_不断增加_顺序扫描顶点，则强连通分量的算法会更简单。这个更简单的算法总是产生正确的结果吗？</p></blockquote><p>培根教授的建议行不通。举个例子，假设我们的图在三个顶点$\{1, 2, 3\}$上，并且由边$(2, 1), (2, 3), (3, 2)$组成。然后，我们应该以$\{2, 3\}$和$\{1\}$作为我们$\text{SCC}$的结束。然而，可能$\text{DFS}$的开始时间$2$可以在之前$1$探索$3$，这将意味着的$3$完成时间低于$1$和$2$。这意味着当我们第一次执行$\text{DFS}$开始$3$时。但是，$\text{DFS}$从 AT$3$开始将能够到达所有其他顶点。这意味着算法将返回整个图是单个$\text{SCC}$的，尽管情况显然不是这样，因为既没有从$1$到$2$的路径，也没有从$1$到$3$的路径。</p><h2 id="22-5-4"><a href="#22-5-4" class="headerlink" title="22.5-4"></a>22.5-4</h2><blockquote><p>证明对于任何有向图$G$，我们有$((G^\text T)^{\text{SCC}})^\text T = G^{\text{SCC}}$。也就是说，的分量图$G^\text T$的转置与的分量图$G$相同。</p></blockquote><p>首先观察$C$是的$G$强连通分支当且仅当它是的$G^\text T$强连通分支。因此，和$(G^\text T)^{\text{SCC}}$的$G^{\text{SCC}}$顶点集是相同的，这意味着和$G^{\text{SCC}}$的$((G^\text T)^\text{SCC})^\text T$顶点集是相同的。这足以表明它们的边集是相同的。假设$(v_i, v_j)$是中的$((G^\text T)^{\text{SCC}})^\text T$一条边。然后$(v_j, v_i)$是边缘在$(G^\text T)^{\text{SCC}}$。因此，存在$x \in C_j$并且$y \in C_i$使得$(x, y)$是的$G^\text T$边，这意味着$(y, x)$是的$G$边。由于组件被保留，这意味着它$(v_i, v_j)$是中的$G^{\text{SCC}}$一条边。对于相反的含义，我们简单地注意到，对于我们拥有的$(G^\text T)^{\text T} = G$任何图$G$。</p><h2 id="22-5-5"><a href="#22-5-5" class="headerlink" title="22.5-5"></a>22.5-5</h2><blockquote><p>给出了$O(V + E)$计算有向图$G = (V, E)$的分量图的时间算法。确保算法生成的组件图中的两个顶点之间最多有一条边。</p></blockquote><p>首先执行STRONGLY-CONNECTED-COMPONENTS过程，然后在[1，k]中为每个节点分配一个值，即生成的k个强连通分量。第k个强连通分支中所有节点的值为k。然后遍历每个节点i，对于Adj[i]的每个节点j，如果k[i]和k[j]之前没有边，则相加。</p><h2 id="22-5-6"><a href="#22-5-6" class="headerlink" title="22.5-6"></a>22.5-6</h2><blockquote><p>给定一个有向图$G = (V, E)$，解释如何创建另一个图$G’ = (V, E’)$，使得（A）$G’$具有与$G$相同的强连通分支，（B）$G’$具有与$G$相同的分支图，并且（C）$E’$尽可能小。描述一个快速算法来计算$G’$。</p></blockquote><ol><li>先对原图G生成k个联通分量和一个SCC子图.</li><li>遍历k个所有的联通分量. 对每个联通分量,必然有一个能够到所有点的回路,只添加该回路到新的图.假设第i个联通分量有5个节点a,b,c,d,e,我们只需要添加边a-&gt;b,b-&gt;c,c-&gt;d,d-&gt;e,e-&gt;a即可.</li><li>选SCC子图的边,加到新的图. 节点可以任意选择.</li></ol><h2 id="22-5-7"><a href="#22-5-7" class="headerlink" title="22.5-7"></a>22.5-7</h2><blockquote><p>一个有向图$G = (V, E)$是**<em>半连接的</em>**如果，对于所有的顶点$u, v \in V$对，我们有$u \leadsto v$或$v \leadsto u$。给出了判断是否$G$为半连通的有效算法。证明你的算法是正确的，并分析它的运行时间。</p></blockquote><p>算法：</p><ol><li>快跑$\text{STRONG-CONNECTED-COMPONENTS}(G)$。</li><li>将每个强连通分支作为一个虚拟顶点，创建一个新的虚拟图$G’$。</li><li>快跑$\text{TOPOLOGICAL-SORT}(G’)$。</li><li>检查对于拓扑排序中的$G’$所有连续顶点$(v_i, v_{i + 1})$，图$G’$中是否存在边$(v_i, v_{i + 1})$。如果是，则原图是半连通的。否则，它就不是。</li></ol><p>证明：</p><p>很容易证明这$G’$是一个 DAG.考虑中的$G’$连续顶点$v_i$和$v_{i + 1}$。如果没有从$v_i$到$v_{i + 1}$的边，我们也可以得出结论，没有从$v_{i + 1}$到$v_i$的路径，因为$v_i$之后$v_{i + 1}$完成了。根据的定义$G’$，我们得出结论，不存在从表示为$v_i$的中$G’$的$G$任何顶点到表示为的$v_{i + 1}$顶点的路径。因此，$G$不是半连接的。如果在所有连续的顶点之间存在一条边，则我们声称在任意两个顶点之间存在一条边。因此，$G$是半连通的。</p><p>运行时间：$O(V + E)$。</p><blockquote><p>让 $G = (V, E)$ 是一个无向连通图，其权重函数为 $w： E \rightarrow \mathbb R$，并假设 $|E| \ge |V|$ 且所有边的权重都不同。</p><p>我们定义一棵次优最小生成树如下。让 $mathcal T$ 是 $G$ 所有生成树的集合，让 $T’$ 是 $G$ 的最小生成树。那么**<em>次优最小生成树</em>**就是一棵生成树$T$，使得$W(T) = \min_{T’’ \in \mathcal T - \{T’\}} \（w（T’’））$.</p><p><strong>a.</strong> 证明最小生成树是唯一的，但是次优最小生成树不一定是唯一的。</p><p><strong>b.</strong> 让 $T$ 成为 $G$ 的最小生成树。证明 $G$ 包含在 T$ 中的边 $(u, v) 和不在 T$ 中的边 $(x, y) ，这样 $T - \{(u, v)\} \cup \{(x, y)\}$ 是G的次优最小生成树。</p><p><strong>c.</strong> 让 $T$ 是 $G$ 的一棵生成树，对于 V$ 中的任意两个顶点 $u，v，让 $max[u, v]$ 表示在 $T$ 中 $u$ 和 $v$ 之间唯一的简单路径上权重最大的一条边。描述一个$O(V^2)$时间的算法，在给定$T$的情况下，为V$中的所有$u, v计算$max[u, v]$。</p><p><strong>d.</strong> 给出计算 $G$ 的次优最小生成树的高效算法。</p></blockquote><p><strong>a.</strong> 为了说明次优最小生成树不一定是唯一的，我们来看看下面这个有四个顶点的示例图。假设顶点为 ${a, b, c, d}$, 边的权重如下：</p><p>$$<br>\begin{array}{c|c|c|c|c|}<br>  &amp; a &amp; b &amp; c &amp; d \\<br>\hline<br>a &amp; - &amp; 1 &amp; 4 &amp; 3 \\<br>\hline<br>b &amp; 1 &amp; - &amp; 5 &amp; 2 \\<br>\hline<br>c &amp; 4 &amp; 5 &amp; - &amp; 6 \\<br>\hline<br>d &amp; 3 &amp; 2 &amp; 6 &amp; - \\<br>\hline<br>\end{array}<br>$$</p><p>那么，最小生成树的权重为 $7$，但有两棵权重次优的生成树，权重为 $8$。</p><p><strong>b.</strong> 我们试图证明，有一条边的交换可以使我们的最小生成树降级为次优最小生成树。在获得次优最小生成树的过程中，必须有某个远离其余顶点的单个切点，而在该切点上添加的边并不轻，否则，我们找到的将是最小生成树，而不是次优最小生成树。我们将该切分所选的边称为次优最小生成树 $(x,y)$。现在，考虑同样的切分，只是看看在获得 $T$ 时所选择的边，称之为 $(u，v)$。那么，如果考虑 $T -\{(u, v)} \cup \{(x, y)}$，它将是一棵次优最小生成树。这是因为如果第二好的最小生成树也为另一条切分选择了一条非光边，那么它最终会比所有的最小生成树都要昂贵。这就意味着，我们需要在每条切线上都选择轻边。这意味着所有选择都与最小生成树一致。</p><p><strong>c.</strong> 我们在此给出一个动态编程解决方案。假设我们要为 $(u, v)$ 求解。首先，我们将确定在从 $u$ 到 $v$ 的简单路径上紧接着 $u$ 出现的顶点 $x$。然后，我们将使 $\max[u, v]$ 等于 $w((u, x))$ 和 $\max[w, v]$ 的最大值。最后，我们只考虑 $u$ 和 $v$ 相邻的情况，在这种情况下，最大权重边只是两者之间的一条边。如果我们能在恒定时间内找到 $x$，那么整个动态程序的运行时间就是 $O(V^2)$，因为这就是正在建立的表的大小。为了在恒定时间内找到 $x$，我们要对树进行预处理。我们首先选取一个任意根。然后，我们对塔尔扬的离线最小公祖算法进行预处理（见问题 21-3）。这需要的时间只比线性多一点，即 $O(|V|\alpha(|V|))$。计算出所有最小公祖后，我们就可以在恒定时间内，在稍后的某个时间点查找该结果。然后，为了找到我们应该选取的 $w$，我们首先要看 $u = \text{LCA}(u,v)$，如果没有，那么我们就选取树中 $u$ 的父节点。如果是，那么我们就把问题反过来，试着计算 $\max[v，u]$，我们保证不会出现 $v = \text{LCA}(v, u)$ 这种情况，因为我们知道 $u$ 是 $v$ 的祖先。</p><p><strong>d.</strong> 在此，我们提供了一种用时 $O(V^2)$的算法，并对是否存在线性时间解（即用时 $O(E+V)$的解）保持开放态度。首先，我们用 $O(E+V\lg(V))$的时间找到一棵最小生成树，其时间为 $O(V^2)$。然后，使用 c 部分的算法，找到双数组最大值。然后，我们在所有顶点 $u$, $v$ 对中取运行最小值 $w(u,v)-\max[u,v]$。如果 $u$ 和 $v$ 之间没有边，我们就认为权重是无限的。然后，对于这个差值最小的一对，我们加入这条边，并从最小生成树中删除从 $u$ 到 $v$ 的路径中权重为 $\max[u,v]$的一条边。</p><blockquote><p>对于一个非常稀疏的连通图 $G = (V，E)$，我们可以通过在运行 Prim 算法之前对 $G$ 进行预处理以减少顶点数量，从而进一步提高使用斐波那契堆的 Prim 算法的 $O(E + V\lg V)$ 运行时间。具体来说，我们为每个顶点$u$ 选择与$u$ 相连的最小权重边$(u, v)$，并将$(u, v)$ 放入正在构建的最小生成树中。然后，我们收缩所有选定的边（见第 B.4 节）。我们不是一条一条地收缩这些边，而是首先确定合并为同一个新顶点的顶点集。然后，我们创建一个图形，这个图形就是逐条收缩这些边的结果，但我们是根据边的端点所处的集合对边进行 “重命名”。原始图中的几条边可能会被重命名为相同的名称。在这种情况下，结果只有一条边，其权重是相应原始边权重的最小值。</p><p>最初，我们将正在构建的最小生成树 $T$ 设置为空，对于 E$ 中的每一条边 $(u，v)，我们初始化属性 $(u, v).orig = (u, v)$ 和 $(u, v).c = w(u，v)$。我们使用 $orig$ 属性来引用与收缩图中的边相关联的初始图中的边。$c$ 属性用于保存边的权重，当边被收缩时，我们会根据上述选择边权重的方案对其进行更新。存储过程 $text{MST-REDUCE}$接受输入 $G$ 和 $T$，并返回带有更新属性 $orig’$ 和 $c’$ 的收缩图 $G’$。程序还会将 $G$ 的边累加到最小生成树 $T$ 中。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MST-<span class="built_in">REDUCE</span>(G, T)</span><br><span class="line">    <span class="keyword">for</span> each v ∈ G.V</span><br><span class="line">        v.mark = <span class="literal">false</span></span><br><span class="line">        MAKE-<span class="built_in">SET</span>(v)</span><br><span class="line">    <span class="keyword">for</span> each u ∈ G.V</span><br><span class="line">        <span class="keyword">if</span> u.mark == <span class="literal">false</span></span><br><span class="line">            choose v ∈ G.Adj[u] such <span class="built_in">that</span> (u, v).c is minimized</span><br><span class="line">                <span class="built_in">UNION</span>(u, v)</span><br><span class="line">                T = T ∪ {(u, v).orig}</span><br><span class="line">                u.mark = v.mark = <span class="literal">true</span></span><br><span class="line">    G<span class="number">'.</span>V = {FIND-<span class="built_in">SET</span>(v): v ∈ G.V}</span><br><span class="line">    G<span class="number">'.</span>E = Ø</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">each</span> (x, y) ∈ G.E</span><br><span class="line">        u = FIND-<span class="built_in">SET</span>(x)</span><br><span class="line">        v = FIND-<span class="built_in">SET</span>(y)</span><br><span class="line">        <span class="keyword">if</span> (u, v) ∉ G<span class="number">'.</span>E</span><br><span class="line">             G<span class="number">'.</span>E = G<span class="number">'.</span>E ∪ {(u, v)}</span><br><span class="line">             (u, v).orig<span class="number">'</span> = (x, y).<span class="built_in">orig</span></span><br><span class="line">             (u, v).c<span class="number">'</span> = (x, y).c</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x, y).c &lt; (u, v).c<span class="number">'</span></span><br><span class="line">             (u, v).orig<span class="number">'</span> = (x, y).<span class="built_in">orig</span></span><br><span class="line">             (u, v).c<span class="number">'</span> = (x, y).c</span><br><span class="line">    construct adjacency lists G<span class="number">'.</span>Adj <span class="keyword">for</span> G<span class="number">'</span></span><br><span class="line">    <span class="keyword">return</span> G<span class="number">'</span> <span class="keyword">and</span> T</span><br></pre></td></tr></tbody></table></figure><p><strong>a.</strong> 让 $T$ 是 $text{MST-REDUCE}$ 返回的边的集合，让 $A$ 是调用 $\text{MST-PRIM}(G’,c’,r)$形成的图 $G’$ 的最小生成树，其中 $c’$ 是 $G’E$ 边上的权重属性，$r$ 是 $G’V$ 中的任意顶点。证明 $T \cup {(x,y).orig’: (x, y) \in A}$ 是 $G$ 的最小生成树。</p><p><strong>b.</strong> 论证 $|G’.V| \le |V| / 2$.</p><p><strong>c.</strong> 展示如何实现 $text{MST-REDUCE}$，使其在 $O(E)$ 时间内运行。($\textit{提示：}$ 使用简单的数据结构)</p><p>**d.**假设我们运行$\text{MST-REDUCE}$$的$k$个阶段，使用一个阶段产生的输出$G’$作为下一阶段的输入$G$，并在$T$中累积边。论证 $k$ 阶段的总体运行时间为 $O(kE)$。</p><p>**e.**假设在运行$k$阶段的$\text{MST-REDUCE}$后，如第(d)部分所示，我们通过调用$\text{MST-PRIM}(G’, c’, r)$来运行普里姆算法，其中$G’$的权重属性为$c’$，由最后一个阶段返回，而$r$是$G’.V$中的任意顶点。演示如何选择 $k$，从而使总体运行时间为 $O(E/lg/lg V)$。论证您所选择的 $k$ 能使整体渐近运行时间最小化。</p><p><strong>f.</strong> 对于 $|E|$（就 $|V|$而言）的哪些值，有预处理的 Prim 算法会渐进地击败无预处理的 Prim 算法？</p></blockquote><p>**我们将证明每一步添加的边都是安全的。考虑一个无标记顶点 $u$。设 $S = {u/}$，并让 $A$ 是目前树中的边集。那么剪切尊重 $A$，我们添加的下一条边是一条光边，所以对 $A$ 来说是安全的。因此，在我们运行 Prim 算法之前，$T$ 中的每一条边对$T$ 都是安全的。通常情况下，Prim’s 算法在此时添加的任何一条边都必须连接两棵已创建的树，而且会被选作最小边。此外，我们在任何两棵树之间都会选择一条边。因此，我们只有最小的边并不是问题。结果树一定是最小的。</p><p>**b.**我们通过对 $G$ 中顶点数量的归纳来论证。我们假设 $|V| &gt; 1$，否则 $text{MST-REDUCE}$ 将在第 6 行遇到错误，因为无法选择 $v$。让 $|V| = 2$。因为 $G$ 是连通的，所以 $u$ 和 $v$ 之间一定有一条边，而且这条边的权重是最小的。它们连接起来，$|G’.V| = 1 = |V| / 2$。</p><p>假设在 $|V| = n$ 的情况下，上述主张成立。让 $G$ 是一个有 $n + 1$ 个顶点的连通图。那么在第 4 行的 for 循环检查最终顶点 $v$ 之前，$G’.V \le n / 2$。如果 $v$ 已被标记，那么我们就完成了；如果 $v$ 没有被标记，那么我们将把它连接到其他顶点，由于 $v$ 是最后一个要处理的顶点，所以它必须被标记。</p><p>无论如何，$v$ 都无法为 $G’.V$ 带来额外的顶点。所以</p><p>$$|G’.V| \le n / 2 \le (n + 1) / 2.$$</p><p><strong>c.</strong> 与其使用第 21 章中的不相交集合结构，我们可以简单地使用数组来跟踪顶点所在的组件。假设 $A$ 是一个长度为 $|V|$ 的数组，如果 $v = \text{FIND-SET}(u)$，那么 $A[u] = v$。那么 $\text{FIND-SET}(u)$现在可以替换为 $A[u]$，$\text{UNION}(u, v)$ 可以替换为 $A[v]=A[u]$。由于这些操作的运行时间不变，因此运行时间为 $O(E)$。</p><p><strong>d.</strong> 输出中的边的数量是单调递减的，因此每次调用的时间为 $O(E)$。因此，$k$ 调用耗时为 $O(kE)$。</p><p>**e.**普里姆算法的运行时间为 $O(E+V/lg V)$。每次运行 $\text{MST-REDUCE}$，顶点数量至少会减少一半。因此，在调用 $k$ 后，顶点数量最多为 $|V| / 2^k$。我们需要最小化</p><p>$$E + V / 2^k\lg(V / 2^k) + kE = E + \frac{V\lg V}{2^k} - \frac{Vk}{2^k} + kE$$</p><p>与 $k$ 有关。如果我们选择 $k =\lg\lg V$，那么我们就能如愿以偿地实现 $O(E\lg\lg V)$ 的总体运行时间。</p><p>要看到这个 $k$ 值最小，请注意 $\frac{Vk}{2^k}$ 项总是小于 $kE$ 项，因为 $E\ge V$。随着 $k$ 的减小，$kE$ 的贡献会减小，而 $\frac{V\lg V}{2^k}$ 的贡献会增大。因此，我们需要找到 $k$ 的值，使它们在最坏的情况下（当 $E = V$ 时）大致相等。为此，我们设置 $\frac{\lg V}{2^k} = k$。要精确解决这个问题，需要用到兰伯特 W 函数，但最接近的基本函数是 $k = \lg\lg V$。</p><p><strong>f.</strong> 我们只需设置不等式</p><p>$$E\lg\lg V &lt; E + V\lg V$$</p><p>发现我们需要</p><p>$$E &lt; \frac{V\lg V}{\lg\lg V-1} = O(\frac{V\lg V}{\lg\lg V}).$$</p><blockquote><p>无向图 $G$ 的**<em>瓶颈生成树</em>** $T$ 是 $G$ 的生成树，其最大边的权重在 $G$ 的所有生成树中最小。我们说瓶颈生成树的值就是 $T$ 中最大边的权重。</p><p>**a.**论证最小生成树就是瓶颈生成树。</p><p>第（a）部分表明，找到一棵瓶颈生成树并不比找到一棵最小生成树难。在剩下的部分中，我们将展示如何在线性时间内找到一棵瓶颈生成树。</p><p><strong>b.</strong> 给定一个图 $G$ 和一个整数 $b$，给出一个线性时间算法，确定瓶颈生成树的值是否最多为 $b$。</p><p>**c.**将（b）部分的算法用作瓶颈生成树问题线性时间算法的子程序。($textit{提示:}$ 您可能想使用一个收缩边集的子程序，就像问题 23-2 中描述的 $\text{MST-REDUCE}$程序那样).</p></blockquote><p><strong>a.</strong> 发现每棵最小生成树也是一棵瓶颈生成树。假设 $T$ 是一棵最小生成树。假设其中有一条边 $(u, v)$ 的权重大于瓶颈生成树的权重。那么，让 $V_1$ 成为 $V$ 的顶点子集，这些顶点在 $T$ 中不经过 $v$ 就能从 $u$ 到达。对称定义 $V_2$。然后，考虑将 $V_1$ 与 $V_2$ 分割开的切口。在这条切线上，我们只能添加一条权重最小的边，因此我们知道在这条切线上没有权重小于 $w(u,v)$的边。</p><p>然而，我们知道有一条权重小于该权重的瓶颈生成树。这是一个矛盾，因为瓶颈生成树既然是生成树，就必须有一条边穿过这条切口。</p><p>**为此，我们首先处理整个图，删除权重大于 $b$ 的边。如果剩下的图是连通的，我们就可以任意选择其中的任意一棵树，它将是一棵权重最多为 $b$ 的瓶颈生成树。测试图的连通性可以在线性时间内完成，方法是先进行广度搜索，然后确保搜索结束时没有空白顶点。</p><p><strong>c.</strong> 写下所有顶点的边重。使用第 9.3 节中的算法，在 $O(E)$的时间内找出这个数字列表的中位数。然后，以该中值为输入，运行 b 部分的程序。那么有两种情况：</p><p>第一种情况是，存在一棵权重最多为中位数的瓶颈生成树。那么，只需丢弃权重大于中值的边，然后在这张新图上用一半的边重复程序即可。</p><p>其次，我们可以认为不存在权重至多为该权重的瓶颈生成树。然后，我们应该运行与问题 23-2 类似的程序，收缩所有权重至多等于中位数权重的边。这需要花费 $O(E)$，然后我们就可以在现在只有一半边的图上解决问题了。</p><p>请注意，两种情况都是 $O(E)$，而且每次递归都会将问题规模减半。因此，这种递归的解法是线性的。</p><blockquote><p>在这个问题中，我们给出了三种不同算法的伪代码。每种算法都将连通图和权重函数作为输入，并返回一组边 $T$。对于每种算法，要么证明 $T$ 是最小生成树，要么证明 $T$ 不是最小生成树。同时描述每种算法最有效的实现方式，无论它是否能计算出最小生成树。</p><p><strong>a.</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MAYBE-MST-<span class="built_in">A</span>(G, w)</span><br><span class="line">    sort the edges into nonincreasing order of edge weights w</span><br><span class="line">    T = E</span><br><span class="line">    <span class="keyword">for</span> each edge e, taken in nonincreasing order by weight</span><br><span class="line">        <span class="keyword">if</span> T - {e} is a connected graph</span><br><span class="line">            T = T - {e}</span><br><span class="line">    <span class="keyword">return</span> T</span><br></pre></td></tr></tbody></table></figure><p><strong>b.</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MAYBE-MST-<span class="built_in">B</span>(G, w)</span><br><span class="line">    T = Ø</span><br><span class="line">    <span class="keyword">for</span> each edge e, taken in arbitrary order</span><br><span class="line">        <span class="keyword">if</span> T ∪ {e} has no cycles</span><br><span class="line">            T = T ∪ {e}</span><br><span class="line">    <span class="keyword">return</span> T</span><br></pre></td></tr></tbody></table></figure><p><strong>c.</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAYBE-MST-<span class="built_in">C</span>(G, w)</span><br><span class="line">    T = Ø</span><br><span class="line">    <span class="keyword">for</span> each edge e, taken in arbitrary order</span><br><span class="line">        T = T ∪ {e}</span><br><span class="line">        <span class="keyword">if</span> T has a cycle c</span><br><span class="line">            let e<span class="number">'</span> be a maximum-weight edge on c</span><br><span class="line">            T = T - {e}</span><br><span class="line">    <span class="keyword">return</span> T</span><br></pre></td></tr></tbody></table></figure></blockquote><p><strong>a.</strong> 这确实会返回一个 $\text{MST}$。为了说明这一点，我们将证明我们永远不会删除必须是最小生成树一部分的边。如果我们删除 $e$，那么 $e$ 就不可能是桥，这意味着 e 位于图的一个简单循环上。由于我们按非递增顺序删除边，循环上每条边的权重必须小于或等于 $e$。根据练习 23.1-5，$G$ 上有一棵删除了边 $e$ 的最小生成树。</p><p>要实现这一点，我们首先要在 $O(E \lg E)$ 时间内对边进行排序。对于每一条边，我们都需要检查 $T - {e}$ 是否相连，因此我们需要运行 $\text{DFS}$。每一次都需要 $O(V+E)$，因此对所有边进行检查需要 $O(E(V+E))$。这将主导运行时间，因此总时间为 $O(E^2)$。</p><p><strong>b.</strong> 这不会返回 ${MST}$。要了解这一点，让 $G$ 成为有 3 个顶点 $a$、$b$ 和 $c$ 的图。让权重分别为 3、2 和 1 美元的 eges 分别为 $(a,b)$、$(b,c)$ 和 $(c,a)$。如果算法按照列出的顺序检查这些边，则会选取最重的两条边，而不是最轻的两条边。</p><p>高效的实现方法是使用不相邻集合来跟踪相连的组件，如问题 23-2 中的 $\text{MST-REDUCE}$。试图在同一组件内联合将产生一个循环。由于我们对 $\text{MAKESET}$ 的调用次数为 $|V|$，对 $\text{FIND-SET}$ 和 $\text{UNION}$ 的调用次数最多为 3|E|$，因此运行时间为 $O(E\alpha(V))$。</p><p><strong>c.</strong> 这确实会返回一个 $\text{MST}$。要了解这一点，我们只需引用练习 23.1-5 中的结果即可。我们移除的边只是某个循环上权重最大的边，而且总是存在不包含这些边的最小生成树。此外，如果我们从每个循环中删除一条边，那么得到的图就不可能有任何循环，因此它一定是一棵树。</p><p>为了实现这一点，我们使用了第(b)部分中的方法，只不过现在我们还需要找到循环上的最大权重边。对于每一条引入循环的边，我们都可以执行 $\text{DFS}$来找到循环和最大权重边。由于此时的树最多只有一个循环，因此它最多有 $|V|$ 条边，所以我们可以在 $O(V)$ 内运行 $\text{DFS}$。因此运行时间为 $O(EV)$。</p><h2 id="23-1-1"><a href="#23-1-1" class="headerlink" title="23.1-1"></a>23.1-1</h2><blockquote><p>设$(u, v)$是连通图$G$中的最小权边。显示$(u, v)$属于的$G$某个最小生成树。</p></blockquote><p>在GENERIC-MST的第一步中，我们可以选择这样的切割，节点u在一边，节点v在另一边。（u，v）是通过这个切割的一条轻边。因此，添加（u，v）是安全的。</p><h2 id="23-1-2"><a href="#23-1-2" class="headerlink" title="23.1-2"></a>23.1-2</h2><blockquote><p>萨巴蒂尔教授猜想定理 23.1 的逆定理如下。设$G = (V, E)$是一个连通的无向图，其上$E$定义了一个实值权函数$w$。设$A$是包含在某个最小生成树$G$中的$E$子集，设$(S, V - S)$是该方面$A$的$G$任何切割，且设$(u, v)$是用于$A$交叉$(S, V - S)$的安全边。然后，$(u, v)$是一个光边的切割。通过举反例来证明教授的猜想是错误的。</p></blockquote><p>设$G$图$4$的顶点为：$u, v, w, z$。设图$(u, v), (u, w), (w, z)$的边的权$3$分别为、$1$和$2$。</p><p>假设$A$是集合$\{(u, w)\}$。让$S = A$。然后$S$清楚地尊重$A$。既然$G$是一棵树，它的最小生成树就是它本身，所以$A$它通常是最小生成树的一个子集。</p><p>此外，每个边缘都是安全的。特别是$(u, v)$，对于切割来说是安全的，但不是轻的边缘。因此，萨巴蒂尔教授的猜想是错误的。</p><h2 id="23-1-3"><a href="#23-1-3" class="headerlink" title="23.1-3"></a>23.1-3</h2><blockquote><p>证明如果一条边$(u, v)$包含在某个最小生成树中，则它是穿过图的某个割集的一条轻边。</p></blockquote><p>设$T_0$和$T_1$是通过从 A$\text{MST}$中删除边$(u, v)$而得到的两棵树。假设$V_0$和$V_1$分别是和$T_1$的$T_0$顶点。</p><p>考虑与$V_1$分离$V_0$的切口。假设有一个矛盾，即在这个切割中，有一些边的重量小于$(u, v)$。然后，我们可以通过添加该边来$T_1 \cup T_0$构造整个图的最小生成树。这将导致最小生成树的权重小于包含$(u, v)$的原始最小生成树。</p><h2 id="23-1-4"><a href="#23-1-4" class="headerlink" title="23.1-4"></a>23.1-4</h2><blockquote><p>给出一个简单的例子，一个连通图的边$\{(u, v):$集合存在一个割集$(S, V - S)$，使得$(u, v)$轻边交叉$(S, V - S)\}$不形成最小生成树。</p></blockquote><p>当三角形三条边权重相同时,每条边在某种 切割 中均是最轻,即结果中存在环,所以不是最小生成树.</p><p>例如，如果我们有一个三角形具有相同的重量。在每个切割中，将有两个相等的边e1和e2。如果我们选择e1进入MST，虽然e2也是一个轻量级的，但它不在MST中。</p><h2 id="23-1-5"><a href="#23-1-5" class="headerlink" title="23.1-5"></a>23.1-5</h2><blockquote><p>设$e$是连通图$G = (V, E)$的某个圈上的最大权边。证明存在的$G’ = (V, E - \{e\})$最小生成树也是的$G$最小生成树。也就是说，存在不包括$e$的$G$最小生成树。</p></blockquote><p>设$A$为任何切割，其在切割的一侧导致循环中的一些顶点，而在另一侧导致循环中的一些顶点。对于这些切口中的任何一个，我们都知道该切口的边缘$e$不是轻边缘。因为所有其他的切割都不会有边缘$e$穿过它，所以我们也不会有任何切割的边缘是轻的。这意味着我们认为 E 不安全。</p><h2 id="23-1-6"><a href="#23-1-6" class="headerlink" title="23.1-6"></a>23.1-6</h2><blockquote><p>证明一个图有唯一的最小生成树，如果对于图的每个割集，都有唯一的轻边穿过割集。给出一个反例，说明反之不成立。</p></blockquote><p>假设存在两个最小生成树 T 和 T’. 对任意一条边 e 属于 T, 如果从 T 中移除 e, 则 T 变得不连通, 形成 cut (S, V - S), 根据练习 23.1-3 可知, e 是穿过 cut(S, V - S) 最轻边. 假设边 x 属于 T’, 并穿过 cut (S, V - S), 则 x 同样是最轻边. 由于穿过 cut(S, V - S) 的最轻边唯一. 既 e 和 x 是同一条边. 所以 e 也属于 T’, 由于我们选择 e 是任意的, 所有在 T 中的边, 同样在 T’ 中. 即最小生成树唯一.</p><p>假设有两个MST，称为T和T ‘。对于T中的任何边e，如果我们从T中移除e，则T变得不连通，并且我们有一个割（S，V-S）。根据练习23.1-3，e是通过切割的光边（S，V-S）.如果边x在T’中且穿过切割（S，V-S），则x也是一个轻权。因为光边是独一无二的。所以e和x是同一条边，e也在T ‘中。因为我们随机选择e，在T中的所有边中，也在T ‘中。因此，MST是独一无二的。</p><p>将条件和结论调换则不成立, 如下.</p><p>如果相反，则不成立。看图片。</p><p><img src="https://github.com/gzc/CLRS/raw/master/C23-Minimum-Spanning-Trees/repo/s1/2.jpg" alt="img"></p><h2 id="23-1-7"><a href="#23-1-7" class="headerlink" title="23.1-7"></a>23.1-7</h2><blockquote><p>如果一个图的所有边权都是正的，那么任何连接所有顶点且总权最小的边子集一定是一棵树。给出一个例子来说明，如果我们允许某些权为非正数，则不能得出相同的结论。</p></blockquote><p>首先，我们证明了连接所有顶点的最小总权重的边子集是一棵树。为了看到这一点，假设没有，它有一个周期。这意味着移除此循环中的任何边将意味着剩余的边仍将连接所有顶点，但其总权重将小于被移除的边的权重。这将与顶点子集的总权重的最小值相矛盾。由于边的子集形成树，并且具有最小的总权重，因此它也必须是最小生成树。</p><p>如果我们允许负的边权，这个结论是不正确的，我们提供了一个构造。考虑所有边权重等于$-1$的图$K_3$。连接图的边的唯一最小权重集具有总权重$-3$，并且由所有边组成。这显然不是 A$\text{MST}$，因为它不是一棵树，这很容易看出，因为它比三个顶点的树多一条边。这个加权图中的任何一个$\text{MST}$都必须具有至少$-2$为的权重。</p><h2 id="23-1-8"><a href="#23-1-8" class="headerlink" title="23.1-8"></a>23.1-8</h2><blockquote><p>设$T$是图$G$的最小生成树，$L$是图的边权$T$的排序表。证明对于的$G$任何其他最小生成树$T’$，该列表$L$也是的边权重$T’$的排序列表。</p></blockquote><p>假设这$L’$是最小生成树的边权重的另一个排序列表。如果$L’ \ne L$，则在或$T’$中必须有第一条边$(u, v)$$T$，其权重小于另一组中的相应边$(x, y)$。不失一般性，假设$(u, v)$是在$T$。</p><p>设$C$是通过添加$(u, v)$到$L’$得到的图。那么我们一定引入了一个循环。如果在该圈上存在权大于$(u, v)$的边，则我们可以移除它以获得权严格小于的$T’$权的树$C’$，这与最小生成树的事实$T’$相矛盾。</p><p>因此，循环上的每条边的权重必须小于或等于$(u, v)$。假设每条边都具有严格较小的权。从$T$拆下$(u, v)$，将其分成两个组件。除了连接这些的圈之外，还必须存在一些边$(u, v)$，由于它具有较小的权重，我们可以使用该边来创建权重小于$T$的生成树，这是一个矛盾。因此，循环上的某些边具有与$(u, v)$相同的权重。将该边缘替换为$(u, v)$。相应的列表$L$和$L’$保持不变，因为我们换出了一条权重相等的边，但和$T’$共有的边$T$的数量增加了$1$。</p><p>如果我们以这种方式继续下去，最终它们必须有共同的边，这与它们的边权重在某些地方不同的事实相矛盾。因此，所有最小生成树都具有相同的边权重排序列表。</p><h2 id="23-1-9"><a href="#23-1-9" class="headerlink" title="23.1-9"></a>23.1-9</h2><blockquote><p>设$T$是一个图$G = (V, E)$的最小生成树，$V’$是的$V$一个子集。设$T’$为由$V’$导出的$T$子图，设$G’$为由$V’$导出的$G$子图。证明如果$T’$是连通的，则$T’$是的$G’$最小生成树。</p></blockquote><p>假设有一棵比$T’$这更便宜的生成树。也就是说，我们有一些$T’’$，所以$w(T’’) &lt; w(T’)$。然后，设$S$边在中$T$，但不在中$T’$。然后，我们可以通过考虑$S \cup T’’$来构造的$G$最小生成树。这是一个生成树，$T’’$因为$S \cup T’$它使所有的顶点$V’$都像$T’$这样连接起来。</p><p>然而，我们有</p><p>$$W（s\cup t ‘ ‘）=W（s）+W（t ‘ ‘） &lt;W（s）+W（t ‘）=W（S\cup t ‘）=w（t）。$$</p><p>这意味着我们刚刚找到了一个比最小生成树具有更低总权重的生成树。这是一个矛盾，所以我们假设有一个比$T’$更便宜的$V’$生成树一定是错误的。</p><h2 id="23-1-10"><a href="#23-1-10" class="headerlink" title="23.1-10"></a>23.1-10</h2><blockquote><p>给定一个图$G$和一个最小生成树$T$，假设我们减少其中一条边$T$的权重。显示$T$仍然是的$G$最小生成树。更正式地，设$T$是具有由权函数$w$给出的边权的$G$最小生成树。选择一条边$(x, y) \in T$和一个正数$k$，并定义权重函数$w’$</p><p>$$<br>w’(u, v) =<br>\begin{cases}<br>w(u, v)     &amp; \text{ if }(u, v) \ne (x, y), \\<br>w(x, y) - k &amp; \text{ if }(u, v) =   (x, y).<br>\end{cases}<br>$$</p><p>证明$T$是的最小生成树，$G$其边权由$w’$给出。</p></blockquote><p>我们通过切割来证明。最初，（x，y）是某个切割（V1，V2）中的轻边。减小（x，y），（x，y）的权重仍然是一个轻边。所以T是G的最小生成树，其边权由w′给出。</p><h2 id="23-1-11-star"><a href="#23-1-11-star" class="headerlink" title="23.1-11$\star$"></a>23.1-11$\star$</h2><blockquote><p>给定一个图$G$和一个最小生成树$T$，假设我们减少其中一条不在$T$的边的权重。给出了在修改图中求最小生成树的算法。</p></blockquote><p>如果我们将这个新减少的边添加到给定的树中，我们将创建一个循环。然后，如果我们沿着这个循环删除任何一条边，我们仍然会有一个生成树。这意味着我们沿着通过添加减少的边而形成的该循环查看所有权重，并且移除最大权重的循环中的边。这正是我们想要的，因为我们可能只想添加单个减少的边，然后，从那里我们将图改回树，使其总权重最小化。</p><h2 id="23-2-1"><a href="#23-2-1" class="headerlink" title="23.2-1"></a>23.2-1</h2><blockquote><p>Kruskal 的算法可以为相同的输入图$G$返回不同的生成树，这取决于当边按顺序排序时它如何打破联系。证明对于的$G$每个最小生成树$T$，有一种方法可以对克鲁斯卡尔算法中的$G$边进行排序，以便算法返回$T$。</p></blockquote><p>假设我们想要选择$T$作为我们的最小生成树。然后，为了使用 Kruskal 算法获得该树，我们将首先根据边的权重对边进行排序，然后将通过首先挑选包含在最小生成树中的边来解决边权重的关系，并将所有不$T$包含在最小生成树中的边视为稍大，即使它们具有相同的实际权重。</p><p>通过这种排序，我们仍然可以找到与所有最小生成树$w(T)$具有相同权重的树。然而，由于我们对中$T$的边进行了优先排序，我们将在其他最小生成树中的任何其他边上挑选它们。</p><h2 id="23-2-2"><a href="#23-2-2" class="headerlink" title="23.2-2"></a>23.2-2</h2><blockquote><p>假设我们将图$G = (V, E)$表示为邻接矩阵。对于这种情况，给出 Prim 算法的一个简单实现，它在$O(V^2)$时间上运行。</p></blockquote><p>在算法的每一步，我们将添加一条边，从目前为止创建的树中的一个顶点到不在树中的一个顶点，使得这条边具有最小权重。因此，对于不在树中的每个顶点，知道从该顶点到最小权重的树中的某个顶点的边将是有用的。我们将此信息存储在一个数组$A$中，其中$A[u] = (v, w)$如果$w$是的权重$(u, v)$，并且在到目前为止构建的树中从$u$到某个顶点$v$的边的权重中是最小的。我们将使用$A[u].1$访问$v$和$A[u].2$访问$w$。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PRIM-<span class="built_in">ADJ</span>(G, w, r)</span><br><span class="line">    initialize A with every entry = (NIL, ∞)</span><br><span class="line">    T = {r}</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to V</span><br><span class="line">        <span class="keyword">if</span> Adj[r, i] != <span class="number">0</span></span><br><span class="line">            A[i] = (r, <span class="built_in">w</span>(r, i))</span><br><span class="line">    <span class="keyword">for</span> each u in V - T</span><br><span class="line">        k = <span class="built_in">min</span>(A[i]<span class="number">.2</span>)</span><br><span class="line">        T = T ∪ {k}</span><br><span class="line">        k.π = A[k]<span class="number">.1</span></span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span> to V</span><br><span class="line">            <span class="keyword">if</span> Adf[k, i] != <span class="number">0</span> <span class="keyword">and</span> Adj[k, i] &lt; A[i]<span class="number">.2</span></span><br><span class="line">                A[i] = (k, Adj[k, i])</span><br></pre></td></tr></tbody></table></figure><h2 id="23-2-3"><a href="#23-2-3" class="headerlink" title="23.2-3"></a>23.2-3</h2><blockquote><p>对于稀疏图$G = (V, E)$，其中$|E| = \Theta(V)$，使用斐波那契堆实现 Prim 算法是否比二进制堆实现更快？对于一个稠密的图，在哪里$|E| = \Theta(V^2)$？斐波那契堆实现的大小$|E|$和$|V|$之间的关系如何才能比二进制堆实现更快？</p></blockquote><p>用二进制堆实现的 Prim 算法的运行时间为 $O((V+E)\lg V)$，在稀疏的情况下，运行时间仅为 $O(V\lg V)$。用斐波那契堆实现的算法是</p><p>$$O(E + V\lg V) = O(V + V\lg V) = O(V \lg V).$$</p><ul><li><p>在稀疏情况下，两种算法的渐进运行时间相同。</p></li><li><p>在密集的情况下。</p><ul><li><p>二进制堆实现的运行时间为</p><p>  $$O((V + E)\lg V) = O((V + V^2)\lg V) = O(V^2\lg V).$$</p></li><li><p>斐波纳契堆实现的运行时为</p><p>  $$O(E + V\lg V) = O(V^2 + V\lg V) = O(V^2).$$</p></li></ul><p>  因此，在密集情况下，斐波那契堆的实现速度会逐渐加快。</p></li><li><p>只要 $E = \omega(V)$，斐波那契堆实现的速度就会逐渐加快。假设我们有一个比线性增长更快的函数，比如 $f$，而 $E = f(V)$。</p></li><li><p>二进制堆实现的运行时间为</p><p>  $$O((V + E)\lg V) = O((V + f(V))\lg V) = O(f(V)\lg V).$$</p></li></ul><p>但是，斐波纳契堆实现的运行时将具有</p><p>$$O(E + V\lg V) = O(f(V) + V\lg V).$$</p><p>此运行时要么$O(f(V))$是或，要么$O(V\lg V)$取决于其$f(V)$增长速度是否$V\lg V$分别更快或更慢。</p><p>在这两种情况下，运行时都比$O(f(V)\lg V)$。</p><h2 id="23-2-4"><a href="#23-2-4" class="headerlink" title="23.2-4"></a>23.2-4</h2><blockquote><p>假设图中的所有边权都是从$1$到$|V|$范围内的整数。你能让克鲁斯卡尔的算法以多快的速度运行？如果对于某个常数$W$，边权重是从$1$到$W$范围内的整数呢？</p></blockquote><p>（已删除）</p><p>如果w是一个常数，我们可以使用计数排序</p><p>·对边排序：O（E lg E）时间。</p><p>· O（E）不交集森林上的运算，时间复杂度为O（Eα（V））。</p><p>排序占优势，因此总时间是O（E lg E）。当边落在范围1，. . .，|V|时间复杂度为O（V + E）时间复杂度为O（Eα（V））。如果边缘落在范围1，. . .，W对于任何常数W，我们仍然需要使用Ω（E）时间进行排序，并且总运行时间不能进一步提高。</p><h2 id="23-2-5"><a href="#23-2-5" class="headerlink" title="23.2-5"></a>23.2-5</h2><blockquote><p>假设图中的所有边权都是从$1$到$|V|$范围内的整数。你能让普里姆的算法运行多快？如果对于某个常数$W$，边权重是从$1$到$W$范围内的整数呢？</p></blockquote><p>对于第一种情况，我们可以使用 Van Emde Boas 树来改进时间限制$O(E \lg \lg V)$。与 Fibonacci 堆实现相比，该方法仅对稀疏图的渐近运行时间有所改善，而不能多项式地改善运行时间。这种实现的优点是它可以具有较低的开销。</p><p>对于第二种情况，我们可以使用双链表的集合，每个双链表对应于一个边权。这提高了到$O(E)$的界限。</p><h2 id="23-2-6-star"><a href="#23-2-6-star" class="headerlink" title="23.2-6$\star$"></a>23.2-6$\star$</h2><blockquote><p>假设图中的边权在半开区间$[0, 1)$上均匀分布。克鲁斯卡尔算法和普里姆算法，哪种算法能让你跑得更快？</p></blockquote><p>对于从均匀分布中提取的输入，我将使用 Kruskal 算法的桶排序，用于按权重对边进行预期线性时间排序。这将达到预期的运行时间$O(E\alpha(V))$。</p><h2 id="23-2-7-star"><a href="#23-2-7-star" class="headerlink" title="23.2-7$\star$"></a>23.2-7$\star$</h2><blockquote><p>假设已经计算了一个图$G$的最小生成树。如果我们添加一个新的顶点和关联边，$G$我们更新最小生成树的速度有多快？</p></blockquote><p>如果只有一条边,只需要将这个顶点和这条边加进去.</p><p>如果有k(k &gt; 1)条边,那么需要删去k-1条边.</p><p>假设新节点是v,那么从v必然有一些回路. 遍历k-1次,每次都能找到一个回路,从该回路中删除一条权值最大的边.</p><p>如果只有一条边，只需添加此边。</p><p>如果有k（k &gt; 1）条边，则需要移除k-1条边。我们可以通过Union-Find找到循环，并删除并集中最重的边。该算法需要（k-1）遍。</p><h2 id="23-2-8"><a href="#23-2-8" class="headerlink" title="23.2-8"></a>23.2-8</h2><blockquote><p>波登教授提出了一种新的分治算法来计算最小生成树，该算法如下。给定一个图$G = (V, E)$，将顶点集$V$划分为两个集合$V_1$和$V_2$，使得$|V_1|$和$|V_2|$最多$1$相差。设$E_1$为仅在中的$V_1$顶点上关联的边的集合，设$E_2$为仅在中的$V_2$顶点上关联的边的集合。递归求解两个子图$G_1 = (V_1, E_1)$和$G_2 = (V_2, E_2)$上的最小生成树问题。最后，选择穿过切口$(V_1, V_2)$的最小权重边$E$，并使用该边将生成的两个最小生成树合并为一个生成树。</p><p>要么论证该算法正确计算了的$G$最小生成树，要么提供一个该算法失败的例子。</p></blockquote><p>算法失败。假设$E = \{(u, v), (u, w), (v, w)\}$，和$(u, w)$的$(u, v)$权为$1$，的$(v, w)$权为$1000$，将集合划分为两个集合$V_1 = \{u\}$和$V_2 = \{v, w\}$。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>山东大学汇编实验一</title>
      <link href="/2023/10/20/shan-dong-da-xue-hui-bian-shi-yan-yi/"/>
      <url>/2023/10/20/shan-dong-da-xue-hui-bian-shi-yan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编实验（DOSBox-MASM）"><a href="#汇编实验（DOSBox-MASM）" class="headerlink" title="汇编实验（DOSBox+MASM）"></a>汇编实验（DOSBox+MASM）</h1><p>在编辑器下写好代码（asm文件，assembly（汇编语言）的文件）之后，进入DOSBox执行下面三条指令，例如file_name.asm已经编写好了</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MASM file_name</span><br><span class="line"></span><br><span class="line">LINK file_name</span><br><span class="line"></span><br><span class="line">file_name</span><br></pre></td></tr></tbody></table></figure><p>分别是编译，连接，执行</p><p>在MASMPlus写完代码，应该放进<strong>MASM64</strong>文件夹，然后才能在DOSBox里面用上面方法运行</p><h2 id="汇编语言的语法"><a href="#汇编语言的语法" class="headerlink" title="汇编语言的语法"></a>汇编语言的语法</h2><p>实验使用的汇编语言的版本是8086汇编语言，跟现代汇编语言在语法上大致相同，关键词有点儿变更</p><h3 id="实验一（字符串比较）"><a href="#实验一（字符串比较）" class="headerlink" title="实验一（字符串比较）"></a>实验一（字符串比较）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">datarea segment                       ; 定义数据段</span><br><span class="line">    string1 db 'Move the cursor backward.';db是伪指令，分配数据大小的</span><br><span class="line">    string2 db 'Move the cursor forward.'</span><br><span class="line">    ;</span><br><span class="line">    mess1   db 'Match.',13,10,'$''$'    ; 匹配消息</span><br><span class="line">    mess2   db 'No match!',13,10,'$''$' ; 不匹配消息</span><br><span class="line">datarea ends</span><br><span class="line"></span><br><span class="line">prognam segment                        ; 定义代码段</span><br><span class="line">    main proc far;远进程段</span><br><span class="line">        assume cs:prognam, ds:datarea, es:datarea</span><br><span class="line">    start:                                ; 程序入口点</span><br><span class="line">        ; 保存旧数据段</span><br><span class="line">        push   ds</span><br><span class="line">        sub    ax, ax;ax=ax-ax=0,实际上就是置零指令</span><br><span class="line">        push   ax</span><br><span class="line"></span><br><span class="line">        ; 设置 DS 和 ES 段寄存器</span><br><span class="line">        mov    ax, datarea                ; 数据段地址</span><br><span class="line">        mov    ds, ax                     ; DS 寄存器</span><br><span class="line">        mov    es, ax                     ; ES 寄存器</span><br><span class="line"></span><br><span class="line">        ; 比较字符串</span><br><span class="line">        lea    si, string1                ; SI 指向 string1</span><br><span class="line">        lea    di, string2                ; DI 指向 string2</span><br><span class="line">        cld                               ; 清除方向标志位，从左到右比较</span><br><span class="line">        mov    cx, 25                     ; 比较的字符数</span><br><span class="line">        repz   cmpsb                      ; 比较字符串</span><br><span class="line">        jz     match                      ; 如果相等，跳转到 match 标签</span><br><span class="line">        lea    dx, mess2                  ; 不相等，加载 mess2 地址</span><br><span class="line">        jmp    short disp                ; 跳转到 disp 标签</span><br><span class="line"></span><br><span class="line">    match:  ;跳转标签</span><br><span class="line">        lea    dx, mess1                  ; 相等，加载 mess1 地址</span><br><span class="line"></span><br><span class="line">    disp:  ;display,显示</span><br><span class="line">        mov    ah, 09                    ; 设置功能码为 9，用于显示字符串</span><br><span class="line">        int    21h                       ; 调用 DOS 中断显示消息</span><br><span class="line"></span><br><span class="line">        ret                               ; 返回到 DOS</span><br><span class="line">    main endp                             ; 结束主程序</span><br><span class="line">prognam ends                             ; 结束代码段</span><br><span class="line">end start                                ; 程序结束标记</span><br></pre></td></tr></tbody></table></figure><p>注意这里有一个系统调用，经过<strong>查看中断表INT 21H</strong>，可以知道<code>mov    ah, 09</code>就是调用了09的系统功能，<strong>显示了字符串</strong>。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>汇编的注释是”;”</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;注释内容</span><br></pre></td></tr></tbody></table></figure><h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><h4 id="datarea"><a href="#datarea" class="headerlink" title="datarea"></a>datarea</h4><p>datarea=data area，数据段</p><p><strong>数据段定义：</strong> 数据段是用于存储数据的部分，以<code>datarea segment</code>开始，以<code>datarea ends</code>结束。</p><h4 id="prognam"><a href="#prognam" class="headerlink" title="prognam"></a>prognam</h4><p>“prognam” 的全拼是 “program name”，表示程序的名称。</p><h3 id="ASSUME"><a href="#ASSUME" class="headerlink" title="ASSUME"></a>ASSUME</h3><p><code>ASSUME</code> 是一种指令或伪指令，用于建立代码段（<code>CS</code>）、数据段（<code>DS</code>）、附加段（<code>ES</code>）、堆栈段（<code>SS</code>）等不同段寄存器和段寄存器组合之间的关联。这是一种在8086汇编语言和一些后续x86架构中的寄存器分段模型中使用的机制。</p><p>以下是 <code>ASSUME</code> 指令的详解：</p><ol><li><p><strong>语法：</strong> <code>ASSUME seg_reg: seg_name</code>，其中 <code>seg_reg</code> 是段寄存器（如 <code>CS</code>、<code>DS</code>、<code>ES</code>、<code>SS</code> 等），而 <code>seg_name</code> 是段的名称或标签。</p></li><li><p><strong>作用：</strong> <code>ASSUME</code> 指令建立了一个假设或关联，告诉汇编器哪个段寄存器应与哪个段相关联。这是为了在编译时确定代码和数据的位置，以便在生成机器代码时能够正确地生成内存地址。</p></li><li><p><strong>用途：</strong> <code>ASSUME</code> 指令通常在程序开头的数据段（<code>DATA</code>）中使用，以确保代码段和数据段的正确关联。例如，代码段（<code>CS</code>）通常与程序代码相关联，数据段（<code>DS</code>）通常与程序数据相关联。</p></li><li><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assume cs:prognam, ds:datarea, es:datarea</span><br></pre></td></tr></tbody></table></figure><p>在这个示例中，<code>CS</code> 寄存器被关联到 <code>prognam</code> 段，<code>DS</code>和<code>ES</code> 寄存器被关联到 <code>datarea</code> 段。这意味着汇编器将使用这些关联来生成正确的内存地址，以便在程序执行时能够访问正确的代码和数据。</p></li></ol><p>在现代的x86汇编中，由于分段模型的变化，通常不再需要显式使用 <code>ASSUME</code>，因为多数情况下，汇编器会根据段声明自动推断关联。但在一些情况下，特别是在使用老旧的编译器和汇编器时（实验环境），可能需要手动设置关联。</p><h3 id="db-dw-dd"><a href="#db-dw-dd" class="headerlink" title="db,dw,dd"></a>db,dw,dd</h3><p>在汇编语言中，<code>db</code> 是一个伪指令（directive），用于定义数据。具体地，<code>db</code> 表示 “define byte”，它用于将一个或多个字节（8位）的数据分配给指定的标识符。其他常用的伪指令还包括 <code>dw</code>（define word，用于定义16位数据）、<code>dd</code>（define doubleword，用于定义32位数据）等，它们用于分配不同大小的数据。</p><ol><li><p><strong><code>assume</code> 段寄存器指令：</strong> 在程序的开始，<code>assume cs:prognam, ds:datarea, es:datarea</code>用于关联代码段（<code>cs</code>）和数据段（<code>ds</code>、<code>es</code>）的寄存器。这表明代码段和数据段使用相同的内存段，可以相互访问。</p></li><li><p><strong>栈操作：</strong> 该程序使用栈来保存和还原数据段寄存器的值。<code>push</code>指令用于将数据保存在栈中，<code>pop</code>指令用于将数据弹出栈。这是为了保护程序的状态。</p></li><li><p><strong>寄存器操作：</strong> <code>ax</code> 寄存器用于存储零值。<code>mov</code> 指令用于将数据加载到寄存器中，例如，<code>mov ax, datarea</code> 将 <code>ax</code> 设置为数据段的地址。</p></li><li><p><strong>字符串比较：</strong> 使用字符串比较指令，<code>cld</code> 用于确保比较从左到右进行。然后，<code>repz cmpsb</code> 用于比较两个字符串，直到出现不匹配或达到指定的字符数（<code>cx</code> 寄存器中的值）。如果两个字符串匹配，<code>jz match</code> 将跳转到 <code>match</code> 标签，否则跳转到 <code>disp</code> 标签。</p></li><li><p><strong>消息显示：</strong> <code>lea dx, mess1</code> 或 <code>lea dx, mess2</code> 用于加载消息的地址到 <code>dx</code> 寄存器。接着，<code>mov ah, 09</code> 设置功能码，表示要显示字符串，然后使用 <code>int 21h</code> 来调用DOS中断以显示消息。</p></li><li><p><strong>返回：</strong> <code>ret</code> 用于返回到DOS。程序的入口点是 <code>start</code> 标签，而 <code>end start</code> 表明程序的结束点。</p></li></ol><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><p><a href="https://blog.csdn.net/qq_40843865/article/details/81210164">汇编指令详解-CSDN博客</a></p><p>下面列出实验一的一些指令</p><p><strong>(1) LEA(Load Effective Address)</strong><br>    格式：   lea REG,OPRD        <br>    功能：   把操作数OPRD的<font color="cornflowerblue">有效地址</font>传送到操作数REG<br>     注：    REG必须是16位通用寄存器，OPRD必须是一个存储器操作数<br> <br>     如：    lea ax,buf            ;buf是变量名<br>            lea ax,[si+2]</p><p><strong>(4) CLD(Clear Direction Flag):            DF置0，执行串操作指令时，地址递增</strong></p><p><strong><code>REPZ CMPSB</code> 是x86汇编语言中的一个指令序列，用于比较两个内存中的字符串并返回比较结果</strong>。以下是对该指令的详细解释：</p><ol><li><p><code>REPZ</code> 前缀：<code>REPZ</code> 是一个前缀指令，用于控制<strong>重复执行后续的指令</strong>。它基本上表示”<strong>repeat while zero</strong>“，即只要 <code>ZF</code>（零标志位）标志为1（表示相等），就重复执行后续的指令。如果 <code>ZF</code> 标志变为0（表示不相等），则停止重复执行。</p></li><li><p><code>CMPSB</code> 指令：<code>CMPSB</code> 是比较字符串指令，用于比较 <code>DS:SI</code> 指向的字节和 <code>ES:DI</code> 指向的字节，并根据比较结果更新一些寄存器和标志。在这里，<code>DS</code> 和 <code>ES</code> 是数据段寄存器，<code>SI</code> 和 <code>DI</code> 是源和目的地偏移地址寄存器。</p><ul><li><code>CMPSB</code> 会比较 <code>DS:SI</code> 和 <code>ES:DI</code> 指向的字节。</li><li>如果两个字节相等，它会设置 <code>ZF</code> 标志位为1（表示相等），否则为0（表示不相等）。</li><li>它还会根据 DF 标志位（方向标志位）的值来决定是向前比较（DF=0）还是向后比较（DF=1）。</li><li>然后，它会递增或递减 <code>SI</code> 和 <code>DI</code> 的值，取决于 DF 标志位的值，以便指向下一个要比较的字节。</li></ul></li></ol><p>在 <code>REPZ CMPSB</code> 指令序列中，重复执行 <code>CMPSB</code> 指令直到 <code>ZF</code> 标志变为0。这意味着它会持续比较两个字符串中的字节，直到找到不匹配的字节或直到达到字符串的末尾。</p><p>如果两个字符串完全相等，<code>REPZ</code> 指令将在比较结束后停止，<code>ZF</code> 标志将保持为1，表示字符串相等。如果字符串不相等或任何一个字符串的长度小于 <code>CX</code> 寄存器中的计数，<code>REPZ</code> 将停止，<code>ZF</code> 标志将变为0，表示字符串不相等。</p><p>在实验1中，<code>repz cmpsb</code> 的目的是比较 <code>string1</code> 和 <code>string2</code> 中的字符，直到找到不匹配的字符或两个字符串都完全匹配。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2023/10/19/hui-bian-yu-yan/"/>
      <url>/2023/10/19/hui-bian-yu-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h3 id="8086的字节和字"><a href="#8086的字节和字" class="headerlink" title="8086的字节和字"></a>8086的字节和字</h3><p>8086一个字节是8位（在哪里都不会变），但是8086的一个字是16位，也就是两个字节</p><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>注意：默认小端存储，低位低放，高位高放</p><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104213821128.png" alt="image-20231104213821128"></p><h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><p>源操作数与目的操作数字长一致。</p><p> 任何操作数不能是IP、FLAGS，目的操作数不能是CS。（有专用指令）</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104214357160.png" alt="image-20231104214357160"></p><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231017141209086.png" alt="image-20231017141209086"></p><p><strong>AX、BX、CX、DX 通常用来存放一般性数据被称为通用寄存器（16位）</strong></p><p>由于8086初期是8位，为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。</p><p>​AX可以分为AH和AL；</p><p>​BX可以分为BH和BL；</p><p>​CX可以分为CH和CL；</p><p>​DX可以分为DH和DL。</p><p>AX的低8位（0位<del>7位）构成了AL寄存器，高8位（8位</del>15位）构成了AH寄存器</p><p>段地址×16（也就是二进制左移4位）+偏移地址=物理地址，物理地址20位，段地址16位</p><p>内存没有分段，只是CPU用段地址记录物理地址</p><p>段的起始地址（不是段地址，段地址是去掉末位）必然是xxxx0H（16的倍数），偏移地址16位，所以段长度最多64K</p><h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>段寄存器就是提供段地址的</p><p>8086CPU有4个段寄存器：</p><p>​ CS、DS、SS、ES</p><p>当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018224509342.png" alt="image-20231018224509342"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018225526532.png" alt="image-20231018225526532"></p><h3 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h3><p><strong>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址</strong></p><p>​CS为代码段寄存器</p><p>​IP为指令指针寄存器</p><table><thead><tr><th align="center">8086PC工作过程的简要描述</th></tr></thead><tbody><tr><td align="center">（1）<strong>从CS:IP指向内存单元读取指令</strong>，读取的指令进入指令缓冲器；<br>（2）IP = IP + 所读取指令的长度，从而指向下一条指令；<br>（3）执行指令。 转到步骤 （1），重复这个过程。</td></tr></tbody></table><blockquote><p>tip:</p><p>在 8086CPU 加电启动或复位后（ 即 CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行，<strong>FFFF0H单元中的指令是8086PC机开机后执行的第一条指令</strong></p></blockquote><p>CPU将CS:IP指向的内存单元中的内容看作指令</p><p>怎么修改CS:IP?</p><p>mov指令不能用于设置CS、IP的值，   8086CPU没有提供这样的功能。8086修改CS:IP的指令是转移指令（jmp等）</p><p>8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。若有内存被CPU访问，则该内存一定被CS:IP指向过</p><h3 id="DS"><a href="#DS" class="headerlink" title="DS"></a>DS</h3><p>执行指令时，8086CPU自动取DS中的数据为内存单元的段地址</p><p>​mov [0],ax即将ax寄存器数据存到DS:0位置</p><p>8086CPU中有一个 DS寄存器，通常用来存放<strong>要访问的数据的段地址</strong>。</p><p>mov指令的格式：      </p><p>​mov 寄存器名，[内存单元地址]</p><p>“[…]”表示一个内存单元， “[…]”中的数字表示内存单元的偏移地址。</p><p><font color="red"><strong>8086CPU不支持将数据直接送入段寄存器的操作</strong></font></p><p><strong>数据➡️一般的寄存器➡️段寄存器</strong></p><h2 id="和-的应用"><a href="#和-的应用" class="headerlink" title="[]和()的应用"></a>[]和()的应用</h2><p>[bx]表示一个内存单元（存储器操作数），它的偏移地址在bx中，比如下面的指令：mov ax,[bx]</p><p>ax中的内容为0010H，我们可以这样来描述：(ax)=0010H； </p><p>也可以这样说，[]一般出现在指令里面&lt;偏移地址&gt;，()一般出现在计算里面&lt;内容数据&gt;</p><table><thead><tr><th align="left">mov [bx],ax</th></tr></thead><tbody><tr><td align="left">功能：<br>bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。  即：(ds *16 +(bx))  =  (ax)。</td></tr></tbody></table><h2 id="SI和CI"><a href="#SI和CI" class="headerlink" title="SI和CI"></a>SI和CI</h2><p>SI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8 位寄存器来使用</p><p>一般默认SI源寄存器，DI目的寄存器</p><p>在“[…]” 中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di</p><p>只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231016230952500.png" alt="image-20231016230952500"></p><h2 id="控制寄存器（IP和FLAGS）"><a href="#控制寄存器（IP和FLAGS）" class="headerlink" title="控制寄存器（IP和FLAGS）"></a>控制寄存器（IP和FLAGS）</h2><p><strong>IP</strong> 指定将IP用于指令地址记录，即Instruction Pointer。每次取指后都自增1。</p><p><strong>FLAGS</strong> 指定将FLAGS用作程序状态指示，也即PSW（Program Status Word）。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018224328803.png" alt="image-20231018224328803"></p><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231018230055341.png" alt="image-20231018230055341"></p><h3 id="PTR什么时候用？"><a href="#PTR什么时候用？" class="headerlink" title="PTR什么时候用？"></a><code>PTR</code>什么时候用？</h3><p>有寄存器时不用，无寄存器（包含【bx】）时要使用，防止源操作数和目的操作数位数不一致</p><p><code>BYTE PTR</code>指明是要赋单字节值</p><p><a href="https://blog.csdn.net/qq_36561697/article/details/80698875">https://blog.csdn.net/qq_36561697/article/details/80698875</a></p><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><h3 id="1-立即寻址"><a href="#1-立即寻址" class="headerlink" title="1.立即寻址"></a>1.立即寻址</h3><p>操作数直接存放在指令中，立即寻址方式用来表示常数，它经常用于给寄存器赋初值，并且只能用于源操作数字段，不能用于目的操作数字段，且源操作数 长度 应与目的操作数 长度一致。</p><p><strong>例子：MOV AX, 3064H</strong> </p><h3 id="2-寄存器寻址"><a href="#2-寄存器寻址" class="headerlink" title="2.寄存器寻址"></a>2.寄存器寻址</h3><p>操作数 在寄存器中，指令指定寄存器号。 </p><p>对于16位操作数，寄存器可以是AX,BX,CX,DX,SI,DI,SP和BP；</p><p>对于8位操作数，寄存器可以是AL,AH, BL, BH, CL, CH, DL,DH；</p><p><strong>例子：MOV AX, BX</strong> </p><h3 id="3-直接寻址"><a href="#3-直接寻址" class="headerlink" title="3.直接寻址"></a>3.直接寻址</h3><p>操作数的有效地址只包含位移量一种成分(位移量（displacement)是存放在指令中的一个 8位、16位或 32位的数，但它不是立即数，而是一个地址。区别在于<strong>位移量加[]</strong>)，其值就存放在代码段中指令的操作码之后，位移量的值即操作数的有效地址</p><p><strong>例子：MOV AX,[2000H]</strong></p><h3 id="4-寄存器间接寻址"><a href="#4-寄存器间接寻址" class="headerlink" title="4.寄存器间接寻址"></a>4.寄存器间接寻址</h3><p>操作数的有效地址只包含基址寄存器内容或变址寄存器内容一种成分。 因此，<strong>有效地址就在某个寄存器中</strong>，而<strong>操作数则在存储器</strong>中</p><p><strong>例子：MOV AX，[BX]</strong></p><p>没有特殊说明（段跨越前缀），默认段寄存器为DS（BP和SP的时候默认是SS）</p><p>假设（DS）=2000H，（BX）=1000H，物理地址EA=（DS）&lt;&lt;4+(BX)=21000H</p><p>则(AX)=50A0H，<strong>一定要注意EA是地址，操作数是（EA）</strong>，<strong>AX赋值是操作数赋值</strong>，EA只是用来寻址的</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231019223728313.png" alt="image-20231019223728313"></p><h3 id="5-寄存器相对寻址"><a href="#5-寄存器相对寻址" class="headerlink" title="5.寄存器相对寻址"></a>5.寄存器相对寻址</h3><p>操作数的有效地址为基址寄存器或变址寄存器的内容和指令中指定的位移量之和， 所以有效地址由两种成分组成。</p><p><strong>例子：MOV AX, COUNT[SI]</strong> （也可表示为<strong>MOV AX, [COUNT+SI])</strong>其中<strong>COUNT为16位位移量的符号地址。</strong></p><p><strong>MOV AX, [BX+10]</strong></p><p>如果 (DS) = 3000H, （SI）= 2000H, COUNT= 3000H</p><p>则物理地址EA＝30000+2000+3000= 35000H </p><h3 id="6-基址变址寻址"><a href="#6-基址变址寻址" class="headerlink" title="6.基址变址寻址"></a>6.基址变址寻址</h3><p>操作数的有效地址是一个基址寄存器和一个变址寄存器的内容之和，所以有效地址由两种成分组成</p><p><strong>例子：MOV AX, [BX] [DI] （或写为 ：MOV AX, [BX+ DI])</strong></p><p>如(DS)= 2100H, （BX) = 0158H, (DI)= 10A5H<br>则EA= 0158+10A5= 11FDH，物理地址＝21000+11FD= 221FDH </p><p>执行结果(AX)=1234H</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231019225016657.png" alt="image-20231019225016657"></p><h3 id="7-相对基址变址寻址"><a href="#7-相对基址变址寻址" class="headerlink" title="7.相对基址变址寻址"></a>7.相对基址变址寻址</h3><p>操作数的有效地址是一个基址寄存器与一个变址寄存器的内容和指令中指定的位移量之和，所以有效地址由三种 成分组成。</p><p><strong>例子：MOV MASK[BX] [SI]（也可写成MOV AX, MASK[BX+SI]或MOV AX, [MASK+BX+ SI])</strong></p><p>如（DS)= 3000H, (BX)= 2000H, (SI）= 1000H，MASK= 0250H, </p><p>则 物理地址<strong>EA＝（DS)&lt;&lt;4+(BX)+(SI）+MASK</strong><br>= 30000+2000+1000+0250 = 33250H<br>执行结果(AX)= 1234H。<br><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231019225646835.png" alt="image-20231019225646835"></p><h2 id="存储器寻址"><a href="#存储器寻址" class="headerlink" title="存储器寻址"></a>存储器寻址</h2><p><strong><font color="red">一个指令不能有两个存储器操作数</font></strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104220620156.png" alt="image-20231104220620156"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104220640105.png" alt="image-20231104220640105"></p><h3 id="PTR什么时候用？-1"><a href="#PTR什么时候用？-1" class="headerlink" title="PTR什么时候用？"></a><code>PTR</code>什么时候用？</h3><p>有寄存器时不用，无寄存器（包含【bx】）时要使用，防止源操作数和目的操作数位数不一致</p><p><code>BYTE PTR</code>指明是要赋单字节值</p><p><a href="https://blog.csdn.net/qq_36561697/article/details/80698875">https://blog.csdn.net/qq_36561697/article/details/80698875</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104221244053.png" alt="image-20231104221244053"></p><h2 id="控制转移寻址"><a href="#控制转移寻址" class="headerlink" title="控制转移寻址"></a>控制转移寻址</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104221750451.png" alt="image-20231104221750451"></p><h3 id="SHORT和FAR什么时候用"><a href="#SHORT和FAR什么时候用" class="headerlink" title="SHORT和FAR什么时候用"></a>SHORT和FAR什么时候用</h3><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104221830111.png" alt="image-20231104221830111"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104222152841.png" alt="image-20231104222152841"></p><p>看看PPT（第3章）记忆吧，总不能把这个文档全贴上图，这里仅仅放了near和far，因为经常见到，算是备忘录吧</p><h2 id="数据移动"><a href="#数据移动" class="headerlink" title="数据移动"></a>数据移动</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231104222419547.png" alt="image-20231104222419547"></p><p>注意段寄存器需要寄存器间接，可以说是设计上的缺陷吧，或者其他什么原因。注意CS是不能寄存器直接改的，但是DS和ES是可以的，只要注意固定搭配</p><h2 id="指令大全"><a href="#指令大全" class="headerlink" title="指令大全"></a>指令大全</h2><p>看第4讲PPT</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231105193717038.png" alt="image-20231105193717038"></p><h2 id="以字节对齐"><a href="#以字节对齐" class="headerlink" title="以字节对齐"></a>以字节对齐</h2><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20231105195609620.png" alt="image-20231105195609620"></p><p>在汇编语言中，<code>BX</code> 寄存器通常用来存储地址或偏移量。乘以2（SHL BX, 1）可能是因为<strong>查找表中的条目是按字（Word）大小存储的</strong>，而字的大小通常是2个字节（16位），因此需要将 <code>BX</code> 乘以2以获得正确的<strong>字节偏移</strong>。</p><p><strong><font color="DarkVoilet">这是因为在汇编语言中，地址通常是按字节而不是字（Word）对齐的。</font></strong><font color="MediumVioletRed">查找表的每个条目都是字大小的</font>，因此如果你要访问查找表中的一个条目，你需要考虑每个条目的大小，通常是2个字节，所以需要将 <code>BX</code> 乘以2以得到正确的字节偏移。这确保了你在查找表中正确地访问到所需的条目。</p><p>当你在程序中执行 <code>SHL BX, 1</code> 操作时，实际上是将 <code>BX</code> 寄存器的值左移一位，相当于将其乘以2。这是一种常见的操作，用于计算地址偏移量，以便访问数组、查找表或其他内存结构中的元素。这可以确保访问到正确的数据，以执行条件分支操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索</title>
      <link href="/2023/10/10/sou-suo/"/>
      <url>/2023/10/10/sou-suo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_43590232/article/details/104735102">https://blog.csdn.net/weixin_43590232/article/details/104735102</a></p><p><a href="https://stackoverflow.com/questions/3332947/what-are-the-practical-factors-to-consider-when-choosing-between-depth-first-sea">https://stackoverflow.com/questions/3332947/what-are-the-practical-factors-to-consider-when-choosing-between-depth-first-sea</a></p><p><strong>BFS适用于需要找到最短路径或距离起点最近的解决方案的问题，而DFS适用于需要深度探索或搜索所有可能解决方案的问题。</strong></p><p><strong>BFS通常只用来找一个解决方案，DFS用来找所有解决方案。</strong>BFS当然可以搜索所有解决方案，而且时间复杂度跟DFS相同，但是BFS的空间复杂度比DFS高太多了。</p><p>BFS和DFS的相邻点 有的时候很明显，有的时候不明显，需要自己总结一下。在做CSP题时，基本上没有明显的节点，都是需要抽象出来树形结构的</p><p><strong>做题第一步，纸上写出树形结构，分别考虑边和点。边考虑回溯，点考虑BFS和DFS。一定要考虑记忆化搜索和剪枝，不然一般都会超时。</strong></p><h2 id="BFS-最短路径问题"><a href="#BFS-最短路径问题" class="headerlink" title="BFS(最短路径问题)"></a>BFS(最短路径问题)</h2><h3 id="BFS问题的本质都是找从start到target的最短路"><a href="#BFS问题的本质都是找从start到target的最短路" class="headerlink" title="BFS问题的本质都是找从start到target的最短路"></a><code>BFS</code>问题的本质都是找从<code>start</code>到<code>target</code>的最短路</h3><p>如果是找最短路径，第一时间想<code>BFS</code>，注意是<code>短</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>{</span><br><span class="line">    queue&lt;Node&gt; q; </span><br><span class="line">    unordered_set&lt;Node&gt; visited;<span class="comment">//一般是用bool vis[size];用1表示自己去过了,数组访问O(1)。不过unordered_set也差不多。</span></span><br><span class="line">    <span class="comment">//一般是用数组。但是一些问题的索引不好确认，用unordered_set更好，普适性更好一些，但是需要确认元素是否重复（用值时）</span></span><br><span class="line">    q.<span class="built_in">push</span>(start); </span><br><span class="line">    <span class="comment">//visited.insert(start);//有时候写上会有问题，有了下面的，这里不要写了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) {</span><br><span class="line">            Node cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            visited.<span class="built_in">insert</span>(cur);<span class="comment">//必要</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cur == target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.<span class="built_in">adj</span>()) {<span class="comment">//不管是 邻接表 还是邻接数组 还是链式前向星 都要会写</span></span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">count</span>(x) == <span class="number">0</span>) {</span><br><span class="line">                    q.<span class="built_in">push</span>(x);</span><br><span class="line">                    visited.<span class="built_in">insert</span>(x);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果走到这里，说明在图中没有找到目标节点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>BFS</code>的<code>vis</code>数组一般只加不减，<code>vis</code>只是用来指示邻接点是否已经遍历过了</p><h2 id="BFS优化（双向BFS）"><a href="#BFS优化（双向BFS）" class="headerlink" title="BFS优化（双向BFS）"></a><code>BFS</code>优化（双向<code>BFS</code>）</h2><p><strong>前提：已经知道终点，从起点和终点分别开始<code>BFS</code>，可以降低大约一半<code>空间复杂度</code>和<code>时间复杂度</code>。这种技巧实际上并没有降低big O时间复杂度。用BFS还是双向BFS看情况吧。</strong></p><p>双向 BFS 还是遵循 BFS 算法框架的，只是<strong>不再使用队列，而是使用<code>unordered_set</code>方便快速判断两个集合q1、q2是否有交集。起点和终点分别加入<code>unordered_set</code>，遍历一个集合的时候，判断另一个集合是否有该元素。</strong>。</p><p>另外的一个技巧点就是 <strong>while 循环 <code>while( !q1.empty()&amp;&amp;!q2.empty()  )</code>的最后交换 <code>q1</code> 和 <code>q2</code> 的内容</strong>，所以只要默认扩散 <code>q1</code> 就相当于轮流扩散 <code>q1</code> 和 <code>q2</code>。或者 可以加一个<strong>判定<code>if (q1.size() &gt; q2.size()) </code>交换，仍然默认<code>q1</code>，但每次使用最小的集合</strong>。跟上边没什么区别。</p><p><strong>必掌握：求“最短路径”</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>{</span><br><span class="line">    unordered_set&lt;Node&gt; q1, q2, visited;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;<span class="comment">//记录路径长度</span></span><br><span class="line">    q1.<span class="built_in">insert</span>(start);</span><br><span class="line">    q2.<span class="built_in">insert</span>(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()){</span><br><span class="line">        <span class="comment">// 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果</span></span><br><span class="line">        unordered_set&lt;string&gt; temp;<span class="comment">//现在是q1遍历后的q1，相当于clear了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将 q1 中的所有节点向周围扩散 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> cur : q1){</span><br><span class="line">            <span class="comment">/* 判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span>(q2.<span class="built_in">count</span>(cur))</span><br><span class="line">                <span class="keyword">return</span> step;<span class="comment">//q1、q2相交，代表找到了</span></span><br><span class="line"></span><br><span class="line">            visited.<span class="built_in">insert</span>(cur);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将一个节点的未遍历相邻节点加入集合 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.<span class="built_in">adj</span>()) {<span class="comment">//不管是 邻接表 还是邻接数组 还是链式前向星 都要会写</span></span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">count</span>(x) == <span class="number">0</span>) {</span><br><span class="line">                    temp.<span class="built_in">push</span>(x);<span class="comment">//注意：应该是往temp里面加入元素</span></span><br><span class="line">                    visited.<span class="built_in">insert</span>(x);</span><br><span class="line">                }</span><br><span class="line">       }</span><br><span class="line">        <span class="comment">/* 在这里增加步数 */</span></span><br><span class="line">        step++;</span><br><span class="line">        <span class="comment">// temp 相当于 新的 q1</span></span><br><span class="line">        <span class="comment">// 这里交换 q1 q2，下一轮 while 就是扩散 q2</span></span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><a href="https://oi-wiki.org/search/astar/">A* - OI Wiki (oi-wiki.org)</a></p><p>这里涉及到了一个启发式搜索</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a><code>DFS</code></h2><p>DFS和回溯一般都是混用的，大家没严格区分</p><p>时间复杂度较高，但是可以拿部分的分 </p><p>本质上是 暴力穷举，递归函数，跟回溯基本一致。不要特别在意区分回溯和<code>DFS</code>，只要能做题就行。一般都是void，不用到返回值。</p><p><strong><code>DFS</code>必掌握“N皇后问题、全排列”</strong>，呃，这俩都是回溯</p><p>一般不会求最值，没有最优子结构</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> vis[N];<span class="comment">//DFS经常用到，当然也可以用unordered_map</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (终止条件) {</span><br><span class="line">      处理语句</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">    <span class="keyword">for</span> (邻接点) {</span><br><span class="line">        <span class="keyword">if</span>(下一步有效)<span class="comment">//一般是 !vis[i]</span></span><br><span class="line">        {</span><br><span class="line">            处理</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">      <span class="built_in">dfs</span>(参数);</span><br><span class="line">      撤销处理</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>就是二叉树遍历的<code>void traverse()</code>函数</p><p><strong>一般情况下，回溯算法的「做选择」和「撤销选择」在 for 循环里面，而<code>DFS</code>的操作在 for 循环外面。这是回溯算法和 DFS 算法的区别所在：回溯算法关注的不是节点，而是树枝（也可以说边，就是for里面 的路径选择）。而DFS只处理本身节点的选择和撤销选择。二者的区别在于根节点，DFS会处理和撤销处理根节点，但是回溯不行（回溯关注的是边，边数=点数-1（无环图成立，但是回溯等一般的 图算法都会visited掉环，所以对回溯是永远会漏掉根节点（大概？） ），回溯会漏掉根节点）。</strong></p><p>dfs和回溯都是void遍历+外部变量，动态规划是有返回值的（后序遍历）。相同点是都要在前序位置（入栈前判断，判断是否入栈）写判定条件（一定要考虑好边界条件），在后面写的时候，哪怕判断条件重复，实际上也不会影响算法效率。</p><p>通过选边还是选点，选择回溯或者DFS</p><h3 id="非明显节点型"><a href="#非明显节点型" class="headerlink" title="非明显节点型"></a>非明显节点型</h3><h4 id="1-排列组合问题"><a href="#1-排列组合问题" class="headerlink" title="1.排列组合问题"></a>1.排列组合问题</h4><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231008203914915.png" alt="image-20231008203914915"></p><p><strong>边问题，回溯</strong></p><p>求一个数组的全排列，这个要注意一点，vis标记与撤销，vis不能不撤销，那样会导致其他分支被剪掉，从而只会剩下一个排列。</p><h4 id="2-表格型（棋盘型、迷宫型）"><a href="#2-表格型（棋盘型、迷宫型）" class="headerlink" title="2.表格型（棋盘型、迷宫型）"></a>2.表格型（棋盘型、迷宫型）</h4><p>典型：“N皇后”问题</p><p>关键步骤：找到遍历逻辑（怎么遍历），至于皇后不能攻击、迷宫墙不能通过……这些问题是后期限制条件(if语句、剪枝)，前期不用管。</p><p>遍历逻辑——&gt;转化为树形结构（图本身也算树形大类）</p><p><strong>根节点为空，考虑回溯（抽象为边，边问题的根节点是空的）。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231008210924883.png" alt="image-20231008210924883"></p><p>N皇后一般思路：每行取一个皇后，这个皇后可以在该行的每个列（只要不在另一个皇后的攻击范围）——&gt; 后面加<code>if</code>限制条件。</p><p> <strong>在宽度优先和深度优先搜索里面，我们都是根据搜索的顺序依次进行搜索，可以称为盲目搜索，搜索效率非常低。</strong></p><p>而启发式搜索则大大提高了搜索效率，但启发式搜索可能很繁琐</p><p><a href="https://www.cnblogs.com/isguxing/p/9800490.html">https://www.cnblogs.com/isguxing/p/9800490.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据数据估算时间复杂度</title>
      <link href="/2023/10/07/gen-ju-shu-ju-gu-suan-shi-jian-fu-za-du/"/>
      <url>/2023/10/07/gen-ju-shu-ju-gu-suan-shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<p><strong>前提：一般都是1秒对应一千万次计算（也可能是一亿）</strong></p><p>拿题目数据规模反推大概用个啥算法用些啥优化。</p><p><strong>10^5级别？基本上是O(nlogn)；10^7?那必须O(n)了；10^3基本上不就是个O(n^2)；蹦跶出来个诸如20以内的条件基本上就暴力了；如果俩参数范围一个才十几二十另一个成千上万基本上是个状态压缩DP类似的玩意了……诸如此类。</strong></p><p>就因为是竞赛，你得正反都能估啊……算法推得出复杂度，复杂度推得出算法什么的。</p><p>当然了也不仅仅是一个渐进最大时间复杂度，通常来说还需要熟悉平均时间复杂度……</p><p><a href="https://liam.page/2016/06/20/big-O-cheat-sheet/">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector索引问题</title>
      <link href="/2023/10/04/vector-suo-yin-wen-ti/"/>
      <url>/2023/10/04/vector-suo-yin-wen-ti/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout&lt;&lt;<span class="string">"输入n"</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        cin&gt;&gt;temp;</span><br><span class="line">        v[i]=temp;<span class="comment">//这里会报错，因为v[i]还没有被定义，所以不能直接赋值，应该用push_back()函数</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注意一个问题，以前一直理解错了。"><a href="#注意一个问题，以前一直理解错了。" class="headerlink" title="注意一个问题，以前一直理解错了。"></a>注意一个问题，以前一直理解错了。</h2><p><strong>C++里面vector必须分配空间后才能用索引，否则就会报错。不然就用push_back();</strong></p><p>以前一直以为会自动处理，要引起重视。</p><p>在 C++ 中，如果尝试访问一个尚未分配内存的 <code>vector</code> 的元素，会导致未定义行为。当创建一个空的 <code>vector&lt;int&gt; res;</code> 时，它没有分配任何内存空间来存储元素，因此尝试访问 <code>v[i]</code> 将导致问题。</p><p>如果不设置大小，<code>v</code> 将是一个空的、没有分配内存的 <code>vector</code>，尝试在其中存储数据会导致内存越界错误或其他未定义行为，这可能会导致程序崩溃或产生不可预测的结果。因此，在使用 <code>vector</code> 时，通常需要确保分配足够的内存空间来存储数据，以避免这类问题。</p><h2 id="普通数组计算长度"><a href="#普通数组计算长度" class="headerlink" title="普通数组计算长度"></a>普通数组计算长度</h2><p>在C++中，你可以使用以下方法来快速计算数组的长度：</p><ol><li>使用 <code>sizeof</code> 操作符：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br></pre></td></tr></tbody></table></figure><p>这种方法会返回数组的总字节数除以每个元素的字节数，从而得到数组的长度。</p><ol start="2"><li>使用 <code>std::size</code> 函数（C++17及以上版本）：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> length = std::<span class="built_in">size</span>(arr);</span><br></pre></td></tr></tbody></table></figure><p><code>std::size</code> 是C++17及以上版本的标准库函数，它可以用于获取数组的长度。</p><ol start="3"><li>如果你使用了 <code>std::vector</code> 或其他STL容器，可以使用容器的 <code>size</code> 成员函数来获取长度：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> length = vec.<span class="built_in">size</span>();</span><br></pre></td></tr></tbody></table></figure><p>这些方法都可以快速计算数组或容器的长度，你可以根据你的编译环境和需求选择其中一种方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 易错点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2023/10/04/shuang-zhi-zhen/"/>
      <url>/2023/10/04/shuang-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231005115512463.png" alt="image-20231005115512463"></p><h1 id="双指针专题"><a href="#双指针专题" class="headerlink" title="双指针专题"></a>双指针专题</h1><h2 id="一、快慢指针技巧（同向指针）"><a href="#一、快慢指针技巧（同向指针）" class="headerlink" title="一、快慢指针技巧（同向指针）"></a>一、快慢指针技巧（同向指针）</h2><h3 id="1、数组问题中比较常见的快慢指针技巧，是让你原地修改数组。"><a href="#1、数组问题中比较常见的快慢指针技巧，是让你原地修改数组。" class="headerlink" title="1、数组问题中比较常见的快慢指针技巧，是让你原地修改数组。"></a>1、数组问题中比较常见的快慢指针技巧，是让你<strong>原地修改</strong>数组。</h3><p>套路框架：fast遍历数组，遇到符合条件的抛给slow。（数组元素只能覆盖，不能删除）</p><h3 id="2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。"><a href="#2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。" class="headerlink" title="2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。"></a>2、数组中另一大类快慢指针的题目就是「滑动窗口算法」。</h3><p>强调滑动窗口算法的快慢指针特性：</p><p><code>left</code> 指针在后，<code>right</code> 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s)</span> </span>{</span><br><span class="line">    <span class="comment">// 用合适的数据结构记录窗口中的数据</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) {</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        window.<span class="built_in">add</span>(c)</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="comment">// 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment">// 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"window: [%d, %d)\n"</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) {</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            window.<span class="built_in">remove</span>(d)<span class="comment">//应该是window[d]--;</span></span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>时间复杂度为<code>O(n)</code>：指针 <code>left, right</code> 不会回退（它们的值只增不减），所以字符串/数组中的每个元素都只会进入窗口一次，然后被移出窗口一次，不会说有某些元素多次进入和离开窗口，所以算法的时间复杂度就和字符串/数组的长度成正比</p><hr><p><strong>滑动窗口算法的思路是这样</strong>：</p><p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」。</p><table><thead><tr><th>Tip</th></tr></thead><tbody><tr><td>理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 <code>left = right = 0</code> 时区间 <code>[0, 0)</code> 中没有元素，但只要让 <code>right</code> 向右移动（扩大）一位，区间 <code>[0, 1)</code> 就包含一个元素 <code>0</code> 了。如果你设置为两端都开的区间，那么让 <code>right</code> 向右移动一位后开区间 <code>(0, 1)</code> 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 <code>[0, 0]</code> 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。</td></tr></tbody></table><p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</p><p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p><p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p><hr><p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解</strong>，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p><p>下面画图理解一下，<code>needs</code> 和 <code>window</code> 相当于计数器，分别记录 <code>T</code> 中字符出现次数和「窗口」中的相应字符的出现次数。</p><p>初始状态：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1.png" alt="img"></p><p>增加 <code>right</code>，直到窗口 <code>[left, right)</code> 包含了 <code>T</code> 中所有字符：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2.png" alt="img"></p><p>现在开始增加 <code>left</code>，缩小窗口 <code>[left, right)</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3.png" alt="img"></p><p>直到窗口中的字符串不再符合要求，<code>left</code> 不再继续移动：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4.png" alt="img"></p><p>之后重复上述过程，先移动 <code>right</code>，再移动 <code>left</code>…… 直到 <code>right</code> 指针到达字符串 <code>S</code> 的末端，算法结束。</p><hr><h4 id="常见环境：判断window里面的元素是否包含-子串-所有元素"><a href="#常见环境：判断window里面的元素是否包含-子串-所有元素" class="headerlink" title="常见环境：判断window里面的元素是否包含 子串 所有元素"></a><strong>常见环境：判断<code>window</code>里面的元素是否包含 子串 所有元素</strong></h4><p>对于 子串问题（字母有重复的）。添加<code>int valid</code>和<code>unordered_set&lt;char,int&gt; need</code><code>need</code>是子串的哈希表，记录子串字母和字母数目。</p><p>**在扩展窗口的时候，window添加后，当<code>window</code>里面对应字母数量等于子串对应的数量，<code>valid</code>加一。**</p><p><strong>在缩小窗口的时候，在window缩小前，若<code>window</code>内字母数量等于<code>need</code>里面对应的数量时（也就是缩小窗口后必小于need.size()），<code>valid</code>减一。</strong></p><p>还有就是 <code>window</code><strong>一般只需要记录子串元素，不用管其他元素</strong></p><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need,window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i:t)need[i]++;<span class="comment">//已完成，不修改</span></span><br><span class="line">        <span class="type">int</span> valid=<span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> need_size=need.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,len=INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> right_value=s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(right_value))<span class="comment">//存在</span></span><br><span class="line">            {</span><br><span class="line">                window[right_value]++;</span><br><span class="line">                <span class="keyword">if</span>(window[right_value]==need[right_value])</span><br><span class="line">                valid++;<span class="comment">//加法判定</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(valid==need_size)<span class="comment">//可缩</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(len&gt;right-left)<span class="comment">//找最小</span></span><br><span class="line">                {</span><br><span class="line">                    start=left;</span><br><span class="line">                    len=right-left;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> delete_value=s[left];</span><br><span class="line">                left++;<span class="comment">//易忘</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(delete_value))<span class="comment">//存在</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span>(window[delete_value]==need[delete_value])</span><br><span class="line">                    {</span><br><span class="line">                        valid--;</span><br><span class="line">                    }</span><br><span class="line">                    window[delete_value]--;</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(len==INT_MAX)<span class="keyword">return</span> <span class="string">""</span>;<span class="comment">//易忘</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>注意小部件：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(need.<span class="built_in">count</span>(deleteleft))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(window[deleteleft]==need[deleteleft])<span class="comment">//必须是先判断等于，因为这里的valid是一次性的。若后判断小于，则会出问题。</span></span><br><span class="line">{</span><br><span class="line">valid--;</span><br><span class="line">}</span><br><span class="line">window[deleteleft]--;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>类似的还有<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p><h4 id="常见环境：求窗口长度"><a href="#常见环境：求窗口长度" class="headerlink" title="常见环境：求窗口长度"></a><strong>常见环境：求窗口长度</strong></h4><p>注意窗口是<strong>左闭右开</strong>的，窗口长度一般是<code>right-left</code>。关键就是判断一下right此时是否在window</p><hr><h2 id="二、左右指针的常用算法（相向指针）"><a href="#二、左右指针的常用算法（相向指针）" class="headerlink" title="二、左右指针的常用算法（相向指针）"></a>二、左右指针的常用算法（相向指针）</h2><p>套路框架和二分差不多</p><h3 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a><strong>1、二分查找</strong></h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//右闭</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> mid = left+(right-left)&gt;&gt;<span class="number">1</span>;<span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="二分总结："><a href="#二分总结：" class="headerlink" title="二分总结："></a>二分总结：</h4><p><strong>左闭右闭是left小于等于right，如果右边更新则middle-1</strong></p><p><strong>最终原理就是right是否可能是target，左闭右闭自然是可能的。</strong></p><p><strong>口诀：是闭沾一（左闭left=middle+1，右闭right=middle-1），两闭相等（）</strong></p><p><strong>二分法的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这 就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><h5 id="二分法第一种写法"><a href="#二分法第一种写法" class="headerlink" title="二分法第一种写法"></a>二分法第一种写法</h5><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) { <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) {</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) {</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h5><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) { <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) {</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) {</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="不要求二分法的方案"><a href="#不要求二分法的方案" class="headerlink" title="不要求二分法的方案"></a>不要求二分法的方案</h5><p>C++ STL（标准模板库）中提供了封装的二分查找函数，它是 <code>std::binary_search</code> 和 <code>std::lower_bound</code> 和 <code>std::upper_bound</code> 这些函数。</p><ol><li>**bool**<code>std::binary_search</code> 函数用于检查容器中是否存在指定的元素。它返回一个布尔值，指示元素是否存在。如果元素存在，则返回 <code>true</code>，否则返回 <code>false</code>。示例用法如下：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="type">bool</span> exists = std::<span class="built_in">binary_search</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exists) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Element found!"</span> &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Element not found."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><code>std::lower_bound</code> 函数用于查找容器中<strong>大于或等于指定值的第一个元素的迭代器</strong>。它返回一个指向该元素的<strong>迭代器</strong>。<strong>如果没有大于或等于指定值的元素，则返回容器的 <code>end()</code> 迭代器</strong>。示例用法如下：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"First element greater than or equal to 3: "</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"No element greater than or equal to 3 found."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><code>std::upper_bound</code> 函数用于<strong>查找容器中大于指定值的第一个元素的迭代器</strong>。它返回一个指向该元素的<strong>迭代器</strong>。<strong>如果没有大于指定值的元素，则返回容器的 <code>end()</code> 迭代器</strong>。示例用法如下：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"First element greater than 3: "</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"No element greater than 3 found."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这些函数使得在有序容器中进行二分查找非常方便，可以帮助你快速定位元素并执行相关操作。</p><h5 id="左右指针模板（二分）"><a href="#左右指针模板（二分）" class="headerlink" title="左右指针模板（二分）"></a>左右指针模板（二分）</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//右闭</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> mid = left+(right-left)&gt;&gt;<span class="number">1</span>;<span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2、两数之和"><a href="#2、两数之和" class="headerlink" title="2、两数之和"></a><strong>2、两数之和</strong></h3><h3 id="3、反转数组"><a href="#3、反转数组" class="headerlink" title="3、反转数组"></a><strong>3、反转数组</strong></h3><h3 id="4、回文串判断"><a href="#4、回文串判断" class="headerlink" title="4、回文串判断"></a><strong>4、回文串判断</strong></h3><p>左右指针都可以仿照上面的模版</p>]]></content>
      
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和&amp;&amp;差分</title>
      <link href="/2023/10/04/qian-zhui-he-chai-fen/"/>
      <url>/2023/10/04/qian-zhui-he-chai-fen/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和专题"><a href="#前缀和专题" class="headerlink" title="前缀和专题"></a>前缀和专题</h1><p><strong>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。</p><p><strong>总结：下面题目基本上都是按照 前缀和presum[0]=0，presum[1]=第一个元素值</strong></p><p>在弄不清加一减一的时候，就想一下索引最大值</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="1、库函数优化"><a href="#1、库函数优化" class="headerlink" title="1、库函数优化"></a>1、库函数优化</h3><p>在C++中，可以使用STL（标准模板库）来优化前缀和的计算，特别是<strong>使用STL中的<code>partial_sum</code>函数</strong>。<code>partial_sum</code>函数可以快速计算数组的前缀和，而不需要手动编写循环来累加数组的元素。</p><p>以下是使用STL的<code>partial_sum</code>函数来计算前缀和的示例：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// 包含 partial_sum 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 partial_sum 计算前缀和</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">prefixSum</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    std::<span class="built_in">partial_sum</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), prefixSum.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印前缀和</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Prefix Sum: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : prefixSum) {</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上述示例中，我们首先包含了<code>&lt;numeric&gt;</code>头文件，其中包含了<code>partial_sum</code>函数。然后，我们创建一个与原始数组相同大小的<code>prefixSum</code>向量，并使用<code>partial_sum</code>函数计算前缀和，将结果存储在<code>prefixSum</code>中。最后，我们打印前缀和。</p><p>使用<code>partial_sum</code>函数可以让前缀和的计算更加简洁和高效，避免手动编写循环。这个函数非常适用于需要频繁计算前缀和的情况。</p><h3 id="2、经典写法"><a href="#2、经典写法" class="headerlink" title="2、经典写法"></a>2、经典写法</h3><h4 id="1-当presum-i-代表-nums-0-i-的前缀和时"><a href="#1-当presum-i-代表-nums-0-i-的前缀和时" class="headerlink" title="1)当presum[i] 代表 nums[0...i] 的前缀和时"></a>1)当<code>presum[i]</code> 代表 <code>nums[0...i]</code> 的前缀和时</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getPresum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">presum</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> presum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 nums[0...i] 的前缀和</span></span><br><span class="line">    presum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; presum.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        presum[i] = presum[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> presum;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRangeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; presum, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> presum[j];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> presum[j] - presum[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-当presum-i-代表-nums-0-i-1-的前缀和时-推荐"><a href="#2-当presum-i-代表-nums-0-i-1-的前缀和时-推荐" class="headerlink" title="2)当presum[i] 代表 nums[0...i-1] 的前缀和时(推荐)"></a>2)当<code>presum[i]</code> 代表 <code>nums[0...i-1]</code> 的前缀和时(推荐)</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getPresum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">presum</span><span class="params">(nums.size()+<span class="number">1</span>)</span></span>;<span class="comment">//presum[nums.size()]代表的是全nums数组的和</span></span><br><span class="line">    presum[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//便于计算前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> presum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 nums[0...i] 的前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; presum.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        presum[i] = presum[i - <span class="number">1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> presum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRangeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; presum, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> presum[j+<span class="number">1</span>] - presum[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; preSum;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//总共m行n列</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 构造前缀和矩阵</span></span><br><span class="line">        preSum = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">                <span class="comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">                preSum[i][j] = preSum[i<span class="number">-1</span>][j] + preSum[i][j<span class="number">-1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] - preSum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算子矩阵 [x1, y1, x2, y2] 的元素和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>{</span><br><span class="line">        <span class="comment">// 目标矩阵之和由四个相邻矩阵运算获得</span></span><br><span class="line">        <span class="keyword">return</span> preSum[x2+<span class="number">1</span>][y2+<span class="number">1</span>] - preSum[x1][y2+<span class="number">1</span>] - preSum[x2+<span class="number">1</span>][y1] + preSum[x1][y1];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>二维数组的前缀和一般都是从1索引开始，在计算一块区域的时候记住:<strong>二维数组前缀和，一般都从一开始。计算矩阵元素和，大的加一小不变（索引）。</strong></p><h1 id="差分数组专题"><a href="#差分数组专题" class="headerlink" title="差分数组专题"></a>差分数组专题</h1><p> <strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong></p><p>差分数组不能STL优化</p><p><strong><code>diff[i]</code> 就是 <code>nums[i]</code> 和 <code>nums[i-1]</code> 之差</strong>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> diff[nums.<span class="built_in">size</span>()];</span><br><span class="line"><span class="comment">// 构造差分数组</span></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>通过这个 <code>diff</code> 差分数组是可以反推出原始数组 <code>nums</code> 的，代码逻辑如下：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res[diff.<span class="built_in">size</span>()];</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>这样构造差分数组 <code>diff</code>，就可以快速进行区间增减的操作</strong>，如果你想对区间 <code>nums[i..j]</code> 的元素全部加 3，那么只需要<strong>让 <code>diff[i] += 3</code>，然后再让 <code>diff[j+1] -= 3</code></strong> 即可<strong>：</strong>因为只对区间 <code>nums[i..j]</code> 的元素全部加 3，[j+1… …]不变，如果 <code>diff[j+1]</code>不变， [j+1… …]也是加3</p><p><strong>原理很简单，回想 <code>diff</code> 数组反推 <code>nums</code> 数组的过程，<code>diff[i] += 3</code> 意味着给 <code>nums[i..]</code> 所有的元素都加了 3，然后 <code>diff[j+1] -= 3</code> 又意味着对于 <code>nums[j+1..]</code> 所有元素再减 3，那综合起来，就是对 <code>nums[i..j]</code> 中的所有元素都加 3 了</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; diff; <span class="comment">// 差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，接受一个初始数组 nums</span></span><br><span class="line">    <span class="built_in">Difference</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">assert</span>(nums.<span class="built_in">size</span>() &gt; <span class="number">0</span>); <span class="comment">// 确保输入数组不为空</span></span><br><span class="line">        diff = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">size</span>()); <span class="comment">// 初始化差分数组的大小</span></span><br><span class="line">        <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给闭区间 [i, j] 增加 val（可以是负数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        diff[i] += val; <span class="comment">// 更新差分数组的起始位置</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.<span class="built_in">size</span>()) {</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val; <span class="comment">// 更新差分数组的结束位置（注意边界检查）</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(diff.size())</span></span>; <span class="comment">// 初始化结果数组的大小</span></span><br><span class="line">        <span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2023/09/30/di-gui/"/>
      <url>/2023/09/30/di-gui/</url>
      
        <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=733411277&amp;bvid=BV1UD4y1Y769&amp;cid=915366282&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="500" padding-bottom:="" 56.25%="" high_quality="1" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe><p>​这个视频讲的很好，<strong>处理递归，核心就是千万不要想子问题的过程，你脑子能处理几层？马上就绕迷糊了。要想子问题的结果，思路就清晰了。</strong></p><p>​<strong>只要代码的边界条件和非边界条件的逻辑写对了，其他的事情交给数学归纳法就好了。也就是说，写对了这两个逻辑，你的代码自动就是正确的了，没必要想递归是怎么一层一层走的。</strong></p><p>我的想法是：<strong>明确递归函数的作用，坚定相信递归函数能做这件事。由此可以逻辑上分解做题思路。</strong>这是系统设计、网络设计上的常见思想。充分相信上层信息。</p><p>还有就是“回溯和递归是一套的，有一个递归就要有一个回溯”。不过很多回溯是隐性的。关键就是用递归分解问题，确定是否显性回溯。</p><p>留一个显性回溯的题目。</p><p><a href="https://leetcode.cn/problems/binary-tree-paths/description/">257. 二叉树的所有路径 - 力扣（LeetCode）</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231001184646709.png" alt="image-20231001184646709"></p><p><a href="https://www.programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><p><a href="https://www.zhihu.com/question/31412436/answer/683820765">对于递归有没有什么好的理解方法？ - 知乎 (zhihu.com)</a></p><p><strong>这篇把递归分三步</strong></p><p>①明确函数功能（以及参数和返回值），这点也是我想强调的。</p><p>②找到递归结束条件，这个在③后要再来一次，避免情况遗漏，很容易遗漏。</p><p>③<strong>找到函数的等价关系式</strong>，这个是作者提出的最难的部分，提出了一个观点（缩小参数的范围）。这个点也能覆盖住二叉树递归的情况。这一步类似于：“<strong>找到单层逻辑</strong>”。</p><p>记录一下圆桌会议：<a href="https://www.zhihu.com/roundtable/ruhexuehaoshujujiego">如何学好数据结构与算法 (zhihu.com)</a></p><iframe src="//player.bilibili.com/player.html?aid=428008124&amp;bvid=BV1nG411x77H&amp;cid=764491411&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="500" padding-bottom:="" 56.25%="" high_quality="1"> </iframe><p>不得不说这个labuladong的视频，真的解答了很多困惑。尤其是刷了三四天的二叉树合集之后。这个视频值得反复看。</p><p>【一周刷爆LeetCode，算法大神左神（左程云）耗时100天打造算法与数据结构基础到高级全家桶教程，直击BTAJ等一线大厂必问算法面试题真题详解】<a href="https://www.bilibili.com/video/BV13g41157hK?vd_source=4280d897d89a285191ff2a49582a555b">https://www.bilibili.com/video/BV13g41157hK?vd_source=4280d897d89a285191ff2a49582a555b</a></p><p>左程云+labuladong，配合食用。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231002212118059.png" alt="image-20231002212118059"></p><p><strong>前序是入栈，后序是出栈，中序是节点更换。N叉树没有中序遍历就是因为节点更换位置太多，不唯一。</strong></p><p><strong>只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。</strong></p><p><strong>所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候</strong>，那么进一步，你把代码写在不同位置，代码执行的时机也不同：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1.jpeg"></p><p><img src="https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%94%B6%E5%AE%98/2.jpeg"></p><p><strong>你可以发现每个节点都有「唯一」属于自己的前中后序位置</strong>，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。</p><p>这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。</p><p>说了这么多基础的，就是要帮你对二叉树建立正确的认识，然后你会发现：</p><p><strong>二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作</strong>。</p><p>你也可以看到，<a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/">图论算法基础</a> 把二叉树的遍历框架扩展到了图，并以遍历为基础实现了图论的各种经典算法，不过这是后话，本文就不多说了。</p><h3 id="两种解题思路"><a href="#两种解题思路" class="headerlink" title="两种解题思路"></a><strong>两种解题思路</strong></h3><p>前文 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/wo-de-shua-5fe0c/">我的算法学习心得</a> 说过：</p><p>**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/">回溯算法核心框架</a> 和 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/">动态规划核心框架</a>**。</p><p><code>Tip</code></p><p><code>这里说一下我的函数命名习惯：二叉树中用遍历思路解题时函数签名一般是 void traverse(...)，没有返回值，靠更新外部变量来计算结果，而用分解问题思路解题时函数名根据该函数具体功能而定，而且一般会有返回值，返回值是子问题的计算结果。</code></p><p><code>与此对应的，你会发现我在 [回溯算法核心框架](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 中给出的函数签名一般也是没有返回值的 void backtrack(...)，而在 [动态规划核心框架](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 中给出的函数签名是带有返回值的 dp 函数。这也说明它俩和二叉树之间千丝万缕的联系。</code></p><p><strong>虽然函数命名没有什么硬性的要求，但我还是建议你也遵循我的这种风格，这样更能突出函数的作用和解题的思维模式，便于你自己理解和运用。</strong></p><p>综上，遇到一道二叉树的题目时的通用思考过程是：</p><p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现。</p><p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</p><p><strong>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做</strong>。</p><h2 id="后序位置的特殊之处"><a href="#后序位置的特殊之处" class="headerlink" title="后序位置的特殊之处"></a>后序位置的特殊之处</h2><p>说后序位置之前，先简单说下中序和前序。</p><h2 id="中序位置主要用在-BST-场景中，你完全可以把-BST-的中序遍历认为是遍历有序数组。"><a href="#中序位置主要用在-BST-场景中，你完全可以把-BST-的中序遍历认为是遍历有序数组。" class="headerlink" title="中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。"></a><strong>中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。</strong></h2><h2 id="前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。"><a href="#前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。" class="headerlink" title="前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。"></a>前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。</h2><p>你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：</p><p><img src="https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%94%B6%E5%AE%98/2.jpeg"></p><p>这不奇怪，因为本文开头就说了前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。</p><h2 id="但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。"><a href="#但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。" class="headerlink" title="但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。"></a><strong>但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据</strong>。</h2><h2 id="那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。"><a href="#那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。" class="headerlink" title="那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。"></a><strong>那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</h2><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/image-20231002214509684.png" alt="image-20231002214509684"></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用move优化程序</title>
      <link href="/2023/09/30/yong-move-you-hua-cheng-xu/"/>
      <url>/2023/09/30/yong-move-you-hua-cheng-xu/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) {</span><br><span class="line">        <span class="keyword">if</span> (!root) {</span><br><span class="line">            <span class="keyword">return</span> {};</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="type">int</span> cnt = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) {</span><br><span class="line">                Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (Node* child: cur-&gt;children) {</span><br><span class="line">                    q.<span class="built_in">push</span>(child);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">move</span>(level));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></p><p>在这段代码中，<code>ans.push_back(move(level));</code> 中的 <code>move</code> 是用来将 <code>level</code> 向量的所有权从当前的 <code>level</code> 向量转移到 <code>ans</code> 向量中。这个操作有几个作用：</p><ol><li><p><strong>性能优化</strong>：<code>move</code> 操作会将 <code>level</code> 的内部数据指针转移给 <code>ans</code>，而不是进行复制操作。这可以节省内存和提高性能，特别是当 <code>level</code> 向量包含大量数据时。</p></li><li><p><strong>清空 <code>level</code> 向量</strong>：通过执行 <code>move</code> 操作，<code>level</code> 向量将变为空，这有助于释放 <code>level</code> 中的内存，防止内存泄漏或不必要的资源占用。</p></li><li><p><strong>语义上的标记</strong>：使用 <code>move</code> 可以清晰地表示 <code>level</code> 向量已经不再需要，因为它的内容已经被转移到 <code>ans</code> 向量中。这有助于防止在后续代码中意外修改 <code>level</code> 向量。</p></li></ol><p>总之，<code>move(level)</code> 是为了将 <code>level</code> 向量的所有权转移到 <code>ans</code> 向量，以提高性能、释放内存并明确表示 <code>level</code> 向量不再需要。这在处理大型数据结构或需要优化内存使用的情况下特别有用。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础学习(无框架)</title>
      <link href="/2023/09/28/java-ji-chu-xue-xi-wu-kuang-jia/"/>
      <url>/2023/09/28/java-ji-chu-xue-xi-wu-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p><strong>C&amp;C++更多是造轮子的，java更多是用轮子的。</strong></p><p><a href="https://javaguide.cn/">Java 面试指南 | JavaGuide(Java面试 + 学习指南)</a></p><p><strong>学习路线：基本语法+网络+并发（学习go语言后可以不看）+框架（Springboot）</strong></p><p><strong>看的书里面推荐了Swing框架，但是目前来看，并不推荐学。可以学Spring</strong></p><p><strong>Java的很多API都提供了异常处理</strong></p><p><strong><img src="D:/桌面/media/41d57f251770c4f4149e339c6fdd966e.png"></strong></p><p><strong><img src="D:/桌面/media/bdf617ad4e5c8f23dbbbe8536be34858.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/314bf4a47592c553174d4a72856f7c69.png"></strong></p><p><a href="https://www.w3cschool.cn/java/java-exceptions.html">Java 异常处理_w3cschool</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f5a1ac74c8d90c29141523f011437885.jpeg"><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/78d75271aa7cfe01a58c0f619fae2a5c.png"></strong></p><p><strong>注意，非检查异常实际上是默认使用的（即使不去声明，也会一直在使用）。非检查的异常是由糟糕的编程导致的。</strong></p><p><strong><img src="D:/桌面/media/771c1d9f17b248503796f2d5f763db10.png"></strong></p><p>Java的异常处理是try,catch,finally。比C++多了个finally。finally可以<strong>保证Java程序不管发生什么异常，总会使代码照常执行</strong>，这是对Java异常处理块的最佳补充。还有一点值得一提就是，finally可以维护对象的内部状态，还可以清理非内存资源。如果不使用finally就必须编写代码来释放那些非内存资源。</p><p>在c++中，所有类型(包括原语和指针)都可以作为异常抛出（throw）。但是在Java中，只有可抛出对象(Throwable对象是Throwable类的任何子类的实例)可以作为异常抛出。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4ce2c5332db24fb642a6c1f99f6de8c8.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e601d2ca3a003fc552a24a377c6c6acc.png"></p><p><strong>throw的用法是throw new 异常处理类（“异常处理语句”）</strong></p><p><img src="D:/桌面/media/36932d8aace7609f4b8ddbb91cdbc8b1.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e5eef9a5444066ac28738e557a04a1cc.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/13137dfcbb09385386337b0a24843650.png"></p><p><a href="https://blog.csdn.net/MrYushiwen/article/details/109814008">(108条消息) Java异常处理详解(全文干货，写得非常全，值得收藏)_java 异常_MrYuShiwen的博客-CSDN博客</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f16936cac31dce5170ec4e321dffde6b.png"></p><p><img src="D:/桌面/media/9570f9e4678ab6da0ff756a56a702cd7.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0797936faf8dd6cbe01370de827eaf97.png"></p><p><a href="https://zhuanlan.zhihu.com/p/99770142">2020 年最棒的 9 个 Java 框架，哪个最香？ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/yoyo31/article/details/117994678#:~:text=10%E7%A7%8D%E6%B5%81%E8%A1%8C%E7%9A%84Java%E6%A1%86%E6%9E%B6%201%201.Spring%20%E8%BF%99%E6%98%AF%E5%85%B6%E4%BB%96Java%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%BB%9D%E5%AF%B9%E9%A2%86%E5%AF%BC%E8%80%85%E3%80%82%20%E6%8E%8C%E6%8F%A1Spring%E6%98%AFJava%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E8%81%8C%E4%BD%8D%E6%9C%80%E6%99%AE%E9%81%8D%E7%9A%84%E8%A6%81%E6%B1%82%E4%B9%8B%E4%B8%80%E3%80%82%20...%202%202.Play,MyBatis%20...%208%208.Struts%20Struts%E6%98%AF%E7%94%A8%E4%BA%8E%E5%88%9B%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7Java%20Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E6%BA%90MVC%EF%BC%88%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE-%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89%E6%A1%86%E6%9E%B6%E3%80%82%20...%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE">(108条消息) 10种流行的Java框架_最受欢迎服务器框架_普通网友的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/49893350">Java中的内部类 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/zhao_miao/article/details/83245816">(108条消息) Java内部类的定义、如何创建内部类、内部类的分类、内部类与外部类的关系_java创建内部类_zhao_miao的博客-CSDN博客</a><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d1751b38bdd2f321b938ddd7d4f96719.png"></p><p><strong>内部类可以分为四种：</strong></p><ol><li>实例内部类（成员内部类）：直接定义在类当中的一个类，在类前面没有任何一个修饰符 （这种内部类相当于是外部类的一个对象，它的对象需要用外部类对象new出来），内部类可以访问所有外部类成员（包括private），但是外部类方法不能访问内部类的成员。实例内部类必须依赖于外部类，<strong>需要用外部类的对象创建内部类的对象</strong>。非内部类不能被声明为private或protected访问类型。这个是要考虑到内部类的向上转型为接口 可以完全隐藏内部类的具体实现。外部提供一个接口，就可以有多个内部类以不同的方式实现。这个是一般的类实现不了的。成员内部类内部<strong>不允许存在任何static变量或方法</strong> 正如成员方法中不能有任何静态属性 （成员方法与对象相关、静态属性与类有关）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9a3dc0ab2eb711f6a93238febfe5cd54.png"></p><p>如果在外部类中定义的成员变量与内部类的成员变量名称相同，可以使用this关键字（感觉应该不推荐这么做）</p><p><img src="D:/桌面/media/b51d83c5c27d804f63cd3c4f4b53a850.png"></p><ol><li>静态内部类：在内部类前面加上一个static</li></ol><p>静态内部类不可以使用任何外部类的非static类（包括属性和方法），但可以存在自己的成员变量</p><ol><li>局部内部类：定义在方法的内部类</li></ol><p>方法内部类<strong>不允许使用访问权限修饰符</strong>（public、private、protected）均不允许</p><p>方法内部类对外部完全隐藏，<strong>除了创建这个类的方法可以访问它以外，其他地方均不能访问</strong> (换句话说其他方法或者类都不知道有这个类的存在)方法内部类对外部完全隐藏，出了创建这个类的方法可以访问它，其他地方均不能访问。</p><p>方法内部类如果<strong>想要使用方法形参</strong>，该形参必须使用final声明（JDK8形参变为隐式final声明）。（如果需要在方法体中使用局部变量，该局部变量需要被设置为final类型，换句话说，<strong>在方法中定义的内部类只能访问方法中final类型的局部变量</strong>，这是因为在方法中定义的局部变量相当于一个常量，它的生命周期超出方法运行的生命周期，由于该局部变量被设置为final，所以<strong>不能在内部类中改变该局部变量的值</strong>）</p><p><img src="D:/桌面/media/d0d80297a2e199be795f338ec00858f6.png"></p><ol><li>匿名内部类：属于局部内部的一种特殊情况</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/602c28b2e2930688497afb10996716a7.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4d37889b3ca52b1b97d2393e5e46984f.png"></p><p>类包的主要作用是解决类的同名问题，便于代码复用。Java包通常是第一行代码（package …），而且应该全部使用小写字母。</p><p>在使用import关键字时，可以指定类的完整描述，如果为了使用包中更多的类，可以在使用import关键字指定时在包指定后加上*，这表示可以在程序中使用包中的所有类。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a598327663eaaa15e0a870649420c120.png"></p><p>final关键字修饰基本数据类型时，其值不可变。final关键字修饰引用类型时，指向不可变。类似于C++的const。const *是指向的值不可变，*const是指向不可变。C++的引用是*const即指针常量</p><p>在Java中定义全局常量，通常使用public static final修饰，这样的常量只能在定义时被赋值。</p><p><a href="https://blog.csdn.net/yyhhlancelot/article/details/81531940">(108条消息) C++ 继承与java继承之区别_yyhhlancelot的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_45707610/article/details/124980431?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-124980431-blog-123145312.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-124980431-blog-123145312.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=1">(108条消息) JAVA与C++的区别详解_c++和java_xiaoweids的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/tsingke/article/details/109153565?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-109153565-blog-81531940.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-109153565-blog-81531940.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=3">(108条消息) Java与C、C++的10大区别-总结_Tsingke的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/HD243608836/article/details/78060704">java中函数覆盖（即重写override），子类的返回类型一定要和父类一样吗？_子类返回值类型必须与父类相同吗_HD243608836的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/71576194#:~:text=1%20%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E8%A6%81%E6%B1%82%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E5%BF%85%E9%A1%BB%E4%B8%80%E8%87%B4%EF%BC%8C%E8%80%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E8%A6%81%E6%B1%82%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E5%BF%85%E9%A1%BB%E4%B8%8D%E4%B8%80%E8%87%B4%E3%80%82%202%20%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E8%A6%81%E6%B1%82%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%BF%85%E9%A1%BB%E4%B8%80%E8%87%B4%EF%BC%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%AF%B9%E6%AD%A4%E6%B2%A1%E6%9C%89%E8%A6%81%E6%B1%82%E3%80%82%203,%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%8F%AA%E8%83%BD%E7%94%A8%E4%BA%8E%E5%AD%90%E7%B1%BB%E8%A6%86%E7%9B%96%E7%88%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E7%94%A8%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%EF%BC%88%E5%8C%85%E6%8B%AC%E4%BB%8E%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%89%E3%80%82%204%20%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%AF%B9%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%92%8C%E6%8A%9B%E5%87%BA%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9C%89%E7%89%B9%E6%AE%8A%E7%9A%84%E8%A6%81%E6%B1%82%EF%BC%8C%E8%80%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%9C%A8%E8%BF%99%E6%96%B9%E9%9D%A2%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E9%99%90%E5%88%B6%E3%80%82%205%20%E7%88%B6%E7%B1%BB%E7%9A%84%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%8F%AA%E8%83%BD%E8%A2%AB%E5%AD%90%E7%B1%BB%E8%A6%86%E7%9B%96%E4%B8%80%E6%AC%A1%EF%BC%8C%E8%80%8C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%89%80%E6%9C%89%E7%9A%84%E7%B1%BB%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E8%BD%BD%E5%A4%9A%E6%AC%A1%E3%80%82">Java继承中的方法覆盖、重载（及实例化对比） - 知乎 (zhihu.com)</a></p><p><strong>在Java中使用extends关键字来标识两个类的继承关系，显然java只能实现单一继承。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/ed346947b00cdf82496615cc1f252b16.png"></strong></p><p><strong>在子类中可以连同初始化父类构造方法来完成子类初始化操作，既可以在子类的构造方法中使用super()语句调用父类的构造方法，也可以在子类中使用super关键字调用父类的成员方法等。但是子类没有权限调用父类中被修饰为private的方法，只可以调用父类中修饰为public或protected的成员方法</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/26d8aa9705c6df463102add2e1f87018.png"></strong></p><p><strong>当重写父类方法时，修改方法的修饰权限只能从小的范围到大的范围改变，例如，父类中的doSomething()方法的修饰权限为protected，继承后子类中的方法doSomething()的修饰权限只能修改为public，不能修改为private</strong></p><p><strong>（这里的重写指的是函数覆盖）java函数覆盖的条件有点儿多</strong></p><p><strong>覆盖必须满足一个对象向上转型为它的基本类型并调用相同方法这样一个条件</strong></p><p><strong>在实例化子类对象时，父类无参构造方法将被自动调用。有参构造方法不能被自动调用，用户只能使用super关键字显式地调用父类的构造方法。（从最顶级父类开始构造）</strong></p><p><strong>Java有一点特殊，所有类都是Object的子类（直接或者间接，不声明extends的都是直接子类）。所以所有类都可以使用或者重写Object中的一些方法（主要包括clone()、finalize()、equals()、toString()等方法，其中常用的两个方法为equals()和toString()方法）</strong></p><p><strong>在使用String对象时，应该注意运算符“==”比较的是对象的引用地址，equals()方法是比较内容。但是在自定义类中，equals()默认的也是比较引用地址，需要使用的话，应该自己重写一下。</strong></p><p><strong>类的对象的向上转型总是安全的，但是向下转型就会出现很多问题（而且要注意，必须显式类型转换）。</strong></p><p><em>// 向上转型：将父类引用指向子类对象</em></p><p>Father f = new Son();</p><p>f.sleep();//<em>输出“爸爸睡觉”</em></p><p><em>// 向下转型</em></p><p>Father f = new Son();</p><p>((Son)f).P();<em>//输出“儿子调皮”</em></p><p><img src="D:/桌面/media/2922d7751d5e09d83b2248e9d9de40ce.png"></p><p><a href="https://blog.csdn.net/HuoYiHengYuan/article/details/84855069">(108条消息) Java向上转型和向下转型的通俗简单理解以及使用用途_java中向上转型和向下转型的作用_苏一恒的博客-CSDN博客</a></p><p><strong>Java函数重载还有多态（父类兼容子类，子类不兼容父类）等方面跟C++还是差不多的。但是抽象的关键词从virtual变成了abstract，可以给类名前面加上这个关键词声明，抽象方法不能有方法体，只要有抽象方法就是抽象类（但是抽象类不一定要有抽象方法）。</strong></p><p><strong>由于java的类只接受单一继承，所以支持多继承的接口应运而生。接口更倾向于特定功能的实现，类的继承更倾向于从属关系。接口相当于纯抽象类，接口的所有方法都没有方法体。接口的变量只能是而且默认是public static final类型，接口的方法只能是public，而且默认是public abstract类型。在接口中定义的任何字段都自动是static和final的。</strong></p><p><strong>接口用interface关键字定义，使用接口的时候用implements关键字。接口的多重继承用逗号隔开</strong></p><p><strong><img src="D:/桌面/media/491fd6e04672c46211bce82d81ccbf7f.png"></strong></p><p><a href="https://www.cnblogs.com/dolphin0520/p/3811437.html">深入理解Java的接口和抽象类 - Matrix海子 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq_44543508/article/details/102609910">(108条消息) java抽象类（abstract）与接口（Interface）的区别_抽象类和接口的区别_宜春的博客-CSDN博客</a></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1908def5606690cb95a5574b4ad7a7d6.png"></strong></p><p><strong>上图的第五点已经变了，现在接口可以有静态方法，但是不能继承只能调用。</strong></p><p><strong>Java自带的大数运算、高精度运算是一个非常亮眼的特点。BigInteger类是针对大整数的处理类，而BigDecimal类则是针对大小数的处理类。BigInteger类支持任意大小的整数，BigDecimal扩展支持了小数。</strong></p><p><strong>初学者应该记不全这些函数，只需要记住类就好，然后Ctrl+N查找这些类，那里能看到使用方法。</strong></p><p><strong>Java有一种叫做包装类的东西：Java是可以直接处理基本类型的，但在有些情况下需要将其作为对象来处理，这时就需要将其转换为包装类。基本类型到包装类，基本类型基本上都是小写，转换成包装类就转换成大驼峰（基本类型不是复合词，所以只要首字母大写就行了）。除了int是变成Integer，char是变成Character</strong></p><p><strong>抽象类Number是BigDecimal、BigInteger、Byte、Double、Float、Integer、Long和Short类的父类</strong></p><p>无论是C++还是Java，只要有两个迭代器，表示开头和结尾，所指示范围都是不包括结尾那个元素</p><p>在Java中使用java.text.DecimalFormat格式化数字。在Java中没有格式化的数据遵循以下原则：</p><p>如果数据绝对值大于0.001并且小于10000000，使以常规小数形式表示。</p><p>如果数据绝对值小于0.001或者大于10000000，使用科学记数法表示。</p><p><img src="D:/桌面/media/060abbc6d725a20eb261d3b0d33d0c7e.png"></p><p>在Math类中存在一个random()方法，用于产生随机数字。这个方法默认生成大于等于0.0且小于1.0的double型随机数，即0&lt;=Math.random()&lt;1.0</p><p>与C&amp;C++需要手动释放内存不同，Java有垃圾回收机制，用户不必担心废弃的对象占用内存，垃圾回收器会自动回收无用却占用内存的资源。<strong>但是垃圾回收机制只能回收用new操作符创建的对象</strong></p><p>var这个数据类型相当于C++的auto，但是并不推荐使用</p><p>Java没有地址传递，只有值传递</p><p><a href="https://blog.csdn.net/demo_yo/article/details/115984217">(106条消息) java实现swap函数的几种方案_java swap_Whitemeen太白的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/bjweimengshu/article/details/79799485">(106条消息) 为什么说Java中只有值传递_程序员小灰的博客-CSDN博客</a>这个解释比较清楚</p><p>最简单的实现应该就是借助数组进行交换</p><p><strong>注意，JAVA中大小写非常严格</strong></p><p><a href="https://blog.csdn.net/kuangay/article/details/81485324">(105条消息) Java static关键字详解_Cappuccinooo的博客-CSDN博客</a></p><p>Java常见的static跟C++中的作用大部分一样（但是java的static不会改变访问权限），声明为静态，可以在没有对象（不依赖于对象）的情况下直接调用，静态函数只能使用静态成员。所以，<strong>如果想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。</strong></p><p><strong>最常见的静态方法就是main方法，这就是为什么main方法是静态方法就一目了然了，因为程序在执行main方法的时候没有创建任何对象，只有通过类名来访问。</strong></p><p>局部变量不可以声明为static</p><p>类的地方，略有不同。Java中引入了“包”的概念</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7127c0bffe4685b1b9c2463390d2d7b6.png"></p><p>当声明类时不使用public、protected和private修饰符设置类的权限，则这个类预设为<strong>包存取范围</strong>，即只有一个包中的类可以调用这个类的成员变量或成员方法。<strong>Java语言规定，类的权限设定会约束类成员的权限设定</strong></p><p>注意switch语句在C++和java中有区别，C++的switch不支持字符串，但是java支持。C++要想用字符串就借助constexpr</p><p>Java中也有遍历元素的操作，与C++不同，C++是for(auto i:array);java是for(int i:array)，即java是具体类型。Java的forEach方法实现同样功能。</p><p>C++字符串比较是用strcmp，java字符串比较是用compareTo方法</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/51f47a442a799a51406be37ce154a3d6.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f384a9ca41362766f8b2acfa49e76b88.png"></p><p><img src="D:/桌面/media/3816ef8a8e4f5040ca4bd7150d24dae9.png"></p><p>三个双引号在java里面是文本块，必须使用一个换行</p><p>方法是小驼峰，类和文件是大驼峰</p><p>常量名（final）一般用全大写字母表示，当定义的final变量属于“成员变量”时，必须在定义时就设定它的初值，否则将会产生编译错误</p><p>同包的方法不需要import导入，在IDEA中ctrl+N是查询方法快捷键。</p><p>Java.lang不需要导入，包含常见的Math和String等</p><p>将class文件打包为jar文件，可以用命令行运行jar</p><p><strong>Springboot:这个使用中涉及到了JS和HTML</strong></p><p>使用 向导 或者Spring Initializr，获取Maven包，解压并添加模块，/src/main/java里面运行，可以运行一个服务器。使用浏览器localhost:8080（<a href="http://localhost:8080）访问这个服务器。">http://localhost:8080）访问这个服务器。</a></p><p>JS里面反引号``也表示拼接，了解就行</p><p>注解是必须的</p><p><a href="http://localhost:8080/add?%E5%8F%82%E6%95%B01=%E5%80%BC1&amp;%E5%8F%82%E6%95%B02=%E5%80%BC2">http://localhost:8080/add?参数1=值1&amp;参数2=值2</a></p><p><a href="https://zhuanlan.zhihu.com/p/634522077">Java 容器详解：使用与案例 - 知乎 (zhihu.com)</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d301f8bc08d4bc80a26ad101fe1be4b7.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2babc362e8965f9a0bff69dc6d7aaa21.png"></p><p><img src="D:/桌面/media/d0b7053582bd2802e0ca117d734c33ce.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/672901a72ce5cf778b0648ff8a09d720.jpeg"></p><p><strong>注意：Map没有继承Collection接口</strong></p><p>java.util包中提供了一些集合类，这些集合类又被称为容器。提到容器不难想到数组，集合类与数组的不同之处是，数组的长度是固定的，集合的长度是可变的；数组用来存放基本类型的数据，<strong>集合用来存放对象的引用</strong>。常用的集合有List集合、Set集合和Map集合，其中List与Set继承了<strong>Collection接口</strong>，各接口还提供了不同的实现类。上述集合类的继承关系如上图所示。</p><p><img src="D:/桌面/media/6900bee42772bf8b60bf0e9f15d1cdc9.png"></p><p>Java也有迭代器，是这么用的：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/21c9e227d386aa314fe0e187fa7164cb.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/180d099ef672c9b8fdf45cceefdf5a12.png"></p><p>C++的迭代器是这么用的：</p><p><img src="D:/桌面/media/16ae9edf917f46fc03f648059217f3a3.png"></p><p>Java 的迭代器有两个重要的函数 ①boolean hasNext（）②对象 next（）</p><p>容器的特点基本上与C++保持一致</p><p><img src="D:/桌面/media/6fcda427ce90e0815ec9ca90c1cd6ad9.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e4d416ca0ae78e5308f870e3b7e404f5.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1c1f1cdcfa102341d4ec03f9299fa2e6.png"></p><p>存入TreeSet类实现的Set集合必须实现Comparable接口，该接口中的compareTo(Object o)方法比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、0或正整数。</p><p>headSet()、subSet()、tailSet()方法截取对象生成新集合时是否包含指定的参数，可通过如下方法来判别：如果指定参数位于新集合的起始位置，则包含该对象，如subSet()方法的第一个参数和tailSet()方法的参数；如果指定参数是新集合的终止位置，则不包含该参数，如headSet()方法的入口参数和subSet()方法的第二个入口参数。</p><p><img src="D:/桌面/media/d5bc44e9a80f38110649fc3a3d3df33e.png"></p><p>Map集合中允许值对象是null，而且没有个数限制。例如，可通过“map.put(“05”,null);”语句向集合中添加对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0be754c793a31c899940e42d06adc81c.png"></p><p>Java语言定义了许多类专门负责各种方式的输入／输出，这些类都被放在java.io包中。其中，所有输入流类都是抽象类InputStream（字节输入流）或抽象类Reader（字符输入流）的子类；而所有输出流都是抽象类OutputStream（字节输出流）或抽象类Writer（字符输出流）的子类。</p><p><img src="D:/桌面/media/b4debbec758d594ed152dd6e6a185173.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/8c93b55b9ab6be6e12b8511108ff9bad.png"></p><p>并不是所有的InputStream类的子类都支持InputStream中定义的所有方法，如skip()、mark()、reset()等方法只对某些子类有用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习（无框架）</title>
      <link href="/2023/09/28/python-ji-chu-xue-xi-wu-kuang-jia/"/>
      <url>/2023/09/28/python-ji-chu-xue-xi-wu-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p>因为是以前的PDF转的Markdown,很多图片在上传图床的时候出了问题，暂时没有想到好的解决办法，将就一下吧</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/03ef78595848ed93ebf0db0171cf3d95.png"></p><p>注意<strong>函数不能修改不可变对象</strong>，C++的swap在python里面是一句a,b=b,a</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/fb4a7202372fc8f46b0d33bbb0e5e1cd.png"></p><p>Python不适合大工程，但是做小型项目就非常快。web推荐Django(好处是全面)，Flask（轻量）。桌面的话就推荐PyQt。</p><p>字符串不可改变，只能换新。<strong>split()<strong>可以基于指定分隔符将字符串分隔成多个子字符串(存储到列表中)。如果不指定分隔符，则</strong>默认使用空白字符(换行符/空格/制表符)。</strong></p><p><strong>join（）</strong>的调用对象是“分隔符”，参数是字符串列表。</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/521dbeefac9c8dec33977701045d8acf.png"><img src="D:/桌面/media/2dee1a946c2d645d64338f0324a2d0f5.png"></strong></p><p><strong>变量在栈内存，对象在堆内存，变量是对象的引用（地址）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/69696b15fa732f3728d6d2563437f3a1.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/eae1a4e6e2c4b3a046a4af953794351f.png"></p><p>常量字符串也相当于缓存</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/fde29955aa45ea9ab8c9446961b6bccb.png"></p><p>is对比id，==调用equal</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f08621679d95377e3dc1bc261de1f283.png"></p><p><img src="D:/桌面/media/a7dff5ee018135538cc1c8c4b0e88eda.png"></p><p><a href="https://blog.csdn.net/weixin_38981172/article/details/90176525">python中的各种符号（欢迎补充）_python符号大全_杉木人的博客-CSDN博客</a></p><p>Python的很多语法接近java。Python里面没有long，int可以无限大 。//是地板除，结果是整数。**是幂的意思。python里面没有单字符类型char，python里面单个字符也是字符串类型</p><p><a href="https://blog.csdn.net/moqisaonianqiong/article/details/114674204">python中format用法（最全汇总）_python语言format用法_西部点心王的博客-CSDN博客</a></p><p>Python里面去掉了很多C++和java的格式，<strong>用缩进和冒号代替了大括号（千万不要忘记冒号）</strong>，缩进是区分大括号内容的重要参考，语句之间不需要分号隔开了</p><p>注释的区别：在Python中，<strong>使用“#”作为单行注释的符号</strong>。从符号“#”开始直到换行为止，其后面所有的内容都作为注释的内容而被Python编译器忽略。多行注释是三引号（单引号或双引号都可以），在Python中，三引号（’’’……’’’）或者（”””……”””）是字符串定界符。所以，如果三引号作为语句的一部分出现，那么就不是注释，而是字符串。在JS中三引号有着同样的作用。</p><p><img src="D:/桌面/media/55ab63cdad4c7db3f48daa60492e00a7.png"></p><p>有一个链式赋值可以注意一下。</p><p>Python代码规范：函数、类的属性和方法、包名全小写。类名大驼峰。内部类类名_大驼峰。常量名是全大写</p><p>使用单下划线“_”开头的<strong>模块变量或者函数是受保护的</strong>，在使用import*from语句<strong>从模块中导入时这些变量或者函数不能被导入</strong>。</p><p>使用双下划线“__”开头的<strong>实例变量或方法是类私有的</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/5b3157cc5b1a36bcf58ca28c4712efaf.png"></p><p>Python的索引很神奇，允许是负数，-1就是最后一个元素，0是第一个元素，也就是循环<img src="D:/桌面/media/38b1d47d4916fe53e189174efd79f089.png"></p><p>如果想要复制整个序列，可以将start和end参数都省略，但是中间的冒号需要保留。例如，sname[:]就表示复制整个名称为sname的序列。</p><p>序列支持相同类型（序列类型，不是数据类型）相加。序列支持乘法（仅限与整数型），在Python中，使用数字n乘以一个序列会生成新的序列。新序列的内容为原来序列被重复n次的结果</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/69b6873d84fb6243d87a868a2434c391.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3056c83a7c1995b9119af3bbc2de8393.png"></p><p><img src="D:/桌面/media/b8143fb754253c08bc023cf18742b72b.png"></p><p><img src="D:/桌面/media/e2a7467582549419d5ef7d0a4fe7085c.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/99845659f5e2ea9a4b25586b1f877c89.png"></p><p>列表的使用非常灵活，可放进任意类型，同一个列表可容纳不同类型。用中括号括起来。</p><p>在使用列表时，虽然可以将不同类型的数据放入同一个列表中，但是通常情况下，我们不这样做，而是在一个列表中只放入一种类型的数据。这样可以提高程序的可读性。</p><p>使用list()函数不仅能通过range对象创建列表，还可以通过其他对象创建列表。</p><p>print(列表名)在输出列表时，是包括左右两侧的中括号的。</p><p>元组是不可变的列表（不可变是指单个元素不可修改，只能对整个元组进行重新赋值）。列表是中括号，元组是圆括号。元组的访问速度更快，元组可以作为字典的键，但是列表就不行</p><p>字典类似于C++和java的map，但是字典是无序的，java 的map是一个接口，有有序的也有无序的。<strong>字典用花括号，键与值之间用冒号：隔开</strong></p><p>注意一下，dict（）和zip（）</p><p>enumerate()函数用于将一个<strong>可遍历的数据对象（如列表或元组）</strong>组合为一个索引序列，同时<strong>列出数据下标和数据</strong>，一般在for循环中使用。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/324a8226693add7cdddb4e491590735e.png"></p><p><strong>Python的保留字和标识符是严格区分大小写</strong></p><p><strong>Python中以下划线开头的标识符有特殊意义，一般应避免使用相似的标识符。</strong></p><p><strong>①以单下划线开头的标识符（如_width）表示不能直接访问的类属性，另外，也不能通过from xxx import *导入；</strong></p><p><strong>②以双下划线开头的标识符（如__add）表示类的私有成员；</strong></p><p><strong>③以双下划线开头和结尾的是Python里专用的标识，例如，<strong>init</strong>()表示构造函数。</strong></p><p>在Python语言中允许使用汉字作为标识符，如“我的名字=”明日科技””，在程序运行时并不会出现错误（如图2.17所示），但<strong>建议读者尽量不要使用汉字作为标识符</strong>。</p><p>在Python中，<strong>不需要先声明变量名及其类型，直接赋值即可创建各种类型的变量</strong>。需要注意的是，对于变量的命名并不是任意的，应遵循以下几条规则。</p><ol><li>变量名必须是一个有效的标识符；</li><li>变量名不能使用Python中的保留字；</li><li>慎用小写字母i和大写字母O；</li><li>应选择有意义的单词作为变量名。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/5a86591ffecb35716bbd2bbf2250b7c1.png"></p><p>这跟java和C++都不一样，它们都需要声明类型。</p><p>Python是动态类型的语言（也称为弱类型语言），不需要像Java或者C语言一样在使用变量前必须先声明变量的类型。虽然Python不需要先声明变量的类型，但有时仍然需要用到类型转换。例如a=100是整型，在Java里面可以print(“hello”+a)，但是在python就是错的，print(“hello”+str（a）)这样才对</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/128ea372360a3032345e4825b75a56ce.png"></p><p>另外，<strong>Python是一种动态类型的语言</strong>，也就是说，<strong>变量的类型可以随时变化</strong>。例如，在IDLE中，创建变量nickname，并赋值为字符串“碧海苍梧”，然后输出该变量的类型，可以看到该变量为字符串类型，再为变量赋值为数值1024，并输出该变量的类型，可以看到该变量为整型。在Python语言中，<strong>使用内置函数type()可以返回变量类型</strong>。</p><p>在Python中，<strong>允许多个变量指向同一个值</strong>。将两个变量都赋值为数字2048，再分别应用内置函数id()获取变量的内存地址，将得到相同的结果。在Python语言中，<strong>使用内置函数id()可以返回变量所指的内存地址</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9a93575f55d0a91a996456c8fd66252b.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0b9d520320aca530fd4089c0457d5073.png"></p><p><img src="D:/桌面/media/8fe797b6eb248716345214123f839cf6.png"></p><p>Python的print和java的println一样，是自动换行的</p><p>注意，python没有switch语句。for语句也有一些不一样</p><p><img src="D:/桌面/media/92508e2d275ff63cea0f899efe7f0e12.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/863b02ba481b7d019e2325d8ead1f5e3.png"></p><p><img src="D:/桌面/media/f1db99fac41d62bcae3b4ae9b6de983d.png"></p><p>在保留了break和continue之外，Python多了一个代表doNothing的pass语句</p><p><img src="D:/桌面/media/2ffae691893dc0be9750bdb1fa5367de.png"></p><p>在Python里面没有提供定义 常量的保留字，不过在PEP 8规范中定义了常量的命名规范为大写字母和下划线组成，但是在实际项目中，常量首次赋值后，还是可以被其他代码修改。</p><p>在python中，前缀区分进制：</p><p>十进制开头不能是0，二进制是只有1或者0<br>在Python 3.x中，对于八进制数，必须以0o/0O开头</p><p>十六进制必须以0X或0x开头。</p><p>Python将数值转化为字符串的函数是str(arg)</p><p>Python里面有一个复数类型。Python中的复数与数学中的复数的形式完全一致，都是由实部和虚部组成，并且使用j或J表示虚部。当表示一个复数时，可以将其实部和虚部相加，例如，一个复数，实部为3.14，虚部为12.5j，则这个复数为3.14+12.5j。</p><p>在Python中，字符串属于不可变序列，通常使用单引号“’’”、双引号“”””或者三引号“’’’ ‘’’”或“”””””””括起来。这三种引号形式在语义上没有差别，只是在形式上有些差别。其中单引号和双引号中的字符序列必须在一行上，而三引号内的字符序列可以分布在连续的多行上</p><p>其中，str表示Unicode字符（ASCII或者其他）；bytes表示二进制数据（包括编码的文本）。这两种类型的字符串不能拼接在一起使用。通常情况下，str在内存中以Unicode表示，一个字符对应若干个字节。但是如果在网络上传输，或者保存到磁盘上，就需要把str转换为字节类型，即bytes类型。</p><p>Python的startswith、endswith函数与java的startsWith、endsWith函数是一样的</p><p>函数定义时参数列表中的参数就是形式参数，而函数调用时传递进来的参数就是实际参数，就像剧本选主角一样，剧本的角色相当于形式参数，而演角色的演员就相当于实际参数。</p><p><strong>当实际参数为不可变对象时，进行的是值传递；当实际参数为可变对象时，进行的是引用传递。这个看后面的解释比较好，按照栈内存和堆内存区分</strong></p><p>值传递和引用传递的基本区别就是，进行值传递后，改变形式参数的值，实际参数的值不变；而进行引用传递后，改变形式参数的值，实际参数的值也一同改变。</p><p>定义函数时，为形式参数设置默认值要牢记一点：默认参数必须指向不可变对象。</p><p><img src="D:/桌面/media/aa723b6d69286e768c13aca610fd290a.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b5b34040403c38b50498bf3e2534f3f2.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/34f5eb856589e3e9db1fd61222214952.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/33c977ed9328da06844b3095188c49e7.png"></p><p><img src="D:/桌面/media/89414341722e7044822b003c1c246fbf.png"></p><p>记住*参数是元组，**参数是字典</p><p>Python里面用global关键字修饰全局变量</p><p>Python类名使用“大驼峰命名法”</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7de5e29e56fb8f04933bf88242a9fdc9.png"></p><p>类里面的函数都需要一个self参数</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9911e6d1a881e3488c41cf5aba852d7e.png"></p><p><img src="D:/桌面/media/816f677122870edca3a30dd27e3559c1.png"></p><p>类属性是全类用一个，共享。实例属性 是每个实例的都不一样，区别是实例属性用self定义</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/bf592487cb836c1bf906070044c14ae6.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2191ade786c4ff99bf0a64b03a4c88ce.png"></p><p>保护属性可以通过实例名访问。</p><p><img src="D:/桌面/media/125a014c20f548e9a0ccdf1693990245.png"></p><p>私有属性可以在类的实例方法中访问，也可以通过“实例名.类名__xxx”方式访问，但是不能直接通过实例名＋属性名访问。</p><p>_<em>foo__：首尾双下划线表示定义特殊方法，一般是系统定义名字，如__init</em>_()。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/830d7a8cd6f4d0446c135d6b7cb3bfeb.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/c8b085c1932495870b374d15fdd6e26e.png"></p><p><img src="D:/桌面/media/d97b751ff004ba1bd421a218dd53f439.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d40dd248f3bd7fc2c9b4adf4a82af749.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6ad79cc3f123f55cdedf27a1d227808f.png"></p><p>在Python里面也用super（）表示父类，java是用super。</p><p>Python的__init__（）函数里面应该有下面这句</p><p><img src="D:/桌面/media/6dbc069288a6e14240aa1de25db94d56.png"></p><p>而java的构造函数需要只需要一句super()；</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/dc3152e5f4e15ae629fc1c311618f9c2.png"></p><p><a href="https://blog.csdn.net/weixin_35684521/article/details/81396434">Python中的 if _<em>name</em>_ == “<strong>main</strong>“到底是个啥意思？_大表哥在曾母暗沙的博客-CSDN博客</a></p><p>if _<em>name</em>_ == “<strong>main</strong>“<strong>：</strong>这个语句使得<strong>该文件作为模块使用时下面的代码不运行</strong></p><p><img src="D:/桌面/media/cc06c906d6edff9ea019665c33a32af5.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/71c56e2c522582a79524793030804630.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/cd1b89ee15c868917caa13dd7b40d126.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a4aa18d9fd5e8981e29d98d42c16e074.png"></p><p><strong><img src="D:/桌面/media/f27bcd249cf17587bd790510b1b8a5ca.png"></strong></p><p><strong>总结：import什么，以后调用就要用什么</strong></p><p><strong>在异常处理方面，python跟java类似，但是java是catch，Python是except。抛出异常方面java是throw就跟C++一样，但是Python是raise。Python也有断言assert</strong></p><p><strong><img src="D:/桌面/media/87280a5742b3a08c2510ecce9416b656.png"></strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e9fb901e4c9c5ea487b43e77e2ec891e.png"></p><p>Python的文件打开模式是</p><p><img src="D:/桌面/media/16d04a53e970d4773aad39c93d880d43.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/56de5343546efc74a7cd255100b0bda3.png"></p><p><img src="D:/桌面/media/fde8941d67c26072d96099d31523fbc5.png"></p><p><a href="https://www.runoob.com/python3/python3-mysql.html">Python3 MySQL 数据库连接 – PyMySQL 驱动 | 菜鸟教程 (runoob.com)</a></p><p>尽管wxPython不是最流行的GUI，但他是书里面的。</p><p>正常情况下更推荐PyQT5</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/bb90e6c1710ee7be0e3ec92b88761782.png"></p><p>一般情况都用不到</p><p><strong>序列</strong></p><p><strong>列表：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/642b224f788c91057cb8bcaa8ebd70b5.png"></p><p>例a=[10,20,30,40]，则del a[2]和a.pop(2)和a.remove(30)是一样的效果，都是在原列表上的操作。remove是删除第一个该元素</p><p>sort和sorted的reserve为True时都是降序</p><p>sort和reserve都是在原列表上操作，方便的操作应该是都赋值一下。</p><p><strong>元组</strong></p><p><img src="D:/桌面/media/48c527366ccb11ed30405eef55f0cc2b.png"></p><p>元组是不可变的列表，元组圆括号（可以省，这是唯一可以省的序列）。</p><p><strong>这个不可变是指里面的不可变元素（数字等）不可变，如果元组里面的子对象（列表等）是一个可变子对象，是可以修改的。</strong></p><p>元组特色zip()：</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/8688a6c2a7256c8ac0022dd2212d23c5.png"></p><p>字典经常用它构造（二元）。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1329006ad1917c59bf84bc5059804f5e.png"></p><p>生成器内部维护了一个指针，产生一个生成器对象，生成器对象有一个__next__()方法用于遍历。<img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7dded9565f6099ab74c4107119891229.png"></p><p>**<br>**</p><p><strong>字典</strong></p><p>字典是快速通过键对象获取值对象：<img src="D:/桌面/media/1b8ea5f01f1bf0bb252e843abc04e251.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/5b0961cc8d4ab7541430b8be270dd6e2.png"></p><p>字典的访问通常使用get（），因为这个方法不会抛异常，而是在找不到的时候默认None</p><p>get(查找的键对象key,找不到时的默认值)</p><p><img src="D:/桌面/media/08a591e9409c6a58645387309f56974c.png"><img src="D:/桌面/media/24a4d72636d0cf896d00d373684a45fd.png"></p><p><img src="D:/桌面/media/b283095130a877c4d813d0e8ed9fa37e.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/86f1062878e155504a4f19d344f05b15.png"></p><p><strong>———————————————————————————————————————</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/ff8633246f59c7fc6bdc274c8cb648cc.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/343a74b7ce0333081a944a0cea2f6f47.png"></p><p>删除的话有pop()和del()，参考元组和列表，将索引替换为键对象即可。还有clear（）清空。</p><p>还有popitem()无参函数，随机删除一个（很少见 ）。</p><p><img src="D:/桌面/media/4c9cacfbb0970b6d39a1d6e66afe1005.png"><img src="D:/桌面/media/21d188e627a4813d695aeb2e512d9e92.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/53f42e31e43faf22eadc0c80aa758c41.png"></p><p>字典的底层实现看一下资料</p><p><strong>集合</strong></p><p>相当于字典的键对象集合</p><p><img src="D:/桌面/media/756ed47d83453b3fab5530f222501e95.png"></p><p>也用花括号</p><p><img src="D:/桌面/media/9ded222351c54e1acfb7247e44fc5b9e.png"><img src="D:/桌面/media/a84fb17820b43fb06d7105df371c198a.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4e193ad8f257364f215a65c4ace0531d.png"></p><p>条件表达式</p><p><img src="D:/桌面/media/f4881d3d836672642c8b0ba49e328846.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e8156f57b51145720134921423f03d9a.png"><img src="D:/桌面/media/a40365c9dba1fe8899626149548fd724.png"></p><p><img src="D:/桌面/media/2d642db26c8823f4ff585900649fd0bd.png"></p><p><img src="D:/桌面/media/88c0467a76727676731c03ce9b506149.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6976ff28e24ee13cb2174aa3fec44740.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1094a5535946971ac2437b92921bf8b5.png"></p><p>全局变量尽量少用（会降低通用性和可读性），且局部变量效率更高</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2a5b1e3ef9d98fc82dc8ed4aaa78ed4d.png"></p><p><img src="D:/桌面/media/5ad43ca60ddfedf90d95f1ef993fce7d.png">-</p><p><img src="D:/桌面/media/0bcd78c21723403e8afa218e71fe627e.png"></p><p><img src="D:/桌面/media/fb4a7202372fc8f46b0d33bbb0e5e1cd.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d08efb40d3a9ef9fcb0a3fd1db4ce2ca.png"></p><p><img src="D:/桌面/media/b37371125bbeed34df9bd0fe1a626e97.png"></p><p>a=print_star</p><p>b=a</p><p>则a和b都指向了实际的对象，b不会指向a，a的改变（不是实际对象改变）不会影响b</p><p>python的赋值都是引用赋值。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0f8bea5b794089eadd01ffa7c98f50d4.png"></p><p>栈区里面那个方框是栈帧，代表了def里面的变量。所以在def里面a覆盖了全局的a，如果a被声明为global，则是调用了帧外的那个a。栈帧里面是局部变量，外面（不在任何一个帧里面）是全局变量</p><p>python的垃圾回收是指堆区的对象没有一个箭头（引用），则该对象被自动回收。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b9c7d648809848d7986685869f4da8b4.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1ee91cd71900052b8c774e931b9133e2.png"></p><p>这个内置函数需要导入copy模块</p><p><img src="D:/桌面/media/1b9c8a889b5c2bbfe5600b450bdc8cef.png"></p><p>浅拷贝：拷贝一层对象，子对象拷贝了引用。对子对象的修改会影响到拷贝对象，对最浅层的修改不会。例如上面加一句b[1]=99，那么也不会影响到a</p><p>深拷贝：直接完全复制，所有子对象都一起复制了。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4fc245c97f5a5c663912a8501dc3d4b4.png"></p><p><img src="D:/桌面/media/065411778fd8a4a34c14bc4cc37c2343.png"></p><p>这样想：函数在执行修改的时候，只有修改不了（不可变对象）的时候才会创建一个新的对象。当然，修改不了的时候会抛出异常，但是理解就行。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4d18918fa76200a669686f5a1c41f96a.png"></p><p>内部函数 是为了避免函数内大量重复代码。外面是不能调用内部函数的。</p><p>non_local是声明外层的局部变量，目的是为了使用外层的局部变量。</p><p><img src="D:/桌面/media/371bbfeca007041a4d2fccb52faa23d6.png"></p><p>OOP</p><p>Python的方法也是属性。</p><p>类里面的属性和方法 都可以动态添加、修改，当然，是通过类名调用的。但是要注意一个事情，原方法需要self参数的，修改后的方法也应该有一个slef参数（参数名随便起，但必须有一个），不然就会报错</p><p>python里面数字也是对象，java里面int等不是对象，有专门的数字对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f7486670e2a166ba717b2ce0598d8026.png"></p><p>_<em>init</em>_()是构造函数，用于初始化。</p><p>_<em>new</em>_()是创建函数，用于函数的创建，但是我们一般不需要重定义。</p><p>class里面的是共享属性，构造函数里面的是实例属性（self.定义的），对象私有的。</p><p>实例方法是第一个参数是self的函数。</p><p>self是实例的地址。这也就表明了为什么带self的是不共享的，不带self的是共享的。</p><p>self参数是解释器自动传参的，我们不用管。</p><p><img src="D:/桌面/media/f99102c872111faeb7dd1ad2a2961801.png"></p><p>类对象，实例对象，类属性，和 实例属性之间的关系</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4b2f84312ff3c8b33304eb3e0bb561bf.png"></p><p>很少用</p><p><img src="D:/桌面/media/26575707b05459b254bab673ca235799.png"><img src="D:/桌面/media/1c60770ae4336bd251147231b249eafc.png"></p><p>静态对象不需要cls，也不需要self，就是一个普通函数，放在了类的命名空间</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/ce34dac57c89947c9a8e9f7451db0f0e.png"></p><p>这也就说明了，类名调用的是__init__()函数，类名（）调用的是__call__()函数。</p><p><strong>python里面没有方法（函数）重载，只要重名就会覆盖，哪怕一个有参一个无参。</strong></p><p><img src="D:/桌面/media/bd0993c05d4bc74ad8b1f4b12c54a538.png"></p><p>双下划线开头的是私有的，解释器在运行的时候 把 <strong>__私有方法</strong> 解释为<strong>_类名__私有方法</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/258dbfe3a3851d69bd1e7310436ff0c1.png"></strong></p><p><strong><img src="D:/桌面/media/b726bea957e0e8684d6e0534a8bb007a.png"></strong></p><p><strong>注意一下，这里salary必须是私有属性，不然就会报错。当然一般也只有私有属性会用这两个装饰器。</strong></p><p>**<br>**</p><p>python支持多重继承的，java不支持多重继承，但是java’可以有多个接口。</p><p>python的类都默认继承了object类</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d15b477cbe7914868d60c342942fa4dd.png"></p><p>python的继承是除了构造函数全部继承，哪怕是私有也会被继承</p><p><img src="D:/桌面/media/4f3f353fa13f5b110f07b58f362677f6.png"></p><p>注意一下，在用super().xxx的时候，xxx不要加参数self</p><p><strong>help(类名)可以看帮助文档</strong></p><p><img src="D:/桌面/media/7586d446e88710f6a894c7fd051f799c.png"></p><p>调用str(对象)的时候，实际上都是自动调用了对象的__str__()方法。</p><p>实操中尽量避免多重继承。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7977b6d03d0bcc400cd9e27f2667fc28.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/20e0ef7f2d608ca49e2ac416ed9cb827.png"></p><p><img src="D:/桌面/media/964247d6f43c19678fdacb32d20d2962.png"></p><p>super()代表的是父类的定义，不是对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2ffe68ad9332090ac8962d181e3988b9.png"></p><p><strong>重载运算符，则重写这些特殊方法就行</strong></p><p>说起重载，python不支持自增自减运算符</p><p><img src="D:/桌面/media/837d2d84e6058faf4d44bab587d2d989.png"></p><p><img src="D:/桌面/media/af2a15a4388e51b8c50074ed34cae3e7.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/bc2d539e6c1fc425621fbc40f7a99968.png"></p><p><img src="D:/桌面/media/e83c06af222ce2b98869cb8a8c0fbf04.png"></p><p><img src="D:/桌面/media/aa9a92fd27744840c7bd690ca9582a4e.png"></p><p>设计模式：工厂模式和单例模式。</p><p>单例模式常用的方法就是重写__new__()方法</p><p>异常处理</p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/567a5f6a6d2dd4719b6e2212e67cb54b.png"><br><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b698d9cb91c6deeae18581ce9e73cf4a.png"></strong></p><p><strong>出现异常后，try语句里面异常后面的就不会执行了。except完成后，就接着执行except语句后面的语句</strong></p><p><strong><img src="D:/桌面/media/c161001982d0608ca7da756dfb603730.png"></strong></p><p><strong>先子类后父类，针对性地写代码</strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e605df63744dec248f83bb9fb2935ed0.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/51dc122f44d5c6dad955adcb063a525d.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a637fea850e68e326b198a6dcbba9e97.png"></strong></p><p><strong>return放到异常处理语句里面通常会发生意想不到的错误，一般不建议</strong></p><p><strong><img src="D:/桌面/media/69d0e7c17ddb38d79606ada48d8fa110.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b39f6b57edcd68fcd4b1a8aee7ad3380.png"></strong></p><p><strong>打开资源的时候用with比较方便，其他时间用finally更方便</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9722de82fa2b86c5f772d7a29cecb606.png"></strong></p><p><strong><img src="D:/桌面/media/d9adc2bceda871f9d7b7cc3d52ec9134.png"></strong></p><p><strong>打印到文件里面</strong><a href="https://www.runoob.com/python/python-func-open.html">Python open() 函数 | 菜鸟教程 (runoob.com)</a></p><p><strong><img src="D:/桌面/media/f331f0e07584fa2100dc15cd929e2604.png"></strong></p><p>**<br>**</p><p><strong>文件操作</strong></p><p><strong><img src="D:/桌面/media/97603811d560cb61623f087c3862950d.png"></strong></p><p><a href="https://blog.csdn.net/mahoon411/article/details/109097222">python 字符串前面加‘r’的作用(并举例说明)_python中r的用法_吮指原味张的博客-CSDN博客</a></p><p>r表明字符串不需要转义</p><p>最好都使用with处理文件资源（不需要close()）</p><p><strong>with xxx as x:……</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/63c9ea1a89f0de1ed9e139ee5acaa01f.png"></strong></p><p><strong><img src="D:/桌面/media/8cbdd9a380c148eaac64796999fc2f3c.png"></strong></p><p><strong>程序在写入文件的时候也是UTF-8</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/8ffb45ba4c0bab7f7291c2a481a6f664.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3e166495ff6df5e49daa1ded93ca2aa6.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/2c5e4ab4f5d8a24e6de8fc5ea207d1e3.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6632b903c963856103b0664fe310efc4.png"></strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/9c862f20ee2979e7cf50c73da5dbf0ef.png"></strong></p><p><strong><img src="D:/桌面/media/cf053e96f9ec44f3c8238e50582ba5fe.png"></strong></p><p><strong>OS模块很重要，OS和OS.path</strong></p><p><strong><img src="D:/桌面/media/35600c157168e0205da3942420749677.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d49c362255c2f3d204b8c4b50263293e.png"></strong></p><p><strong>我们可以先调用mkdir（）创建目录，再open()创建文件。</strong></p><p><a href="https://www.runoob.com/python/python-func-repr.html">Python repr() 函数 | 菜鸟教程 (runoob.com)</a></p><p>**repr()的主要作用是将换行符等格式字符转化为转义字符输出<br>**print(repr(os.linesep))</p><p><strong>通过chdir()和mkdir()和makedirs()可以在任意已知目录创建目录（文件夹）</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a175eee504097075b7c370b99b5934bd.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1a26bbea91d7f4d8469015f217f43476.png"></strong></p><p><strong><img src="D:/桌面/media/8cd9c3402256e3e43732d9a5964db0ce.png"></strong></p><p><strong><img src="D:/桌面/media/2d162345cdcbab8d15ac2af2e358f059.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/19940b27caba1435eafd0c76a6e1e3f8.png"></strong></p><p><strong>shutil模块是可以直接压缩一个文件夹，zipfile提供了动态压缩的方法</strong></p><p>**<br>**</p><p><strong>练习：在当前目录下怎么创建多级目录</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/dfa036235cd99929437ea4ad6c9f25d1.png"></strong></p><p><strong>关键在于os.path.join()的使用，不要用r“\shuji\music\book”这种形式。而且不要在makedirs（）里面用相对路径，会被识别为“C：相对路径”。</strong></p><p>**<br>**</p><p><strong>练习（#重要#常用）：递归遍历目录树</strong></p><p><strong><img src="D:/桌面/media/05fd91c33a1a57b408281898d1ba9d14.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7e3a0b8a9052f91eb74f940e2052cef5.png"></strong></p><p><strong>API（文档首部）相当于先搭好一个框架，构建好。具体的实现不提及，最后搭好后编码实现。</strong></p><p><strong>有一些函数是不应该被外部调用的，最后变私有</strong></p><p><strong>在math里面很多函数是pass，是因为这个模块是用来链接C库的，C已经写好了，python直接拿来用。</strong></p><p><strong><img src="D:/桌面/media/201cd7bcc2fe2565b5e504874c70647e.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e1f818703598f4af1643370bd0a6a45c.png"></strong></p><p><strong>推荐from … import …,但不推荐from … import *。总是import一个模块，会让最后项目体积很臃肿。import后面是可以直接使用的，导入模块则 模块名.函数名，导入函数则 函数名。</strong></p><p><strong>动态导入（一般用不到，少见）<br><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a08422d3aa0f6f7a8a2c079e06a81b3d.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/796d86b5bad6b588c2463dce5c058826.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4d412c4a644c3e1a24d740c94b290352.png"></strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/0c404f4455dfafc531533f0ea72003ac.png"></strong></p><p><strong><img src="D:/桌面/media/6d13a317be7dd287ebb7a04ef9e31be7.png"></strong></p><p>**<br>**</p><p><strong>Tkinter学习（这个只适合最简单的，最好用PyQt）</strong></p><p><strong>但是很多窗口框架之类的思想是通用的</strong></p><p><a href="https://docs.python.org/zh-cn/3.11/library/tk.html">Tk图形用户界面(GUI) — Python 3.11.4 文档</a></p><p><a href="https://www.tcl.tk/man/tcl8.6/TkCmd/contents.html">Tk Commands (tcl.tk)</a></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b98aff805ddbb98dacbde454efb1c141.png"></strong></p><p><strong>按钮等组件都需要pack()装载到窗口里，pack()默认是流水线（垂直）装载。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/323160099463587c5a33d4310834b4d4.png"></strong></p><p><strong>用Label显示图像的时候，图片需要是全局的。</strong></p><p><strong>也可以将photo声明为self，实例参数。推荐声明为实例参数。</strong></p><p><strong>command参数赋值不加（）</strong></p><p><strong>label的很多功能是字典给的，label重载了“索引赋值”__setitem__函數。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/cc4348d9260290ce1b12bc8891e881cf.png"></strong></p><p><strong>Entry用来做单行文本框</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3bbc8395eb890d96c101ab7c3dbad584.png">注意绑定的函数一定要有一个参数event</strong></p><p>**<br>**</p><p><strong>练习（自制登录系统without数据库版）：</strong></p><p><strong>问题：一定要注意StringVar，要知道里面的内容应该用get()，不能直接和字符串比较</strong></p><p><strong><img src="D:/桌面/media/b26eb59e6de9d221c58e6b35e7a60ccf.png"></strong></p><p><strong>行从1开始，列从0开始</strong></p><p><strong>Canvas的原点是左上角，一般用对角线两个点。</strong></p><p><strong>grid（格子布局），pack（简单布局），place（坐标布局）</strong></p><p><strong>练习（自制扑克牌）</strong></p><p>关键在于bind_class()这个函数还有列表的使用</p><p><strong>command方式只适合简单情况，不涉及event对象。bind（）函数处理event对象。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/1eda32faa3a7c506c5a80556956588d9.png"></strong></p><p><strong>还有很多具体函数什么的，看文件吧。</strong></p><p><strong>注意：颜色选择框函数askcolor()会返回一个列表[(rgb),颜色代表字符]，调用bg和fg的时候，参数一般是列表第二项“字符”</strong></p><p><strong><img src="D:/桌面/media/58e43ef161af6114361f6c54b5a94f8f.png"></strong></p><p><strong>注意一下这个快捷键的处理，lambda返回的是“函数的名字（暂时这样理解吧）”。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/98368a90b4e8186cdfccb332d8000e0d.png"></strong></p><p><strong>这种lambda实现了已有函数的传参</strong></p><p><strong><img src="D:/桌面/media/69beb7d10b276aae6a77ef600c44df0f.png"></strong></p><p><strong>需要这种形式的时候参考，这些函数不用很容易忘。</strong></p><p>**<br>**</p><p><strong>打包</strong></p><p><strong>在pyinstaller打包的时候，运行最后的exe总是弹出控制台，解决方法如下：</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/c0bd3fd85a82257d609a221b4ce3cb95.png"></strong></p><p><strong>-w有时候不好用，推荐方法一</strong></p><p>**<br>**</p><p><strong>Pygame没有学，以后或许可以了解一下，留个位置吧</strong></p><p>**<br>**</p><p><strong>并发编程</strong></p><p><a href="https://www.runoob.com/python3/python3-multithreading.html">Python3 多线程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://docs.python.org/zh-cn/3/library/threading.html">threading — 基于线程的并行 — Python 3.11.4 文档</a></p><p><strong><img src="D:/桌面/media/17bb1627c9ec9707d575236f024c3587.png"></strong></p><p><strong><img src="D:/桌面/media/d4897f63e60cdc922245e0e98a0b9a6b.png"></strong></p><p><strong><img src="D:/桌面/media/60a174956571aac30effd1e2b0761614.png"></strong></p><p><strong>容易忘，线程必须用start()启动</strong></p><p><strong>哪怕不声明线程，每个程序启动都会有一个主线程。</strong></p><p><strong>线程类一般重写__init__（）和run(),run()是start()后自动执行的</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a9805712cb6ba8e0ab88922942745d3f.png"></strong></p><p><strong>子线程①.join()就行了，主线程会等待这个子线程①</strong></p><p><strong>直接使用线程是</strong><a href="https://blog.csdn.net/chpllp/article/details/54381141">python多线程模块：threading使用方法（参数传递）_threading.thread 传入参数_chpllp的博客-CSDN博客</a></p><p><strong>通过类方式使用线程：</strong></p><p><strong><img src="D:/桌面/media/83cf6dee9f35e6c12d639aab7d0d5b02.png">子线程类的init只能用Thread，用super（）有问题。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/03583c6d70f1fad84c3a881deb1707af.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/83107a32b908af0517de1dbd869d3cf2.png"></strong></p><p><strong>setDaemon()已经被废弃了，现在直接修改“属性”就行</strong></p><p><strong>注意：必须先设置daemon才能start（），否则<img src="D:/桌面/media/78ff4f2647fe6cc0ffb7dc84ea701b51.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/670067e04d3c17704b584ffd4436cff5.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b7cb75dfd8556ebf5f1ff8801274b949.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/aa6b88fb9a0f56c97129549645b03d7f.png">这个锁的概念在数据库里比较详细</strong></p><p><strong><img src="D:/桌面/media/770b8df096790aa66762c9982422a7bf.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9837d98e798699acf620ef4eba1dfa13.png"><img src="D:/桌面/media/c77fc2dc50c7ccf4d997ac13c1853a85.png"></strong></p><p><strong>这个acquire和release是信号量的方法。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/5a2d15a46f7506800be8dc3f29e3fcfc.png">相当于tk的event对象</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/fc1f255d86521862732e2133980428c9.png"></strong></p><p><strong>生产者和消费者模式：</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/9a19e21a0c1206b9236f5a5975d8aeaf.png">这个经常会见到的</strong></p><p><strong>进程的类方法使用和线程差不多</strong></p><p><strong>注意print(f“ada{arg}”)的使用</strong></p><p><strong>注意：进程间不能直接使用代码的全局变量，全局变量是主进程的，新建的几个进程是用不了的（堆内存和栈内存都不共享）</strong></p><p><strong>Manage管理器和Queue其实差不多，都是找一个内存空间，供所有进程存取。</strong></p><p><strong><img src="D:/桌面/media/b71ad6e10602e06ed734cafe9a7b30d2.png"></strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/249121b49b91bfc75f23350eba9c4e23.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d0714153f35a004281c8c8c7ce4b97be.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/e5b98ad18581b788eb569efe01438de3.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/4b2e0017f9dcdde4da4b6634a45814fa.png"></strong></p><p><strong><img src="D:/桌面/media/405fd07564cc2be747d31909d3f99c89.png"></strong></p><p>套接字编程</p><p><a href="https://geek-docs.com/python/python-tutorial/python-socket.html">Python 套接字教程|极客教程 (geek-docs.com)</a></p><p><a href="https://docs.python.org/zh-cn/3/howto/sockets.html">套接字编程指南 — Python 3.11.4 文档</a></p><p><strong><img src="D:/桌面/media/c5f9f6381b590e702b4e4bfcf922ddd7.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0e387551485169e715eec8a63a7a5740.png"></strong></p><p><strong><img src="D:/桌面/media/187a42cd4f8d3aeffbefbd96eb291ebf.png"></strong></p><p>TCP是有连接的，UDP是无连接的。所以connect函数是TCP的</p><p><img src="D:/桌面/media/187a42cd4f8d3aeffbefbd96eb291ebf.png"></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3c505e61f8728b922d7d4bc2d4ea663b.png"></strong></p><p><strong><img src="D:/桌面/media/c33e04ca419b6ccd8d452d4f8d5385a1.png"></strong></p><p><strong><img src="D:/桌面/media/ebeadcfc86331bea044c428a04d22d3d.png"></strong></p><p><strong>发送数据的时候，python3把字符串转化为byte，默认的网络助手的编码是gbk</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/a83c5ea5af4243b9b0c790ae73607216.png"></strong></p><p><a href="https://blog.csdn.net/Z_Stand/article/details/102535706">C语言网络编程：accept函数详解_c accept_z_stand的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/cindy-cindy/p/8022009.html#:~:text=accept,%28%29%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%8C%E4%B8%8D%E5%90%8C%E4%BA%8E%E4%BB%A5%E4%B8%8Asocket%20%28%29%E8%BF%94%E5%9B%9E%E7%9A%84%E7%94%A8%E4%BA%8E%E7%9B%91%E5%90%AC%E5%92%8C%E6%8E%A5%E5%8F%97%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%9B%E4%B8%8E%E6%AD%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%98%AF%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%E6%96%B0%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8A%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E6%9D%A5%E5%AE%8C%E6%88%90%E7%9A%84%E3%80%82">Python中网络编程对socket accept函数的理解 - 小女子的测试之路 - 博客园 (cnblogs.com)</a></p><p><strong>发送数据的时候，python3把字符串转化为byte，默认的网络助手的编码是gbk</strong></p><p><strong>注意：绑定的参数是一个元组_addr（IP地址，端口号）</strong></p><p><strong>绑定bind的参数是_addr</strong></p><p><strong>recv_from和recv的参数是最大字节数，因为UDP和TCP接受信息不可能事先就知道从哪儿来的（接收全球信息），没有_addr参数。</strong></p><p><strong>send_to的参数要这个_addr，还要一个data（要转gbk）。send就不需要了，它是TCP的函数，已经建立好连接了，不用传参_addr</strong></p><p><strong>第一步都是建立socket对象，最后一步都是关闭这个socket对象。UDP服务端接下来就是绑定bind和接受消息recv_from，最后close。UDP客户端接下来就直接是发送消息sendto。TCP的服务端接下来就是绑定，监听listen（参数是套接字排队的最大连接数，即同一时刻最多允许几个套接字连接），一个阻塞accept（返回一个client_socket对象和信息），接收recv（用前面返回的client_socket对象接收，因为同一时刻可能会有多个客户端，用client_socket区分），发送是send（也是用client_socket进行通信），关闭(先关client_socket，再关server_socket)。TCP的客户端需要connect（连接一下，参数就是_addr元组，用自己创建的client_socket调用），然后recv和send跟服务端一样。</strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/c5a4cc61addd0078d359c6ea19c568fd.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b636da3f185f8f6759b6e111de4895f3.png"></strong></p><p><strong>高阶函数用函数当参数</strong></p><p><strong>注意，如果函数参数需要参数，则这样定义高阶函数</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/81f916a8b27754d5d4f16547c4d3decf.png"></strong></p><p><strong><img src="D:/桌面/media/2dc96d9a216380a4851dc1201f837e3f.png">实际上就是设置默认值的函数</strong></p><p><strong>例如：默认的int（）的base默认是10</strong></p><p><strong><img src="D:/桌面/media/77d643b897f7705e590c696b078f54bc.png">这样就把默认值从10变成了2</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d5d8fb00c863534089314bf63a85dd67.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/8828ca013db424b24ea008d2f0dad8f9.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/8a741d497008584d9aa72763c5d7efe6.png">闭包就是一个内部函数</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/d0c2859c084cc88c930b2eee16786830.png"></strong></p><p><strong><img src="D:/桌面/media/7e0e94db24f8ba295c72d740966eb5ad.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/10921db4ce0a382876f0d7d8ee2371dc.png"></strong></p><p><strong><img src="D:/桌面/media/1756974674cd648eb2e1b35ef8c8c17a.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/412e08f6ff32b36214c2a2967126a4eb.png"></strong></p><p><strong><img src="D:/桌面/media/d7bb28e513aac1287f2434ba5828ddde.png">自由变量在外部栈帧消失后，由内部指向，所以不会被回收。自由变量不会污染其他程序，但是自由变量又有全局变量的好处。内部要修改自由变量的时候，要用nonlocal声明。</strong></p><p><strong>闭包是装饰器的基础</strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f84a29d4465d8e4296a50407001734c8.png"></strong></p><p><strong>这个使用更方便，不用也行（写循环）</strong></p><p><strong><img src="D:/桌面/media/5c9e5d388604ead3ed9bb7853d524481.png"></strong></p><p><strong>快速检验：</strong>print(list(map(lambda a,b:a+b,[1,2,3,4],[10,20,30])))</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/c2cb294883f8d5084128405af328a982.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b12977522c9f6acab2adf05930b6b52f.png"></strong></p><p><strong>reduce就是累积的调用，注意“一个序列”，“至少两个参数”，需要导入模块</strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/c9d0a488933197118cc20d292b30e856.png"></strong></p><p><strong>注意，传入的函数返回值必须是布尔值。</strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/afb0f3c88f956d0ee8211638f9fbda20.png"></strong></p><p><strong>实际上就是在函数参数前面一行加上@外部函数</strong></p><p><strong>一个函数可以有多个装饰器</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/bfe84a775041a006f652425d72be4d29.png">实际上就是说</strong></p><p><strong><img src="D:/桌面/media/336c3e414be4cf3f2710dc2f26fa3cdd.png">等于mylog(costlog(func1)).定义阶段先执行costlog再执行mylog。执行阶段先执行mylog再执行costlog</strong></p><p><strong>装饰器有参数的时候，直接<img src="D:/桌面/media/020269843604ed6e0658ac955c3b3f99.png">就行</strong></p><p><strong>注意一下，内部函数的邻近外部函数的参数应该是函数参数（我们一般写作func），最外层函数则不需要这个（如果最外层不是内部函数的邻近外层）。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/93407d69391a7cbdd765dfe60684d83a.png"></strong></p><p><strong><img src="D:/桌面/media/614f431f2e013aab0dbf65ab5a475a35.png"></strong></p><p><strong>不使用wraps的话，后续调用func的doc等是空的。</strong></p><p><strong>注意infunc（）一定要返回infunc</strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/a71bea50315b6bd2661f159d8d1fd821.png">最常见property，其他不常见。</strong></p><p><strong><img src="D:/桌面/media/3814c66b83692697ad7e3ab7beb5f7db.png">适合只有self参数的函数</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6576c13a242c11cc9ff9e5d553a89d6a.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/b8d54002f864c43c45d57914f3e09a77.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/482f24e98ca8a6a09b571ff5ceaef263.png"></strong></p><p><strong><img src="D:/桌面/media/77e06b09e9f0b28bd1e41c52bc7ee1c7.png"><img src="D:/桌面/media/2ebd2630cfb76c684cfed5e91c1adaf2.png"></strong></p><p><strong>一般要将func函数参数初始化init为实例参数。</strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/81db23386040a2d474817c7e3fce89b2.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/361f6c97fc2c5a96f35922409d591f7e.png"><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/3853ae15dd091c836067c99dcd9c2bb1.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/0bb363dee73c4c3ea0af2ccf3161cbbc.png"></strong></p><p><strong>生成器的例子，用圆括号</strong></p><p><strong><img src="D:/桌面/media/cc01e860a1a7d6f9df4de0afc1f79bd0.png"></strong></p><p>**<br>**</p><p><strong><img src="D:/桌面/media/8881ca70dc9f5874b399c779cc5b2baa.png"></strong></p><p><strong>这个就触及了生成器的本质了</strong></p><p><strong><img src="D:/桌面/media/011fcbf6116b9ef47ec7fadae24fa8e1.png"></strong></p><p><strong>函数里面有一个yield类型对象，则函数就是生成器对象</strong></p><p><a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">python中yield的用法详解——最简单，最清晰的解释_python yield_冯爽朗的博客-CSDN博客</a></p><p>把yield理解为return就好，每次记录停留位置。</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6b3ee37d2363fad453f10b029d6d6c35.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/6207dcdd960f94135e3092d80da7c442.png">例如这个就代表了两个语句。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/5b957086b366afaa10a0139c20b6489e.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7a5492b1087087e5e37f21f8f9098519.png"></strong></p><p><strong><img src="D:/桌面/media/2b071f5d71be22710c2d9298cec25028.png"></strong></p><p><strong><img src="D:/桌面/media/0d7a529883cdcd8d4d1d26195dcf3009.png"></strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/c67ab68631f13d1101f4b68a260c636f.png"></strong></p><p><strong>for循环就是调用iter（）将list，dict，str等转化为迭代器</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f200f4d23bdea2ce320efc66a4590fcd.png"></strong></p><p>**<br>**</p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/7dd6d8a841d2a15fcd80529c92ad6ff4.png"></strong></p><p><strong>这个倒是不怎么用</strong></p><p><strong>例子：</strong></p><p><strong><img src="D:/桌面/media/b56d814dfd9db7b77b8a993ac7010f54.png"></strong></p><p><a href="https://zhuanlan.zhihu.com/p/392519274">一文看懂python的迭代器和可迭代对象 - 知乎 (zhihu.com)</a></p><p><strong>python是动态的，可以动态添加、修改属性和方法。但是需要注意的是方法需要用到形如</strong></p><p><strong>cls1.func=types.MethondType(func1,cls1) ，而属性就可以直接赋值。</strong></p><p><strong>但是可以用__slots__关键字限制动态添加成员变量和成员方法。</strong></p><p>**<br>**</p><p><strong>正则表达式是使用标准库的re模块。用到可以查资料。</strong></p><p><strong><img src="D:/桌面/media/3b01e4cbc31af0e86153658d2a06ac23.png"></strong></p><p><strong>pattern就是正则表达式。</strong></p><p><strong>flags是标志位</strong></p><p><strong><img src="D:/桌面/media/a7d4691384e2ec14bd650a747adebdce.png"></strong></p><p>**<br>**</p><p><strong>关键在于正则表达式的书写</strong></p><p><strong><img src="D:/桌面/media/9d314434a7ae9e314ee2ecee3406235c.png"></strong></p><p><strong>还有就是一个限定符</strong></p><p><strong><img src="D:/桌面/media/2c1da7152391fa08d626e2ef326d2941.png"></strong></p><p><strong>由于\是转义字符，在正则表达式中总会引起不便，可以用r前缀转换为原生字符串。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/f65f6f8a1c898b8802f6e83ac698bcfc.png"></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记</title>
      <link href="/2023/09/28/opengl-xue-xi-bi-ji/"/>
      <url>/2023/09/28/opengl-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>写在最前面，我的开发主要在VS2022上面，通过代码学程序，很多函数是不懂的。这个时候<strong>VS的快捷键F1就可以快速查看函数文档，很有用。</strong>（glut函数按F1查看不到）<a href="https://www.opengl.org/resources/libraries/glut/spec3/spec3.html">GLUT API, version 3 — GLUT API，版本3 (opengl.org)</a>这里是参考文档<br><a href="https://zhuanlan.zhihu.com/p/374920616">opengl新手教程（通俗易懂） - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/Wang_Dou_Dou_/article/details/121240714">OpenGL初学者入门——学习指南【共 9 篇文章】_opengl学习_一支王同学的博客-CSDN博客</a></p><p><a href="https://learnopengl.com/Getting-started/OpenGL">LearnOpenGL - OpenGL — 学习OpenGL- OpenGL</a></p><p><a href="https://learnopengl-cn.github.io/">主页 - LearnOpenGL CN (learnopengl-cn.github.io)</a></p><p><img src="https://cdn.jsdelivr.net/gh/liwuxuan/myblog@main/img/dbc430ed349a4411abcf3efba7409c5f.png" alt="img"></p><h5 id="以下是一些常用的OpenGL函数的清单，包括它们的用法和参数含义："><a href="#以下是一些常用的OpenGL函数的清单，包括它们的用法和参数含义：" class="headerlink" title="以下是一些常用的OpenGL函数的清单，包括它们的用法和参数含义："></a>以下是一些常用的OpenGL函数的清单，包括它们的用法和参数含义：</h5><h6 id="1-glClearColor-GLfloat-red-GLfloat-green-GLfloat-blue-GLfloat-alpha"><a href="#1-glClearColor-GLfloat-red-GLfloat-green-GLfloat-blue-GLfloat-alpha" class="headerlink" title="1. glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)"></a>1. <strong>glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)</strong></h6><ul><li>用法：设置背景清除颜色。</li><li>参数含义：<ul><li><code>red</code>：红色分量，取值范围为0.0到1.0。</li><li><code>green</code>：绿色分量，取值范围为0.0到1.0。</li><li><code>blue</code>：蓝色分量，取值范围为0.0到1.0。</li><li><code>alpha</code>：透明度分量，取值范围为0.0到1.0。</li></ul></li></ul><h6 id="2-glClear-GLbitfield-mask"><a href="#2-glClear-GLbitfield-mask" class="headerlink" title="2. glClear(GLbitfield mask)"></a>2. <strong>glClear(GLbitfield mask)</strong></h6><ul><li>用法：清除指定的缓冲区。</li><li>参数含义：<ul><li><code>mask</code>：要清除的缓冲区，可以是<code>GL_COLOR_BUFFER_BIT</code>（颜色缓冲区）、<code>GL_DEPTH_BUFFER_BIT</code>（深度缓冲区）、<code>GL_STENCIL_BUFFER_BIT</code>（模板缓冲区）的组合。</li></ul></li></ul><h6 id="3-glMatrixMode-GLenum-mode"><a href="#3-glMatrixMode-GLenum-mode" class="headerlink" title="3. glMatrixMode(GLenum mode)"></a>3. <strong>glMatrixMode(GLenum mode)</strong></h6><ul><li>用法：设置当前矩阵模式。</li><li>参数含义：<ul><li><code>mode</code>：矩阵模式，可以是<code>GL_MODELVIEW</code>（模型视图矩阵）、<code>GL_PROJECTION</code>（投影矩阵）、<code>GL_TEXTURE</code>（纹理矩阵）之一。</li></ul></li></ul><h6 id="4-glLoadIdentity"><a href="#4-glLoadIdentity" class="headerlink" title="4. glLoadIdentity()"></a>4. <strong>glLoadIdentity()</strong></h6><ul><li>用法：将当前矩阵重置为单位矩阵。</li></ul><h6 id="5-gluOrtho2D-GLdouble-left-GLdouble-right-GLdouble-bottom-GLdouble-top"><a href="#5-gluOrtho2D-GLdouble-left-GLdouble-right-GLdouble-bottom-GLdouble-top" class="headerlink" title="5. gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)"></a>5. <strong>gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)</strong></h6><ul><li>用法：设置正交投影矩阵。</li><li>参数含义：<ul><li><code>left</code>、<code>right</code>、<code>bottom</code>、<code>top</code>：视图体积的边界。</li></ul></li></ul><h6 id="6-glBegin-GLenum-mode-和-glEnd"><a href="#6-glBegin-GLenum-mode-和-glEnd" class="headerlink" title="6. glBegin(GLenum mode) 和 glEnd()"></a>6. <strong>glBegin(GLenum mode)</strong> 和 <strong>glEnd()</strong></h6><ul><li>用法：定义要绘制的图元的起始和结束。</li><li>参数含义：<ul><li><code>mode</code>：绘制的图元类型，如<code>GL_POINTS</code>（点）、<code>GL_LINES</code>（线段）、<code>GL_TRIANGLES</code>（三角形）等。</li></ul></li></ul><h6 id="7-glVertex2f-GLfloat-x-GLfloat-y"><a href="#7-glVertex2f-GLfloat-x-GLfloat-y" class="headerlink" title="7.  glVertex2f(GLfloat x, GLfloat y)"></a>7.  <strong>glVertex2f(GLfloat x, GLfloat y)</strong></h6><ul><li>用法：指定一个顶点坐标。</li><li>参数含义：<ul><li><code>x</code>、<code>y</code>：顶点的x和y坐标。</li></ul></li></ul><h6 id="8-glColor3f-GLfloat-red-GLfloat-green-GLfloat-blue"><a href="#8-glColor3f-GLfloat-red-GLfloat-green-GLfloat-blue" class="headerlink" title="8. glColor3f(GLfloat red, GLfloat green, GLfloat blue)"></a>8. <strong>glColor3f(GLfloat red, GLfloat green, GLfloat blue)</strong></h6><ul><li>用法：设置当前颜色。</li><li>参数含义：<ul><li><code>red</code>、<code>green</code>、<code>blue</code>：颜色的红、绿、蓝分量，取值范围为0.0到1.0。</li></ul></li></ul><h6 id="9-glPushMatrix-和-glPopMatrix"><a href="#9-glPushMatrix-和-glPopMatrix" class="headerlink" title="9. glPushMatrix() 和 glPopMatrix()"></a>9. <strong>glPushMatrix()</strong> 和 <strong>glPopMatrix()</strong></h6><ul><li>用法：保存和恢复当前矩阵状态。</li></ul><h6 id="10-glTranslatef-GLfloat-x-GLfloat-y-GLfloat-z"><a href="#10-glTranslatef-GLfloat-x-GLfloat-y-GLfloat-z" class="headerlink" title="10. glTranslatef(GLfloat x, GLfloat y, GLfloat z)"></a>10. <strong>glTranslatef(GLfloat x, GLfloat y, GLfloat z)</strong></h6><ul><li>用法：执行平移变换。</li><li>参数含义：<ul><li><code>x</code>、<code>y</code>、<code>z</code>：平移的距离。</li></ul></li></ul><h6 id="11-glRotatef-GLfloat-angle-GLfloat-x-GLfloat-y-GLfloat-z"><a href="#11-glRotatef-GLfloat-angle-GLfloat-x-GLfloat-y-GLfloat-z" class="headerlink" title="11. glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)"></a>11. <strong>glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)</strong></h6><ul><li>用法：执行旋转变换。</li><li>参数含义：<ul><li><code>angle</code>：旋转角度（度）。</li><li><code>x</code>、<code>y</code>、<code>z</code>：旋转轴的方向。</li></ul></li></ul><h6 id="12-glViewport-GLint-x-GLint-y-GLsizei-width-GLsizei-height"><a href="#12-glViewport-GLint-x-GLint-y-GLsizei-width-GLsizei-height" class="headerlink" title="12. glViewport(GLint x, GLint y, GLsizei width, GLsizei height)"></a>12. <strong>glViewport(GLint x, GLint y, GLsizei width, GLsizei height)</strong></h6><ul><li>用法：设置视口。</li><li>参数含义：<ul><li><code>x</code>、<code>y</code>：视口的左下角坐标。</li><li><code>width</code>、<code>height</code>：视口的宽度和高度。</li></ul></li></ul><p>这些函数是OpenGL中的一些基本函数，用于设置绘图状态、定义几何图元、执行变换和控制渲染行为。通过组合和调用这些函数，可以创建各种复杂的图形效果。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口宽度和高度</span></span><br><span class="line"><span class="type">int</span> windowWidth = <span class="number">800</span>;</span><br><span class="line"><span class="type">int</span> windowHeight = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 设置背景色为黑色</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT); <span class="comment">// 清除颜色缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制一个彩色三角形</span></span><br><span class="line">    <span class="built_in">glBegin</span>(GL_TRIANGLES);<span class="comment">//画点画线什么的都要用这里</span></span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); <span class="comment">// 设置当前绘制颜色为红色</span></span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">0.0</span>, <span class="number">0.5</span>); <span class="comment">// 第一个顶点坐标</span></span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>); <span class="comment">// 设置当前绘制颜色为绿色</span></span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">-0.5</span>, <span class="number">-0.5</span>); <span class="comment">// 第二个顶点坐标</span></span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 设置当前绘制颜色为蓝色</span></span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">0.5</span>, <span class="number">-0.5</span>); <span class="comment">// 第三个顶点坐标</span></span><br><span class="line">    <span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glFlush</span>(); <span class="comment">// 刷新缓冲区，绘制图形</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口大小变化回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reshape</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> </span>{</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height); <span class="comment">// 设置视口，充满整个窗口</span></span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_PROJECTION);</span><br><span class="line">    <span class="built_in">glLoadIdentity</span>();<span class="comment">//glLoadIdentity() 是OpenGL中的一个函数，用于将当前的矩阵重置为单位矩阵。单位矩阵是一个特殊的矩阵，对于矩阵乘法操作，它是一个“中性元素”。当你调用 glLoadIdentity() 时，它会将当前矩阵设置为单位矩阵，即没有任何变换或投影应用在对象上。</span></span><br><span class="line">    <span class="built_in">gluOrtho2D</span>(<span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>); <span class="comment">// 设置正交投影矩阵，范围为[-1, 1]在X和Y轴上</span></span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_MODELVIEW);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv); <span class="comment">// 初始化GLUT</span></span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_SINGLE | GLUT_RGBA); <span class="comment">// 设置显示模式，单缓冲区</span></span><br><span class="line">    <span class="built_in">glutInitWindowSize</span>(windowWidth, windowHeight); <span class="comment">// 设置窗口尺寸</span></span><br><span class="line">    <span class="built_in">glutCreateWindow</span>(<span class="string">"OpenGL Template"</span>); <span class="comment">// 创建窗口并设置标题</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(); <span class="comment">// 初始化OpenGL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(display); <span class="comment">// 设置渲染函数</span></span><br><span class="line">    <span class="built_in">glutReshapeFunc</span>(reshape); <span class="comment">// 设置窗口大小变化回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glutMainLoop</span>(); <span class="comment">// 进入OpenGL主循环，等待用户交互和渲染</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><a href="https://blog.csdn.net/aa941096979/article/details/50843596">OpenGL 解析glBegin()_Hi_乌龟的博客-CSDN博客</a>主要是看mode</p><p>glut参考链接[<a href="https://blog.csdn.net/qq_39377889/article/details/126946503">OpenGL笔记]glut入门（1）_glut opengl_Binarydog_Lee的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/deniece1/article/details/102642934">GLUT及其函数的用法整理_glutcreatewindow用法_deniece1的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/2303_77480410/article/details/130011521">opengl-glut(内含总结的学习资源)_glut文档_Osatnb.c的博客-CSDN博客</a></p><p>glut现在已经不是一个流行的窗口管理选择，或者说已经被弃用，但是在示例中还是经常能看见。</p><p>经过比较，感觉还是glut更方便。(⊙o⊙)…</p><p>由于不会深入研究openGL，后面统一使用glut</p><h3 id="glutSwapBuffers-与双缓冲区"><a href="#glutSwapBuffers-与双缓冲区" class="headerlink" title="glutSwapBuffers 与双缓冲区"></a><code>glutSwapBuffers</code> 与双缓冲区</h3><p><code>glutSwapBuffers</code> 是 GLUT（OpenGL Utility Toolkit）库中的一个函数，通常在使用双缓冲区（double buffering）时使用。它用于在绘制图形完成后，交换前后缓冲区的内容，以实现平滑的图形更新。下面是对 <code>glutSwapBuffers</code> 函数的中文详解：</p><ol><li><p><strong>缓冲区（Buffer）</strong>：在计算机图形中，缓冲区是内存中的特定区域，用于存储图像数据。常见的缓冲区类型包括前缓冲区（front buffer）和后缓冲区（back buffer）。</p></li><li><p><strong>双缓冲区（Double Buffering）</strong>：双缓冲区是一种图形绘制技术，它使用两个缓冲区来减少屏幕闪烁和提高图形渲染的效果。一个缓冲区用于绘制图像（后缓冲区），另一个缓冲区用于显示（前缓冲区）。这允许在后缓冲区中绘制图像，然后一次性将其显示在屏幕上，减少了用户可见的渲染过程。</p></li><li><p><strong>glutSwapBuffers 函数</strong>：<code>glutSwapBuffers</code> 是 GLUT 库提供的函数之一，它用于切换前后缓冲区，即将后缓冲区的内容复制到前缓冲区，使得用户能够看到刚刚绘制的图像。</p></li><li><p><strong>使用场景</strong>：<code>glutSwapBuffers</code> 通常在绘制完成后（例如，在 <code>display</code> 回调函数中）调用，以实现图像的平滑更新。在单缓冲区模式下，你会直接绘制在屏幕上，这可能会导致图像闪烁和不稳定。双缓冲区允许你预先绘制一个完整的图像，然后在用户看到之前交换缓冲区，以避免这些问题。</p></li><li><p><strong>使用示例</strong>：通常的用法如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glutSwapBuffers</span>();</span><br></pre></td></tr></tbody></table></figure><p>这会将后缓冲区的内容交换到前缓冲区，使绘制的图形变得可见。</p></li></ol><p>总之，<code>glutSwapBuffers</code> 函数是用于在双缓冲区中实现平滑图形更新的关键函数。通过在绘制完成后调用它，你可以确保用户看到的图形是完整和稳定的，减少了屏幕闪烁和不完整图像的问题。这在交互式图形应用程序和游戏开发中特别有用。</p><h3 id="什么时候用glutSwapBuffers，什么时候用glFlush？"><a href="#什么时候用glutSwapBuffers，什么时候用glFlush？" class="headerlink" title="什么时候用glutSwapBuffers，什么时候用glFlush？"></a>什么时候用<code>glutSwapBuffers</code>，什么时候用<code>glFlush</code>？</h3><p><code>glutSwapBuffers</code> 和 <code>glFlush</code> 都是用于刷新绘图窗口的函数，但它们的使用场景和行为略有不同。</p><ol><li><p><strong>glutSwapBuffers</strong>：</p><ul><li><strong>双缓冲区</strong>：<code>glutSwapBuffers</code> 主要用于双缓冲区渲染模式。在双缓冲区中，你绘制图像在后缓冲区中，然后使用 <code>glutSwapBuffers</code> 将后缓冲区的内容切换到前缓冲区，以使其在屏幕上可见。</li><li><strong>典型用途</strong>：通常，在使用双缓冲区时，<font color="orange">在绘制完成后，你会调用 <code>glutSwapBuffers</code> 来刷新窗口，以显示绘制的图像</font>。</li></ul></li><li><p><strong>glFlush</strong>：</p><ul><li><strong>单缓冲区</strong>：<code>glFlush</code> 适用于单缓冲区渲染模式，其中你直接绘制到前缓冲区，而不涉及后缓冲区。**<font color="green">在单缓冲区模式中，图像将立即绘制到屏幕上。</font>**</li><li><strong>典型用途</strong>：<code>glFlush</code> 通常用于单缓冲区模式，当你需要立即将图像绘制到屏幕上时，可以使用 <code>glFlush</code>。它会立即刷新图形缓冲区。</li></ul></li></ol><p><strong>选择使用哪一个函数取决于你的渲染需求</strong>：</p><ul><li>如果你使用双缓冲区，通常使用 <code>glutSwapBuffers</code> 以确保绘制的图像在用户可见之前被交换到前缓冲区。</li><li>如果你使用单缓冲区或者需要实时渲染效果，你可以使用 <code>glFlush</code> 以立即将图像绘制到屏幕上。</li></ul><p>请根据你的应用程序的渲染模式和性能要求来选择合适的函数。在许多情况下，使用双缓冲区和 <code>glutSwapBuffers</code> 会提供更流畅的图形更新，特别是对于需要避免图像闪烁的应用程序。</p><h3 id="怎么确定是单缓冲区还是双缓冲区？"><a href="#怎么确定是单缓冲区还是双缓冲区？" class="headerlink" title="怎么确定是单缓冲区还是双缓冲区？"></a>怎么确定是单缓冲区还是双缓冲区？</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glutInitDisplayMode</span>(GLUT_RGB | GLUT_SINGLE);<span class="comment">//单缓冲区</span></span><br><span class="line"><span class="built_in">glutInitDisplayMode</span>(GLUT_RGB | GLUT_DOUBLE);<span class="comment">//双缓冲区</span></span><br><span class="line"><span class="comment">//这个通常写在main函数里面</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> VS2022 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/27/hello-world/"/>
      <url>/2023/09/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
