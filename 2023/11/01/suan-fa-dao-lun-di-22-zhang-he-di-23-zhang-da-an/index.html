<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="算法导论第22章和第23章答案, MySite">
    <meta name="description" content="
深度优先森林将图的边分为树边、向后边、向前边和交叉边。宽度优先树还可以用于将从搜索源可到达的边分类为相同的四个类别。
**A.**证明在无向图的广度优先搜索中，以下性质成立：

没有后边缘也没有前边缘。
对于每个树边$(u, v)$，我们">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>算法导论第22章和第23章答案 | MySite</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/favicon.png">
    
    <style>
        body{
            background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/css/matery.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/css/my.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/css/post.css">




    



    <script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">MySite</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">MySite</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">算法导论第22章和第23章答案</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-11-01
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    22.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    90 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <blockquote>
<p>深度优先森林将图的边分为树边、向后边、向前边和交叉边。宽度优先树还可以用于将从搜索源可到达的边分类为相同的四个类别。</p>
<p>**A.**证明在无向图的广度优先搜索中，以下性质成立：</p>
<ol>
<li>没有后边缘也没有前边缘。</li>
<li>对于每个树边$(u, v)$，我们有$v.d = u.d + 1$。</li>
<li>对于每个交叉边$(u, v)$，我们有$v.d = u.d$或$v.d = u.d + 1$。</li>
</ol>
<p><strong>乙。</strong>证明在有向图的广度优先搜索中，以下性质成立：</p>
<ol>
<li>没有向前的边。</li>
<li>对于每个树边$(u, v)$，我们有$v.d = u.d + 1$。</li>
<li>对于每个交叉边缘$(u, v)$，我们有$v.d \le u.d + 1$。</li>
<li>对于每个后沿$(u, v)$，我们有$0 \le v.d \le u.d$。</li>
</ol>
</blockquote>
<p><strong>A.</strong></p>
<ol>
<li><p>如果我们找到一条后边，这意味着有两个顶点，一个是另一个的后代，但已经有一条从祖先到子代的路径，这条路径不涉及在树中向上移动。这是一个矛盾，因为 BFS 树中唯一的子节点是那些只有一条边的子节点，这意味着不可能有任何其他路径到达该子节点，因为这将使其超过一条边。为了看到没有前沿，我们做了一个类似的过程。向前的边意味着从一个给定的顶点，我们注意到它有一个已经被处理过的子节点，但这不可能发生，因为所有的子节点都只有一条边的距离，并且对于已经被处理过的顶点，它需要先经过其他一些顶点。</p>
</li>
<li><p>如果边到达尚未考虑的顶点，则将其放置在要处理的列表上。这意味着从该顶点到根的路径必须至少等于到当前顶点的距离加上$1$。最多也是这样，因为我们可以只取一条路径，这条路径包括到当前顶点并取其到根的路径。</p>
</li>
<li><p>我们知道，交叉边不能深入到小于 1 的深度，否则在处理前面的元素时，它将被用作树边。它也不能去一个深度超过一个的顶点，因为我们不会已经处理了一个离根很远的顶点。由于交叉边中顶点的深度不能超过一个，因此可以通过交换和$v$的$u$角色来得出结论，我们可以这样做，因为边是无序的。</p>
</li>
</ol>
<p><strong>乙。</strong></p>
<ol>
<li><p>要获得前向边，我们需要已经使用多条边处理了一个顶点，即使存在使用一条边到达该顶点的路径。由于广度优先搜索总是首先考虑较短的路径，因此这是不可能的。</p>
</li>
<li><p>假设这$(u, v)$是一条树边。那么，这意味着存在一条长度$u.d + 1$为的从根到$v$的路径，只需将其附加$(u, v)$到从根到$u$的路径即可。为了看到没有更短的路径，我们只是注意到我们会更快地处理$v$，所以如果有的话，目前不会有树边。</p>
</li>
<li><p>要看到这一点，我们所需要做的就是注意到有一些从根到$v$的路径，其长度$u.d + 1$是通过附加$(u, v)$到$v.d$而获得的。由于存在该长度的路径，因此它用作从根到$v$的所有此类路径的最小长度的上限。</p>
</li>
<li><p>这是微不足道的$0 \le v.d$，因为不可能有一条从根到$v$负长度的路径。更有趣的不平等是$v.d \le u.d$。我们知道有一条从$v$到$u$的路径，由树的边组成，这是后沿的$(u, v)$定义属性。这意味着它$v, v_1, v_2, \dots, v_k, u$是这条路径（它是唯一的，因为树边形成了一棵树）。那么，我们有那个$u.d = v_k.d + 1 = v_{k − 1}.d + 2 = \cdots = v_1.d + k = v.d + k + 1$。所以，我们有那个$u.d &gt; v.d$。事实上，我们刚刚展示了我们有更有力的结论，那就是$0 \le v.d &lt; u.d$。</p>
</li>
</ol>
<blockquote>
<p>设$G = (V, E)$是一个连通的无向图。OF**<em>关节点</em><strong>$G$是其移除断开$G$的顶点。</strong><em>桥</em><strong>的$G$是其移除断开$G$的边。A</strong><em>双连接组件</em>**OF$G$是一个极大边集，使得集合中的任意两条边都位于一个公共的简单圈上。图 22.10 说明了这些定义。我们可以使用深度优先搜索来确定关节点、桥和双连接组件。设$G_\pi = (V, E_\pi)$是的$G$深度优先树。</p>
<p>**A.**证明的根$G_\pi$是的$G$关节点当且仅当它在中$G_\pi$至少有两个子根。</p>
<p><strong>乙。</strong>设$v$是的$G_\pi$非根顶点。证明$v$是的关节点$G$，当且仅当$v$有一个子节点$s$，使得没有从$s$的后沿或到的$v$正确祖先的$s$任何后代。</p>
<p>**C.**让。</p>
<p>$$<br>v.low = \min<br>\begin{cases}<br>v.d, \\<br>w.d:(u,w) \text{ is a back edge for some descendant } u \text{ of } v.<br>\end{cases}<br>$$</p>
<p>演示如何及时计算$v.low$所有顶点$v \in V$$O(E)$。</p>
<p>**D.**演示如何及时计算所有关节点$O(E)$。</p>
<p>**E.**证明的$G$边是桥当且仅当它不位于的$G$任何简单圈上。</p>
<p>**F.**展示如何计算时间的$G$$O(E)$所有桥梁。</p>
<p>**G.**证明的双连通分支$G$划分的$G$非桥边。</p>
<p>**H.**给出一个$O(E)$时间算法，用一个正整数$e.bcc$标记的$G$每条边$e$，使得$e.bcc = e’.bcc$当且仅当$e$和$e’$在同一个双连通分量中。</p>
</blockquote>
<p>**A.**首先假设的$G_\pi$根$r$是一个关节点。则从中$G$删除$r$将导致图形断开连接，因此$r$中$G$至少$2$有个子项。如果$r$中$G_\pi$只有一个子元素$v$，则必须有一条$v$到其他每个子元素的$r$路径。由于删除$r$断开了图，因此必须存在顶点$u$和$w$，以便从$u$到$w$的唯一路径包含$r$。</p>
<p>若要从$u$到达$r$，路径必须首先到达的$r$一个子项。此子项通过不包含$r$的路径连接到$v$。</p>
<p>要到达$w$，路径还必须通过它的一个子级离开$r$，该子级也可以通过$v$到达。这意味着有一条$u$$w$不包含$r$矛盾的路径。</p>
<p>现在假设$r$至少有两个孩子$u$，并且$v$在$G_\pi$。则不存在不经过$r$的从$u$到$v$$G$的路径，否则$u$将是的$v$祖先。因此，移除$r$断开了组件包含$u$和组件包含$v$，因此$r$是一个关节点。</p>
<p><strong>乙。</strong>假设$v$是的$G_\pi$非根顶点，并且$v$有一个子顶点$s$，使得的后代都$s$$s$没有到的正确祖先$v$的后边。设$r$为的$v$祖先，并从$G$其移除$v$。由于我们是在无向的情况下，图中唯一的边是树边或后边，这意味着与$s$关联的每条边都会将我们带到的$s$后代，并且没有后代具有后边，因此在任何时候我们都不能通过取边来向上移动树。因此$r$是不可到达的$s$，所以图形是断开的，并且$v$是一个关节点。</p>
<p>现在假设，对于的$v$每个子代，都存在该子代的一个后代，该后代具有到的正确祖先$v$的后沿。从.中删除$v$$G$。的$v$每个子树都是连通分支。在一个给定的子树中，找到一个顶点，该顶点有一条到的正确祖先$v$的后边。因为不是的$v$后代的顶点的集合$T$形成了一个连通分量，所以的每个子树$v$都是连通$T$的。因此，在删除 So$v$后，图形仍保持连接，$v$不是关节点。</p>
<p>**C.**由于$v$在其所有后代之前被发现，因此唯一可能影响$v.low$的后边缘是从的$v$后代到的正确祖先$v$的后边缘。如果我们知道$u.low$的$v$每个孩子$u$，那么我们就可以很容易地计算$v.low$，因为所有的信息都被编码在它的后代中。</p>
<p>因此，我们可以递归地写出算法：如果$v$是中的$G_\pi$叶子，则$v.low$是的最小值，$v.d$$w.d$其中$(v, w)$是后沿。如果$v$不是叶，$v$则是的最小值$v.d$，$w.d$其中$(v, w)$是后边缘，并且$u.low$，其中$u$是的$v$子级。计算$v.low$顶点的次数是线性的。顶点度数之和是边数的两倍，因此总运行时间为$O(E)$。</p>
<p>**D.**首先应用部分（C）$O(E)$的算法来计算$v.low$所有$v \in V$。如果$v.low$=$v.d$当且仅当的$v$后代都不具有的正确祖先$v$的后边缘时，当且仅当$v$不是关节点时。</p>
<p>因此，我们只需要检查$v.low$与$v.d$在恒定时间内决定是否$v$是一个关节点，所以运行时是$O(E)$。</p>
<p>**E.**一条边$(u, v)$位于一个简单圈上，当且仅当至少存在一条从$u$到$v$的路径不包含该边$(u, v)$，当且仅当移除$(u, v)$不会断开图，当且只当$(u, v)$不是桥。</p>
<p>**F.**一条边$(u, v)$位于无向图中的一个简单圈上，当且仅当它的两个端点都是关节点，或者它的一个端点是关节点，另一个端点是度$1$顶点。还有一种特殊情况，即只有一条边的关联顶点都是度$1$。我们可以在恒定时间内检查这种情况。由于我们可以计算中的$O(E)$所有关节点，并且我们可以在常数时间内确定顶点是否具有度数$1$，因此我们可以运行部分（d）中的算法，然后在常数时间内确定每条边是否是桥，这样我们就可以及时找到所有的$O(E)$桥。</p>
<p>**G.**很明显，每个非桥边都在某个双连通分量中，因此我们需要证明如果$C_1$和$C_2$是不同的双连通分量，则它们不包含公共边。相反，假设$(u, v)$在$C_1$和$C_2$中都有。</p>
<p>设$(a, b)$为中的$C_1$任意边，且$(c, d)$为中的$C_2$任意边。</p>
<p>然后$(a, b)$位于一个简单的循环$(u, v)$上，由路径组成</p>
<p>$$a, b, p_1, \ldots, p_k, u, v, p_{k + 1}, \ldots, p_n, a.$$</p>
<p>Similarly, $(c, d)$ lies on a simple cycle with $(u, v)$ consisting of the path</p>
<p>$$C，d，Q_1，\ldots，Q_m，u，V，Q_{m+1}，\ldots，Q_l，C.$$</p>
<p>这意味着</p>
<p>$$a, b, p_1, \ldots, p_k, u, q_m, \ldots, q_1, d, c, q_l , \ldots, q_{m + 1}, v, p_{k + 1}, \ldots, p_n,$$</p>
<p>是一个包含$(a, b)$和$(c, d)$的简单循环，是一个矛盾。因此，双连接组件形成了一个分区。</p>
<p>使用部分（f）中描述的算法及时**H.**定位所有桥边缘$O(E)$。从中$E$删除每个网桥。双连通组件现在只是连通组件中的边。假设已经这样做了，运行下面的算法，该算法显然在中$O(|E|)$运行，其中$|E|$是最初在中$G$的边数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VISIT-<span class="built_in">BCC</span>(G, u, k)</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">for</span> each v ∈ G.Adj[u]</span><br><span class="line">        (u, v).bcc = k</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            VISIT-<span class="built_in">BCC</span>(G, v, k)</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>强连通有向图$G = (V, E)$**<em>欧拉之旅</em>**中的圈是恰好遍历每个边一次的$G$圈，尽管它可能不止一次访问一个顶点。</p>
<p>当且仅当$\text{in-degree}(v) = \text{out-degree}(v)$对于每个顶点$v \in V$，**A.**显示$G$具有 Euler 环游。</p>
<p><strong>乙。</strong>描述一个$O(E)$时间算法来查找 Euler 路径$G$（如果存在）。（$\textit{提示：}$merge edge-disjoint cycles.）</p>
</blockquote>
<p>**A.**首先，我们将证明每个顶点的入度必须等于出度。假设有一个顶点 V，这两个顶点不相等，假设$\text{in-degree}(v) - \text{out-degree}(v)$。请注意，我们可以假设 In 度更大，否则我们只需查看向后遍历循环的转置图。如果$v$是列出的循环的开始，只需将开始和结束顶点移动到循环上的任何其他顶点。然后，在我们进行$v$的任何循环中，我们必须通过$v$一定的次数，特别是，在我们通过一次之后，未使用的边的数量$v$为零，然而，仍然有未使用的边需要使用。这意味着没有希望使用这些，而仍然是一个旅游，因为我们将永远无法逃脱$v$，并回到旅游开始的顶点。现在，我们证明了每个顶点的入度和出度相等就足够了。为了做到这一点，我们将把问题稍微一般化，以便它更适合于归纳方法。也就是说，我们将证明，对于每个有两个顶点$v$的图$G$，并且$u$所有顶点都有相同的入度和出度，除了入度比出度大$u$一，$v$那么就有一条从$v$到$u$的欧拉路径。如果我们选择$u = v$图中的任何顶点，这显然与原始语句一致。我们现在对边的数量进行归纳。如果只有一条边，那么只取这条边就是欧拉之旅。然后，假设我们从$v$它开始，并取它的任何边。考虑通过移除该边而获得的图，它归纳地包含一个欧拉路径，我们可以将其后挂到我们要离开$v$的边。</p>
<p><strong>乙。</strong>为了真正得到欧拉回路，我们可以任意走任何我们想走的路，只要我们不重复一条边，我们就一定会得到一个有效的欧拉回路。这是在下面的算法中实现的，$\text{EULER-TOUR}(G)$这需要时间$O(|E|)$。它之所以有这样的运行时间，是因为 for 循环将为每条边运行，并且需要恒定的时间量。此外，初始化每个边的颜色的过程将花费与边的数量成比例的时间。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EULER-<span class="built_in">TOUR</span>(G)</span><br><span class="line">    <span class="function">color all edges WHITE</span></span><br><span class="line"><span class="function">    <span class="title">let</span> <span class="params">(v, u)</span> be any edge</span></span><br><span class="line"><span class="function">    let L be a list containing v</span></span><br><span class="line"><span class="function">    <span class="keyword">while</span> there is some WHITE <span class="title">edge</span> <span class="params">(v, w)</span> coming out of v</span></span><br><span class="line"><span class="function">        <span class="title">color</span> <span class="params">(v, w)</span> BLACK</span></span><br><span class="line"><span class="function">        v </span>= w</span><br><span class="line">        append v to L</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>设$G = (V, E)$是一个有向图，其中每个顶点$u \in V$都标有集合$\{1, 2, \ldots, |V|\}$中的唯一整数$L(U)$。对于每个顶点$u \in V$，设$R(u) = \{v \in V: u \leadsto v \}$为可到达$u$的顶点的集合。定义$\min(u)$为标签最小的顶点$R(u)$，即，$\min(u)$是满足以下条件$L(v) = \min \{L(w): w \in R(u) \}$的顶点$v$。给出$O(V + E)$计算$\min(u)$所有顶点$u \in V$的时间算法。</p>
</blockquote>
<p>**1.**计算分量图$G^{\text{SCC}}$（以便从图$G$中删除简单圈），并用其中$G^{\text{SCC}}$顶点的最小标签标记中的$G^{\text{SCC}}$每个顶点。根据第 22.5 章，该过程的时间复杂度为$O(V + E)$。</p>
<p>**2.**在上$G^{\text{SCC}}$，执行以下算法。请注意，如果我们记住这个函数，它将在大多数$V + E$情况下被调用。其时间复杂度也$O(V + E)$是。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">REACHABILITY</span>(u)</span><br><span class="line">    u.min = u.label</span><br><span class="line">    <span class="keyword">for</span> each v ∈ Adj[u]</span><br><span class="line">        u.min = <span class="built_in">min</span>(u.min, <span class="built_in">REACHABILITY</span>(v))</span><br><span class="line">    <span class="keyword">return</span> u.min</span><br></pre></td></tr></tbody></table></figure>

<p>**3.**回到 Graph$G$，On Graph$G$的$\min(u)$值是 On Graph$G^{\text{SCC}}$的$\min(u.scc)$值。</p>
<p><strong>替代解决方案：</strong>转置图形。调用$\text{DFS}$，但在的$\text{DFS}$主循环中，按顶点的标签顺序考虑顶点。$\text{DFS-VISIT}$在子例程中，在发现新节点时，我们将其$\text{min}$设置为其根的标签。</p>
<h2 id="22-1-1"><a href="#22-1-1" class="headerlink" title="22.1-1"></a>22.1-1</h2><blockquote>
<p>给定一个有向图的邻接表表示，计算每个顶点的$\text{out-degree}$需要多长时间？计算$\text{in-degree}$S 需要多长时间？</p>
</blockquote>
<ul>
<li><p>计算每个顶点的$\text{out-degree}$时间为</p>
<p>  $$\sum_{v \in V}O(\text{out-degree}(v)) = O(|E| + |V|),$$</p>
<p>  这很显然</p>
</li>
<li><p>至于$\text{in-degree}$,我们必须扫描所有邻接表，并记录每个顶点被指向的次数。因此，时间复杂度也是 $O(|E|+|V|)$，因为我们要访问所有节点和边。</p>
</li>
</ul>
<h2 id="22-1-2"><a href="#22-1-2" class="headerlink" title="22.1-2"></a>22.1-2</h2><blockquote>
<p>给出一棵顶点为 $7$ 的完整二叉树的邻接表。给出等价的邻接矩阵表示法。假设顶点的编号从$1$到$7$，就像二叉堆一样。</p>
</blockquote>
<ul>
<li><p><strong>Adjacency-list representation</strong></p>
<p>  $$<br>  \begin{aligned}<br>  1 &amp; \to 2 \to 3 \\<br>  2 &amp; \to 1 \to 4 \to 5 \\<br>  3 &amp; \to 1 \to 6 \to 7 \\<br>  4 &amp; \to 2 \\<br>  5 &amp; \to 2 \\<br>  6 &amp; \to 3 \\<br>  7 &amp; \to 3<br>  \end{aligned}<br>  $$</p>
</li>
<li><p><strong>Adjacency-matrix representation</strong></p>
<p>  $$<br>  \begin{array}{c|ccccccc|}<br>&amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 \\<br>  \hline<br>  1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  2 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\<br>  3 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\<br>  4 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  5 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  6 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  7 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>  \hline<br>  \end{array}<br>  $$</p>
</li>
</ul>
<h2 id="22-1-3"><a href="#22-1-3" class="headerlink" title="22.1-3"></a>22.1-3</h2><blockquote>
<p>有向图$G = (V, E)$的**<em>转置</em>**是图$G^\text T = (V, E^\text T)$，其中$E^\text T = \{(v, u) \in V \times V: (u, v) \in E \}$。因此，$G^\text T$它$G$的所有边都颠倒了。描述从$G$计算$G^\text T$的有效算法，用于的$G$邻接表和邻接矩阵表示。分析算法的运行时间。</p>
</blockquote>
<ul>
<li><p><strong>邻接表表示</strong></p>
<p>  假设原始邻接表为$Adj$。</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let Adj<span class="number">'</span>[<span class="number">1.</span>.|V|] be a <span class="keyword">new</span> adjacency list of the transposed G^T</span><br><span class="line"><span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ Adj[u]</span><br><span class="line">        <span class="built_in">INSERT</span>(Adj<span class="number">'</span>[v], u)</span><br></pre></td></tr></tbody></table></figure>

<p>  时间复杂度：$O(|E| + |V|)$。</p>
</li>
<li><p><strong>邻接矩阵表示</strong></p>
<p>  通过查看对角线上方的每个条目，并将其与对角线下方出现的条目交换，来转置原始矩阵。</p>
<p>  时间复杂度：$O(|V|^2)$。</p>
</li>
</ul>
<h2 id="22-1-4"><a href="#22-1-4" class="headerlink" title="22.1-4"></a>22.1-4</h2><blockquote>
<p>给定多重图$G = (V, E)$的邻接表表示，描述$O(V + E)$计算“等价”无向图的邻接表表示的时间算法$G’ = (V, E’)$，其中$E’$由两个顶点之间的所有多条边替换为一条边并删除所有自环的边$E$组成。</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EQUIVALENT-UNDIRECTED-GRAPH</span><br><span class="line">    let Adj<span class="number">'</span>[<span class="number">1.</span>.|V|] be a <span class="keyword">new</span> adjacency list</span><br><span class="line">    let A be a <span class="number">0</span>-initialized array of size |V|</span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        <span class="keyword">for</span> each v ∈ Adj[u]</span><br><span class="line">            <span class="keyword">if</span> v != u &amp;&amp; A[v] != u</span><br><span class="line">                A[v] = u</span><br><span class="line">                <span class="built_in">INSERT</span>(Adj<span class="number">'</span>[u], v)</span><br></pre></td></tr></tbody></table></figure>

<p>请注意$A$，在内部 for 循环的每次迭代之前，不包含任何具有值$u$的元素。这就是为什么我们使用$A[v] = u$在内部 for 循环中标记边$(u, v)$的存在。因为我们在邻接表$Adj$$|V| + |E|$中查找时间，所以时间复杂度是$O(|V| + |E|)$。</p>
<h2 id="22-1-5"><a href="#22-1-5" class="headerlink" title="22.1-5"></a>22.1-5</h2><blockquote>
<p>有向图$G = (V, E)$的**<em>正方形</em>**是使得$(u, v) \in E^2$当且仅当$G$包含一条在和$v$之间最多有两条边$u$的路的图$G^2 = (V, E^2)$。描述计算$G^2$$G$的邻接表和邻接矩阵表示的$G$有效算法。分析算法的运行时间。</p>
</blockquote>
<ul>
<li><p><strong>邻接表表示</strong></p>
<p>  为了从的$G$邻接表表示$Adj$进行计算$G^2$，我们对每个$Adj[u]$执行以下操作：</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each v ∈ Adj[u]</span><br><span class="line">    <span class="built_in">INSERT</span>(Adj2[u], v)</span><br><span class="line">    <span class="keyword">for</span> each w ∈ Adj[v]</span><br><span class="line">        <span class="comment">// edge(u, w) ∈ E^2</span></span><br><span class="line">        <span class="built_in">INSERT</span>(Adj2[u], w)</span><br></pre></td></tr></tbody></table></figure>

<p>  其中$Adj2$是的$G^2$邻接表表示。对于我们扫描的最多$|V|$顶点中的$Adj$每条边，我们及时$O(|V||E|)$计算$Adj2$。</p>
<p>  在我们计算$Adj2$之后，我们必须从列表中删除重复的边。删除重复的边是在中完成$O(V + E’)$的，其中$E’ = O(VE)$是中$Adj2$的边数，如练习 22.1-4 所示。因此，总运行时间为</p>
<p>  $$O（VE）+O（V+VE）=O（VE）。$$</p>
<p>  但是，如果原始图$G$包含自环，我们应该修改算法，以便不删除自环。</p>
</li>
<li><p><strong>邻接矩阵表示</strong></p>
<p>  设$A$表示的$G$邻接矩阵表示。的邻接矩阵表示$G^2$是的$A$平方。计算$A^2$可以及时$O(V^3)$完成（理论上甚至更快；例如，Strassen 的算法将在中$O(V^{\lg 7})$计算$A^2$。</p>
</li>
</ul>
<h2 id="22-1-6"><a href="#22-1-6" class="headerlink" title="22.1-6"></a>22.1-6</h2><blockquote>
<p>大多数将邻接矩阵表示作为输入的图算法都需要时间$\Omega(V^2)$，但也有一些例外。展示如何确定一个有向图$G$是否包含**<em>通用水槽</em>**$-$一个在时间上$O(V)$具有$\text{in-degree}$$|V| - 1$和$\text{out-degree}$$0$$-$的顶点，给定一个邻接矩阵$G$。</p>
</blockquote>
<p>从检查邻接矩阵中的位置$(1, 1)$开始。当检查位置$(i, j)$时，</p>
<ul>
<li>如果遇到 A$1$，则检查位置$(i + 1, j)$，并</li>
<li>如果$0$遇到，请检查位置$(i, j + 1)$。</li>
</ul>
<p>一旦或$i$$j$等于$|V|$，则终止。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IS-CONTAIN-UNIVERSAL-<span class="built_in">SINK</span>(M)</span><br><span class="line">    i = j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; |V| <span class="keyword">and</span> j &lt; |V|</span><br><span class="line">        <span class="comment">// There's an out-going edge, so examine the next row</span></span><br><span class="line">        <span class="keyword">if</span> M[i, j] == <span class="number">1</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="comment">// There's no out-going edge, so see if we could reach the last column of current row</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> M[i, j] == <span class="number">0</span></span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">    check <span class="keyword">if</span> vertex i is a universal sink</span><br></pre></td></tr></tbody></table></figure>

<p>如果一个图包含一个通用汇点，那么它一定在顶点$i$。</p>
<p>为了看到这一点，假设顶点$k$是一个通用汇点。因为$k$是一个通用接收器，所以行$k$将用$0$“S ”填充，列$k$将用$1$“S ”填充，除了用“A$0$”填充的$M[k, k]$。最后，一旦行$k$被命中，算法将继续增加列$j$，直到$j = |V|$。</p>
<p>为了确保最终命中行$k$，请注意，一旦到达列$k$，算法将继续递增$i$，直到到达为止$k$。</p>
<p>该算法在中$O(V)$运行，并在中$O(V)$检查顶点$i$是否为通用接收器。因此，总运行时间为$O(V) + O(V) = O(V)$。</p>
<h2 id="22-1-7"><a href="#22-1-7" class="headerlink" title="22.1-7"></a>22.1-7</h2><blockquote>
<p>没有自环的有向图$G = (V, E)$的**<em>关联矩阵</em>**是一个$|V| \times |E|$矩阵$B = (b_{ij})$，使得</p>
<p>$$<br>b_{ij} =<br>\begin{cases}<br>-1 &amp; \text{if edge $j$ leaves vertex $i$}, \\<br> 1 &amp; \text{if edge $j$ enters vertex $i$}, \\<br> 0 &amp; \text{otherwise}.<br>\end{cases}<br>$$</p>
<p>描述矩阵乘积$BB^\text T$的元素表示什么，其中$B^\text T$是的$B$转置。</p>
</blockquote>
<p>$$BB^\text T(i, j) = \sum\limits_{e \in E}b_{ie} b_{ej}^\text T = \sum\limits_{e \in E} b_{ie}b_{je}.$$</p>
<ul>
<li>If $i = j$, then $b_{ie} b_{je} = 1$ (it is $1 \cdot 1$ or $(-1) \cdot (-1)$) whenever $e$ enters or leaves vertex $i$, and $0$ otherwise.</li>
<li>If $i \ne j$, then $b_{ie} b_{je} = -1$ when $e = (i, j)$ or $e = (j, i)$, and $0$ otherwise.</li>
</ul>
<p>Thus,</p>
<p>$$<br>BB^\text{T}(i, j) =<br>\begin{cases}<br>\text{degree of } i = \text{in-degree} + \text{out-degree} &amp; \text{if } i = j, \\<br>-\text{(number of edges connecting } i \text{ and } j) &amp; \text{if } i \ne j.<br>\end{cases}<br>$$</p>
<h2 id="22-1-8"><a href="#22-1-8" class="headerlink" title="22.1-8"></a>22.1-8</h2><blockquote>
<p>假设每个数组条目$Adj[u]$不是链表，而是包含顶点$v$的哈希表$(u, v) \in E$。如果所有边查找的可能性相等，则确定边是否在图中的预期时间是多少？这个方案有什么缺点？为解决这些问题的每个边列表建议一个替代数据结构。与哈希表相比，你的替代方案是否有缺点？</p>
</blockquote>
<p>预期的查找时间为$O(1)$，但在最坏的情况下可能需要$O(|V|)$。</p>
<p>如果我们首先对每个邻接表中的顶点进行排序，则我们可以执行二分搜索，以便最坏情况的查找时间为$O(\lg |V|)$，但这具有更差的预期查找时间的缺点。</p>
<h2 id="22-2-1"><a href="#22-2-1" class="headerlink" title="22.2-1"></a>22.2-1</h2><blockquote>
<p>使用顶点$3$作为源，显示在图 22.2（a）的有向图上运行宽度优先搜索得到的$d$和$\pi$值。</p>
</blockquote>
<p>$$<br>\begin{array}{c|cccccc}<br>\text{vertex} &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\<br>\hline<br>d &amp; \infty &amp; 3 &amp; 0 &amp; 2 &amp; 1 &amp; 1 \\<br>\pi &amp; \text{NIL} &amp; 4 &amp; \text{NIL} &amp; 5 &amp; 3 &amp; 3<br>\end{array}<br>$$</p>
<h2 id="22-2-2"><a href="#22-2-2" class="headerlink" title="22.2-2"></a>22.2-2</h2><blockquote>
<p>使用顶点$u$作为源，显示在图 22.3 的无向图上运行宽度优先搜索得到的$d$和$\pi$值。</p>
</blockquote>
<p>$$<br>\begin{array}{c|cccccc}<br>\text{vertex} &amp; r &amp; s &amp; t &amp; u &amp; v &amp; w &amp; x &amp; y \\<br>\hline<br>d &amp; 4 &amp; 3 &amp; 1 &amp; 0 &amp; 5 &amp; 2 &amp; 1 &amp; 1 \\<br>\pi &amp; s &amp; w &amp; u &amp; \text{NIL} &amp; r &amp; t &amp; u &amp; u<br>\end{array}<br>$$</p>
<h2 id="22-2-3"><a href="#22-2-3" class="headerlink" title="22.2-3"></a>22.2-3</h2><blockquote>
<p>通过论证如果删除第 5 行和第 14 行，该$\text{BFS}$过程将产生相同的结果，表明使用单个位来存储每个顶点颜色就足够了。</p>
</blockquote>
<p>出于教学目的，教科书引入了$\text{GRAY}$颜色，以区分$\text{GRAY}$节点（入队）和$\text{BLACK}$节点（出队）。</p>
<p>因此，使用单个位来存储每个顶点颜色就足够了。</p>
<h2 id="22-2-4"><a href="#22-2-4" class="headerlink" title="22.2-4"></a>22.2-4</h2><blockquote>
<p>如果我们用邻接矩阵来表示它的输入图，并修改算法来处理这种形式的输入，那么它的运行时间$\text{BFS}$是多少？</p>
</blockquote>
<p>迭代所有边的时间变为$O(V^2)$$O(E)$。因此，运行时间为$O(V + V^2) = O(V^2)$。</p>
<h2 id="22-2-5"><a href="#22-2-5" class="headerlink" title="22.2-5"></a>22.2-5</h2><blockquote>
<p>论证在广度优先搜索中，分配给顶点$u$的值$u.d$与顶点在每个邻接表中出现的顺序无关。以图 22.3 为例，说明由$\text{BFS}$计算的宽度优先树可以依赖于邻接表中的排序。</p>
</blockquote>
<p>首先，我们将展示分配给顶点的值$d$与条目在邻接表中出现的顺序无关。为了证明这一点，我们依赖于定理 22.5，它证明了的$\text{BFS}$正确性。特别地，该定理指出，$v.d = \delta(s, v)$在的$\text{BFS}$终止处。因为$\delta(s, v)$是基础图的属性，所以对于图的任何邻接表表示（包括邻接表的任何重新排序），$\delta(s, v)$都不会改变。由于这些$d$值对于邻接表的任何排序都是相等$\delta(s, v)$的并且$\delta(s, v)$是不变的，$d$因此也不依赖于邻接表的排序。</p>
<p>现在，为了说明这$\pi$确实依赖于邻接表的排序，我们将使用图 22.3 作为指导。</p>
<p>首先，我们注意到，在给定的计算过程中，我们在邻接表$w$中有，$t$在前面$x$。此外，在制定的程序中，我们有$u.\pi = t$。</p>
<p>现在，假设我们在的$w$邻接表中有$x$前导$t$。然后，它将被添加到队列之前$t$，这意味着在我们有机会处理的子代$t$之前，它将$u$作为它的子代。这将意味着$u.\pi = x$在邻接表$w$的这种不同排序中。</p>
<h2 id="22-2-6"><a href="#22-2-6" class="headerlink" title="22.2-6"></a>22.2-6</h2><blockquote>
<p>给出一个有向图$G = (V, E)$的例子，一个源顶点$s \in V$和一组树边$E_\pi \subseteq E$，使得对于每个顶点$v \in V$，图$(V, E_\pi)$中从$s$到$v$的唯一简单路径是中$G$的最短路径，但无论顶点在每个邻接表中如何排序，都不能通过运行$\text{BFS}$$G$产生边$E_\pi$的集合。</p>
</blockquote>
<p>设$G$为第一幅图中所示的图形，$G_\pi = (V, E_\pi)$为第二幅图中所示的图形，$s$为源顶点。</p>
<p>我们可以看到，$E_\pi$在上$G$运行 BFS 将永远不会产生。</p>
<center>
![](../img/22.2-6-2.png) ![](../img/22.2-6-1.png)
</center>

<ul>
<li>如果$y$在中$Adj[s]$位于前面$v$。我们将在之前$v$离开队列$y$，所以$u.\pi$和$x.\pi$都$y$是。然而，事实并非如此。</li>
<li>如果$v$在$Adj[s]$前面$y$。我们将在之前$y$出队$v$，所以$u.\pi$和$x.\pi$都$v$是，这也是不正确的。</li>
</ul>
<p>尽管如此，中$G_\pi$从$s$到任何顶点的唯一简单路径是中的$G$最短路径。</p>
<h2 id="22-2-7"><a href="#22-2-7" class="headerlink" title="22.2-7"></a>22.2-7</h2><blockquote>
<p>职业摔跤手有两种类型：“娃娃脸”（“好人”）和“高跟鞋”（“坏人”）。在任何一对职业摔跤手之间，可能有也可能没有竞争。假设我们有$n$职业摔跤手，我们有一$r$组有竞争关系的摔跤手。给出一个$O(n + r)$时间算法，该算法确定是否可以将一些摔跤手指定为娃娃脸，而将其余的摔跤手指定为脚跟，以便每次比赛都是在娃娃脸和脚跟之间进行。如果有可能执行这样的指定，你的算法应该产生它。</p>
</blockquote>
<p>这个问题基本上只是两种颜色的混淆版本。我们将尝试用“娃娃脸”和“脚跟”这两种颜色来给这张竞争图的顶点着色。没有两个娃娃脸和两个高跟鞋有竞争，就等于说颜色是合适的。对于两种颜色，我们对每个连通分量执行广度优先搜索，以获得每个顶点的$d$值。然后，我们给所有的奇数一个颜色说“脚跟”，所有的偶数 d 值一个不同的颜色。我们知道，在这个着色失败的地方，没有其他着色会成功，因为如果我们给出任何其他着色，我们会得到一个顶点$v$具有相同的颜色，$v.\pi$$v$并且$v.\pi$它们的$d$值必须具有不同的奇偶性。因为我们知道没有更好的着色，所以我们只需要检查每条边，看看这种着色是否有效。如果每条边都能正常工作，则可以找到一个指定，如果单个边失败，则不可能找到指定。由于 BFS$O(n + r)$和检查都需要$O(r)$时间，因此总运行时间为$O(n + r)$。</p>
<h2 id="22-2-8-star"><a href="#22-2-8-star" class="headerlink" title="22.2-8$\star$"></a>22.2-8$\star$</h2><blockquote>
<p>树$T = (V, E)$的**<em>直径</em>**定义为$\max_{u,v \in V} \delta(u, v)$，即，树中所有最短路径距离中的最大值。给出一个计算树直径的有效算法，并分析该算法的运行时间。</p>
</blockquote>
<p>假设 A 和 B 是树中达到直径的路径的端点，并且不失一般性地假设$a$和$b$是达到直径的唯一对。设$s$为中的$T$任意顶点。我们声称，一个单一$\text{BFS}$的结果将返回一个$a$或$b$（或两者）作为距离$s$最大的顶点。</p>
<p>为了看到这一点，假设与此相反，另一个顶点$x$显示为最远$s$。（请注意，$x$不能在从$a$到$b$的路径上，否则我们可以扩展）。那我们有</p>
<p>$$d(s, a) &lt; d(s, x)$$</p>
<p>and</p>
<p>$$d（s，B） &lt;d（s，X）。$$</p>
<p>让$c$表示从$a$到$b$最小化$d(s, c)$的路径上的顶点。既然图实际上是一棵树，我们必须有</p>
<p>$$d(s, a) = d(s, c) + d(c, a)$$</p>
<p>and</p>
<p>$$D（S，B）=D（S，C）+D（C，B）。$$</p>
<p>（如果有另一条路，我们可以形成一个循环）。利用上面提到的三角不等式、不等式和等式，我们必须</p>
<p>$$<br>\begin{aligned}<br>d(a, b) + 2d(s, c) &amp; = d(s, c) + d(c, b) + d(s, c) + d(c, a) \\<br>                   &amp; &lt; d(s, x) + d(s, c) + d(c, b).<br>\end{aligned}<br>$$</p>
<p>我声称$d(x, b) = d(s, x) + d(s, b)$。如果不是，那么根据三角不等式，我们必须有一个严格的小于。换句话说，有一些从$x$到$b$的路径没有经过$c$。这给出了矛盾，因为它意味着存在通过连接这些路径而形成的循环。那我们有</p>
<p>$$d（a，B） &lt;d（a，B）+2D（s，C） &lt;d（X，B）。$$</p>
<p>因为假设$d(a, b)$在所有对中是最大的，所以我们有一个矛盾。因此，由于树有$|V| - 1$边，我们可以运行$\text{BFS}$一次$O(V)$来获得其中一个顶点，该顶点是图中包含的最长简单路径的端点。再次运行$\text{BFS}$将告诉我们另一个在哪里，这样我们就可以解决树$O(V)$的直径问题。</p>
<h2 id="22-2-9"><a href="#22-2-9" class="headerlink" title="22.2-9"></a>22.2-9</h2><blockquote>
<p>设$G = (V, E)$是一个连通的无向图。给出一个$O(V + E)$时间算法来计算一条路径$G$，该路径在每个方向上恰好遍历每条边$E$一次。描述一下，如果给你大量的便士，你如何能找到走出迷宫的路。</p>
</blockquote>
<p>首先，该算法计算图的最小生成树。请注意，这可以使用第 23 章的程序来完成。也可以通过执行广度优先搜索，并限制到和$v.\pi$之间$v$的边缘来完成$v$。为了避免重复计算边，请事先确定顶点的顺序$\le$。然后，我们将通过调用$\text{MAKE-PATH}(s)$构造步骤序列，其中$s$是用于$\text{BFS}$的根。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MAKE-<span class="built_in">PATH</span>(u)</span><br><span class="line">    <span class="keyword">for</span> each v ∈ Adj[u] but <span class="keyword">not</span> in the tree such that u ≤ v</span><br><span class="line">        go to v <span class="keyword">and</span> back to u</span><br><span class="line">    <span class="keyword">for</span> each v ∈ Adj[u] but <span class="keyword">not</span> equal to u.π</span><br><span class="line">        go to v</span><br><span class="line">        perform the path proscribed by MAKE-<span class="built_in">PATH</span>(v)</span><br><span class="line">    go to u.π</span><br></pre></td></tr></tbody></table></figure>

<h2 id="22-3-1"><a href="#22-3-1" class="headerlink" title="22.3-1"></a>22.3-1</h2><blockquote>
<p>使用行和列标签$\text{WHITE}$、$\text{GRAY}$和$\text{BLACK}$制作$3$-by-$3$ 图表。在每个单元$(i, j)$中，指示在有向图的深度优先搜索期间的任何点处，是否可以存在从颜色$i$顶点到颜色$j$顶点的边。对于每个可能的边，指出它可以是什么类型的边。为无向图的深度优先搜索制作第二个这样的图表。</p>
</blockquote>
<p>根据定理 22.7（括号定理），顶点$u$间隔与$v$的关系有 3 种情况：</p>
<ul>
<li>$[u.d, u.f]$并且$[v.d, v.f]$是完全分离的，</li>
<li>$[u.d, u.f] \subset [v.d, v.f]$，以及</li>
<li>$[v.d, v.f] \subset [u.d, u.f]$。</li>
</ul>
<p>我们根据这个定理来判断可能性。</p>
<ul>
<li><p>对于<strong>有向图</strong>，我们可以使用练习 22.3-5 给出的边缘分类来简化问题。</p>
<p>  $$<br>  \begin{array}{c|ccc}<br>  from \diagdown to &amp; \text{WHITE}         &amp; \text{GRAY}                &amp; \text{BLACK} \\<br>  \hline<br>  \text{WHITE}      &amp; \text{All kinds}     &amp; \text{Cross, Back}         &amp; \text{Cross} \\<br>  \text{GRAY}       &amp; \text{Tree, Forward} &amp; \text{Tree, Forward, Back} &amp; \text{Tree, Forward, Cross} \\<br>  \text{BLACK}      &amp; -                    &amp; \text{Back}                &amp; \text{All kinds}<br>  \end{array}<br>  $$</p>
</li>
<li><p>对于<strong>无向图</strong>，从有向图开始，我们移除前向边和交叉边，并且</p>
<ul>
<li>当存在后边缘时，我们添加树边缘；</li>
<li>当一条树边存在时，我们添加一条后边。</li>
</ul>
<p>  这是正确的，原因如下：</p>
<ol>
<li>定理 22.10：在无向图$G$的深度优先搜索中，的$G$每条边要么是树，要么是后边。所以只有树和后沿。</li>
<li>如果$(u, v)$从$u$的角度看是一条树边，$(u, v)$那么从$v$的角度看也是一条后边。</li>
</ol>
<p>  $$<br>  \begin{array}{c|ccc}<br>  from \diagdown to &amp; \text{WHITE}      &amp; \text{GRAY}       &amp; \text{BLACK} \\<br>  \hline<br>  \text{WHITE}      &amp; -                 &amp; \text{Tree, Back} &amp; \text{Tree, Back} \\<br>  \text{GRAY}       &amp; \text{Tree, Back} &amp; \text{Tree, Back} &amp; \text{Tree, Back} \\<br>  \text{BLACK}      &amp; \text{Tree, Back} &amp; \text{Tree, Back} &amp; -<br>  \end{array}<br>  $$</p>
</li>
</ul>
<h2 id="22-3-2"><a href="#22-3-2" class="headerlink" title="22.3-2"></a>22.3-2</h2><blockquote>
<p>在图 22.6 中显示深度优先搜索是如何工作的。假设$\text{DFS}$过程的第 5-7 行的<strong>为了</strong>循环按字母顺序考虑顶点，并假设每个邻接表按字母顺序排序。显示每个顶点的发现和完成时间，并显示每条边的分类。</p>
</blockquote>
<p>下表给出了图中每个 Vetex 的发现时间和完成时间。</p>
<p>请参见<a target="_blank" rel="noopener" href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3.cpp">C++ demo</a>。</p>
<p>$$<br>\begin{array}{ccc}<br>\text{Vertex} &amp; \text{Discovered} &amp; \text{Finished} \\<br>\hline<br>q &amp;  1 &amp; 16 \\<br>r &amp; 17 &amp; 20 \\<br>s &amp;  2 &amp;  7 \\<br>t &amp;  8 &amp; 15 \\<br>u &amp; 18 &amp; 19 \\<br>v &amp;  3 &amp;  6 \\<br>w &amp;  4 &amp;  5 \\<br>x &amp;  9 &amp; 12 \\<br>y &amp; 13 &amp; 14 \\<br>z &amp; 10 &amp; 11<br>\end{array}<br>$$</p>
<ul>
<li><strong>树边缘：</strong> $(q, s)$，，，，，，，。$(s, v)$$(v, w)$$(q, t)$$(t, x)$$(x, z)$$(t, y)$$(r, u)$</li>
<li><strong>后边缘：</strong> $(w, s)$，，。$(z, x)$$(y, q)$</li>
<li><strong>前进边：</strong> $(q, w)$。</li>
<li><strong>交叉边缘：</strong> $(r, y)$，。$(u, y)$</li>
</ul>
<h2 id="22-3-3"><a href="#22-3-3" class="headerlink" title="22.3-3"></a>22.3-3</h2><blockquote>
<p>显示图 22.4 中深度优先搜索的括号结构。</p>
</blockquote>
<p>图 22.4 的深度优先搜索的括号结构是$(u(v(y(xx)y)v)u)(w(zz)w)$。</p>
<h2 id="22-3-4"><a href="#22-3-4" class="headerlink" title="22.3-4"></a>22.3-4</h2><blockquote>
<p>通过论证如果删除的$\text{DFS-VISIT}$第 3 行，该$\text{DFS}$过程将产生相同的结果，表明使用单个位来存储每个顶点颜色就足够了。</p>
</blockquote>
<p>将第 3 行更改为 <code>color = BLACK</code> 并删除第 8 行。然后，算法将产生相同的结果。</p>
<h2 id="22-3-5"><a href="#22-3-5" class="headerlink" title="22.3-5"></a>22.3-5</h2><blockquote>
<p>显示 Edge$(u, v)$为</p>
<p>**A.**树边或前向边当且仅当$u.d &lt; v.d &lt; v.f &lt; u.f$，</p>
<p><strong>乙。</strong>后边缘当且仅当$v.d \le u.d &lt; u.f \le v.f$，且</p>
<p>**C.**交叉边当且仅当$v.d &lt; v.f &lt; u.d &lt; u.f$。</p>
</blockquote>
<p><strong>A.</strong>$u$是的$v$祖先。</p>
<p><strong>乙。</strong>$u$是的$v$后代。</p>
<p>以前$u$<strong>C.</strong>$v$访问过。</p>
<h2 id="22-3-6"><a href="#22-3-6" class="headerlink" title="22.3-6"></a>22.3-6</h2><blockquote>
<p>证明在无向图中，根据在深度优先搜索期间是否$(u, v)$首先遇到或$(v, u)$将边$(u, v)$分类为树边或后边等价于根据分类方案中四种类型的顺序对其进行分类。</p>
</blockquote>
<p>根据定理 22.10，无向图的每条边要么是树边，要么是后边。首先，假设这$v$是通过探索边缘$(u, v)$首先发现的。那么根据定义，$(u, v)$是一条树边。而且，$(u, v)$一定是以前$(v, u)$发现过的，因为一旦$(v, u)$被探索，$v$就一定会被发现。现在假设它$v$不是第一个被发现$(u, v)$的。那么它必须被一些人$r\ne u$发现$(r, v)$。如果$u$还没有被发现，那么如果$(u, v)$首先被探索，它一定是一个后沿，因为$v$它是的$u$祖先。如果$u$已被发现，则$u$是的$v$祖先，因此$(v, u)$是后沿。</p>
<h2 id="22-3-7"><a href="#22-3-7" class="headerlink" title="22.3-7"></a>22.3-7</h2><blockquote>
<p>重写该过程$\text{DFS}$，使用堆栈来消除递归。</p>
</blockquote>
<p>请参见<a target="_blank" rel="noopener" href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-7/22.3-7.cpp">C++ demo</a>。</p>
<p>另外，请参阅本文<a target="_blank" rel="noopener" href="https://github.com/walkccc/CLRS/issues/329">issue</a>中的<a target="_blank" rel="noopener" href="https://github.com/i-to">@i-to</a>讨论。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DFS-<span class="built_in">STACK</span>(G)</span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.π = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE</span><br><span class="line">            DFS-VISIT-<span class="built_in">STACK</span>(G, u)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DFS-VISIT-<span class="built_in">STACK</span>(G, u)</span><br><span class="line">    S = Ø</span><br><span class="line">    <span class="built_in">PUSH</span>(S, u)</span><br><span class="line">    time = time + <span class="number">1</span>             <span class="comment">// white vertex u has just been discovered</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">while</span> !STACK-<span class="built_in">EMPTY</span>(S)</span><br><span class="line">        u = <span class="built_in">TOP</span>(S)</span><br><span class="line">        v = FIRST-WHITE-<span class="built_in">NEIGHBOR</span>(G, u)</span><br><span class="line">        <span class="keyword">if</span> v == NIL</span><br><span class="line">            <span class="comment">// u's adjacency list has been fully explored</span></span><br><span class="line">            <span class="built_in">POP</span>(S)</span><br><span class="line">            time = time + <span class="number">1</span></span><br><span class="line">            u.f = time</span><br><span class="line">            u.color = BLACK     <span class="comment">// blackend u; it is finished</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// u's adjacency list hasn't been fully explored</span></span><br><span class="line">            v.π = u</span><br><span class="line">            time = time + <span class="number">1</span></span><br><span class="line">            v.d = time</span><br><span class="line">            v.color = GRAY</span><br><span class="line">            <span class="built_in">PUSH</span>(S, v)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FIRST-WHITE-<span class="built_in">NEIGHBOR</span>(G, u)</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ G.Adj[u]</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">    <span class="keyword">return</span> NIL</span><br></pre></td></tr></tbody></table></figure>

<h2 id="22-3-8"><a href="#22-3-8" class="headerlink" title="22.3-8"></a>22.3-8</h2><blockquote>
<p>给出一个猜想的反例，如果一个有向图$G$包含一条从$u$到$v$的路径，并且如果$u.d &lt; v.d$在深度优先搜索$G$中，那么$v$在深度优先森林中产生的是的后代$u$。</p>
</blockquote>
<p>考虑一个图，其$3$顶点$u$为、$v$和$w$，边$(w, u)$为、$(u, w)$和$(w, v)$。假设$\text{DFS}$首先探索$w$，并且该$w$邻接表之前$v$有$u$。我们接下来发现$u$。唯一的相邻顶点是$w$，但$w$已经是灰色的，因此$u$完成。因为$v$还不是的后代$u$，并且$u$已经完成，所以$v$永远不能成为的$u$后代。</p>
<h2 id="22-3-9"><a href="#22-3-9" class="headerlink" title="22.3-9"></a>22.3-9</h2><blockquote>
<p>给出一个猜想的反例：如果一个有向图$G$包含一条从$u$到$v$的路径，那么任何深度优先搜索的结果都是$v.d \le u.f$。</p>
</blockquote>
<p>考虑顶点$\{1, 2, 3\}$上的有向图，并且具有边$(1, 2)$，$(1, 3)$$(2, 1)$则存在从$2$到$3$的路径。然而，如果我们在之前$3$开始一个$\text{DFS}$AT$1$和过程$2$，我们将得到$2.f = 3 &lt; 4 = 3.d$一个给定猜想的反例。</p>
<h2 id="22-3-10"><a href="#22-3-10" class="headerlink" title="22.3-10"></a>22.3-10</h2><blockquote>
<p>修改深度优先搜索的伪代码，以便打印出有向图$G$中的每条边及其类型。如果$G$是未定向的，则显示需要进行的修改（如果有）。</p>
</blockquote>
<p>如果$G$是非定向的，我们不需要做任何修改。</p>
<p>请参见<a target="_blank" rel="noopener" href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-10/22.3-10.cpp">C++ demo</a>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DFS-VISIT-<span class="built_in">PRINT</span>(G, u)</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ G.Adj[u]</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            print <span class="string">"(u, v) is a tree edge."</span></span><br><span class="line">            v.π = u</span><br><span class="line">            DFS-VISIT-<span class="built_in">PRINT</span>(G, v)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> v.color == GRAY</span><br><span class="line">            print <span class="string">"(u, v) is a back edge."</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> v.d &gt; u.d</span><br><span class="line">            print <span class="string">"(u, v) is a forward edge."</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            print <span class="string">"(u, v) is a cross edge."</span></span><br><span class="line">    u.color = BLACK</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time</span><br></pre></td></tr></tbody></table></figure>

<h2 id="22-3-11"><a href="#22-3-11" class="headerlink" title="22.3-11"></a>22.3-11</h2><blockquote>
<p>解释有向图的顶点$u$如何在深度优先树中结束，该树只$u$包含，即使$u$在中$G$既有传入边也有传出边。</p>
</blockquote>
<p>假设我们在顶点$\{1, 2, 3\}$上有一个有向图，并且有边$(1, 2)$和$(2, 3)$。然后，$2$具有传入边和传出边。</p>
<p>如果我们选择我们的第一个根$3$，那将是在它自己的$\text{DFS}$树上。然后，我们选择我们的第二个根$2$，因为它指向的唯一东西已经被标记了$\text{BLACK}$，我们不会探索它。然后，选择最后一个根$1$，我们不会破坏树中$\text{DFS}$的事实，$2$即使它既有传入边又有传出边$G$。</p>
<h2 id="22-3-12"><a href="#22-3-12" class="headerlink" title="22.3-12"></a>22.3-12</h2><blockquote>
<p>表明我们可以使用无向图$G$的深度优先搜索来识别的$G$连通分量，并且深度优先森林包含与$G$连通分量一样多的树。更准确地说，展示如何修改深度优先搜索，以便为每个顶点$v$分配一个介于和$k$之间的整数标签$v.cc$$1$，其中$k$是的连通分量$G$的数量，使得$u.cc = v.cc$当且仅当$u$和$v$在同一连通分量中。</p>
</blockquote>
<p>修改工作如下：每次<strong>如果</strong>在中$\text{DFS-CC}$满足第 8 行的-条件时，我们在森林中有一个树的新根，因此我们将其$cc$标签更新为新值$k$。在对$\text{DFS-VISIT-CC}$的递归调用中，我们总是更新后代的连通分量，使其与祖先的连通分量一致。</p>
<p>请参见<a target="_blank" rel="noopener" href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-12/22.3-12.cpp">C++ demo</a>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DFS-<span class="built_in">CC</span>(G)</span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.π = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    cc = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u ∈ G.V</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE</span><br><span class="line">            u.cc = cc</span><br><span class="line">            cc = cc + <span class="number">1</span></span><br><span class="line">            DFS-VISIT-<span class="built_in">CC</span>(G, u)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DFS-VISIT-<span class="built_in">CC</span>(G, u)</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ G.Adj[u]</span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            v.cc = u.cc</span><br><span class="line">            v.π = u</span><br><span class="line">            DFS-VISIT-<span class="built_in">CC</span>(G, v)</span><br><span class="line">    u.color = BLACK</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time</span><br></pre></td></tr></tbody></table></figure>

<h2 id="22-3-13-star"><a href="#22-3-13-star" class="headerlink" title="22.3-13$\star$"></a>22.3-13$\star$</h2><blockquote>
<p>有向图$G = (V, E)$是指**<em>单连通的</em>**$u \leadsto v$对于所有顶点$u, v \in V$最多$G$包含一条从$u$到$v$的简单路径。给出了一个判定有向图是否单连通的有效算法。</p>
</blockquote>
<p>这是可以及时$O(|V||E|)$完成的。为此，首先执行顶点的拓扑排序。然后，我们将包含每个顶点的祖先$in\text-degree$$0$列表。我们按照从较早的顶点开始的拓扑顺序为每个顶点计算这些列表。</p>
<p>然后，如果我们曾经有一个顶点，在它的两个直接父节点的列表中出现了相同度数$0$的顶点，我们就知道这个图不是单连通的。然而，如果在每一步我们都有，在每一步所有的父节点都有不相交的度点集$0$作为祖先，则图是单连通的。由于对于每个顶点，所需的时间量受顶点数乘以特定顶点的$in\text-degree$限制，因此总运行时间受限制$O(|V||E|)$。</p>
<h2 id="22-4-1"><a href="#22-4-1" class="headerlink" title="22.4-1"></a>22.4-1</h2><blockquote>
<p>在练习 22.3-2 的假设下，显示在图 22.8 的 DAG 上运行时产生$\text{TOPOLOGICAL-SORT}$的顶点排序。</p>
</blockquote>
<p>我们表演的$\text{DFS}$开始和结束时间是</p>
<p>$$<br>\begin{array}{ccc}<br>\text{label} &amp; d &amp; f \\<br>\hline<br>m &amp; 1  &amp; 20 \\<br>q &amp; 2  &amp; 5  \\<br>t &amp; 3  &amp; 4  \\<br>r &amp; 6  &amp; 19 \\<br>u &amp; 7  &amp; 8  \\<br>y &amp; 9  &amp; 18 \\<br>v &amp; 10 &amp; 17 \\<br>w &amp; 11 &amp; 14 \\<br>z &amp; 12 &amp; 13 \\<br>x &amp; 15 &amp; 16 \\<br>n &amp; 21 &amp; 26 \\<br>o &amp; 22 &amp; 25 \\<br>s &amp; 23 &amp; 24 \\<br>p &amp; 27 &amp; 28<br>\end{array}<br>$$</p>
<p>因此，通过按完成时间的降序读取条目，我们得到了序列$p, n, o, s, m, r, y, v, x, w, z, u, q, t$。</p>
<h2 id="22-4-2"><a href="#22-4-2" class="headerlink" title="22.4-2"></a>22.4-2</h2><blockquote>
<p>给出一个线性时间算法，该算法将一个有向无环图$G = (V, E)$和两个顶点$s$和$t$作为输入，并返回中$G$从$s$到$t$的简单路径的数目。例如，图 22.8 的有向无环图恰好包含四条从顶点$p$到顶点$v: pov$的简单路径、$poryv$、$posryv$和$psryv$。（你的算法只需要计算简单路径，而不是列出它们。）</p>
</blockquote>
<p>该算法的工作原理如下。节点$u$的属性$u.paths$告诉从$u$到$v$的简单路径的数量，我们假设$v$在整个过程中是固定的。首先，应进行拓扑排序，并列出之间$u$的顶点，$v$如$\{v[1], v[2], \dots, v[k - 1]\}$。为了计算路径的数量，我们应该从$v$到$u$构造一个解决方案。让我们调用$u$AS$v[0]$和$v$AS$v[k]$，以避免重叠子问题，应该记住和$u$之间$v_k$的路径数量，并将其用作$k$减少到$0$。只有用这种方法我们才能解决这个问题$\Theta(V + E)$。</p>
<p>只有当图使用邻接矩阵时，自底向上的迭代版本才是可能的，因此$u$可以及时确定$O(1)$是否$v$邻接。但是建立一个邻接矩阵是要花钱$\Theta(|V|^2)$的，所以没关系。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-<span class="built_in">PATHS</span>(G, u, v)</span><br><span class="line">    TOPO-<span class="built_in">SORT</span>(G)</span><br><span class="line">    let {v[<span class="number">1</span>], v[<span class="number">2</span>]..v[k - <span class="number">1</span>]} be the vertex between u <span class="keyword">and</span> v</span><br><span class="line">    v[<span class="number">0</span>] = u</span><br><span class="line">    v[k] = v</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">0</span> to k - <span class="number">1</span></span><br><span class="line">        DP[j] = ∞</span><br><span class="line">    DP[k] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> SIMPLE-PATHS-<span class="built_in">AID</span>(G, DP, <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-PATHS-<span class="built_in">AID</span>(G, DP, i)</span><br><span class="line">    <span class="keyword">if</span> i &gt; k</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> DP[i] != ∞</span><br><span class="line">        <span class="keyword">return</span> DP[i]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       DP[i] = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> v[m] in G.adj[v[i]] <span class="keyword">and</span> <span class="number">0</span> &lt; m ≤ k</span><br><span class="line">            DP[i] += SIMPLE-PATHS-<span class="built_in">AID</span>(G, DP, m)</span><br><span class="line">       <span class="keyword">return</span> DP[i]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="22-4-3"><a href="#22-4-3" class="headerlink" title="22.4-3"></a>22.4-3</h2><blockquote>
<p>给出一个确定给定的无向图$G = (V, E)$是否包含圈的算法。你的算法应该及时运行$O(V)$，独立于$|E|$。</p>
</blockquote>
<p>无向图是无环的（即，一个森林）当且仅当DFS不产生后边缘。由于后边是深度优先树中连接顶点u和祖先v的边（u，v），所以没有后边意味着只有树的边，所以没有循环。</p>
<p>所以我们可以简单地运行DFS。如果找到一个后沿，则有一个循环。复杂度是O（V）而不是O（E + V）。既然有后沿，一定要先发现后看|V|明显的边缘这是因为在无环（无向）森林中，|E| ≤ |V|-1</p>
<h2 id="22-4-4"><a href="#22-4-4" class="headerlink" title="22.4-4"></a>22.4-4</h2><blockquote>
<p>证明或反驳：如果一个有向图$G$包含圈，那么$\text{TOPOLOGICAL-SORT}(G)$产生一个顶点排序，使与产生的排序不一致的“坏”边的数量最小化。</p>
</blockquote>
<p>这不是真的。考虑由顶点$a, b, c$和$d$组成的图$G$。假设边为$(a, b)$、$(b, c)$、$(a, d)$、$(d, c)$和$(c, a)$。假设我们从顶点$c$开始$\text{DFS}$$\text{TOPOLOGICAL-SORT}$。假设$b$在的$a$邻接表中出现在之前$d$，则完成时间从最晚到最早的顺序为$c, a, d, b$。</p>
<p>在这种情况下，“坏”边是$(b, c)$和$(d, c)$。然而，如果我们在$a, b, d, c$那时订购它们，唯一不好的边缘将是$(c, a)$。因此$\text{TOPOLOGICAL-SORT}$并不总是最小化“坏”边的数量。</p>
<h2 id="22-4-5"><a href="#22-4-5" class="headerlink" title="22.4-5"></a>22.4-5</h2><blockquote>
<p>在有向无环图$G = (V, E)$上执行拓扑排序的另一种方法是重复查找的$\text{in-degree}$$0$顶点，输出该顶点，并从图中删除该顶点及其所有引出边。解释如何实现这个想法，以便它及时$O(V + E)$运行。如果$G$有循环，这个算法会发生什么？</p>
</blockquote>
<p>首先，运行DFS或BFS来计算O（V+E）时间内每个点的进出，然后在删除边时维护此信息。每次输入为0的一条，点击删除边并保持信息，所以有E条边和V点，所以O（V）输出和O（E）删除。所以总的运行时间是O（V+E）。）</p>
<p>如果图有环，那么有时可能没有度数为零的点。</p>
<h2 id="22-5-1"><a href="#22-5-1" class="headerlink" title="22.5-1"></a>22.5-1</h2><blockquote>
<p>如果添加一条新边，图的强连通分支的数目如何改变？</p>
</blockquote>
<p>它可以保持不变，也可以减少。要了解保持不变的可能性，只需假设向循环添加一些边。为了看到减少是可能的，假设你的原始图在三个顶点上，并且只是一条通过所有顶点的路径，并且添加的边将这条路径完成为一个循环。要看到它不能增加，请注意添加边不能删除以前存在的任何路径。</p>
<p>因此，如果$u$和$v$在原始图中处于相同的连通分量中，则在两个方向上都存在从一个到另一个的路径。添加边不会干扰这两条路径，因此我们知道，$u$$v$添加边后，图中仍将保持不变$\text{SCC}$。由于没有组件可以分开，这意味着它们的数量不能增加，因为它们形成了顶点集合的划分。</p>
<h2 id="22-5-2"><a href="#22-5-2" class="headerlink" title="22.5-2"></a>22.5-2</h2><blockquote>
<p>在图 22.6 的图表上显示程序$\text{STRONGLY-CONNECTED-COMPONENTS}$如何工作。具体来说，显示第 1 行中计算的完成时间和第 3 行中生成的森林。假设的$\text{DFS}$第 5–7 行的循环按字母顺序考虑顶点，并且邻接表按字母顺序。</p>
</blockquote>
<p>在练习 22.3-2 中计算每个顶点的完成时间。这片森林由 5 棵树组成，每棵树都是一条链。我们将按从根到叶的顺序列出每棵树的顶点：$r$、$u$、$q - y - t$、$x - z$和$s - w - v$。</p>
<h2 id="22-5-3"><a href="#22-5-3" class="headerlink" title="22.5-3"></a>22.5-3</h2><blockquote>
<p>培根教授声称，如果在第二次深度优先搜索中使用原始（而不是转置）图，并按完成时间的_不断增加_顺序扫描顶点，则强连通分量的算法会更简单。这个更简单的算法总是产生正确的结果吗？</p>
</blockquote>
<p>培根教授的建议行不通。举个例子，假设我们的图在三个顶点$\{1, 2, 3\}$上，并且由边$(2, 1), (2, 3), (3, 2)$组成。然后，我们应该以$\{2, 3\}$和$\{1\}$作为我们$\text{SCC}$的结束。然而，可能$\text{DFS}$的开始时间$2$可以在之前$1$探索$3$，这将意味着的$3$完成时间低于$1$和$2$。这意味着当我们第一次执行$\text{DFS}$开始$3$时。但是，$\text{DFS}$从 AT$3$开始将能够到达所有其他顶点。这意味着算法将返回整个图是单个$\text{SCC}$的，尽管情况显然不是这样，因为既没有从$1$到$2$的路径，也没有从$1$到$3$的路径。</p>
<h2 id="22-5-4"><a href="#22-5-4" class="headerlink" title="22.5-4"></a>22.5-4</h2><blockquote>
<p>证明对于任何有向图$G$，我们有$((G^\text T)^{\text{SCC}})^\text T = G^{\text{SCC}}$。也就是说，的分量图$G^\text T$的转置与的分量图$G$相同。</p>
</blockquote>
<p>首先观察$C$是的$G$强连通分支当且仅当它是的$G^\text T$强连通分支。因此，和$(G^\text T)^{\text{SCC}}$的$G^{\text{SCC}}$顶点集是相同的，这意味着和$G^{\text{SCC}}$的$((G^\text T)^\text{SCC})^\text T$顶点集是相同的。这足以表明它们的边集是相同的。假设$(v_i, v_j)$是中的$((G^\text T)^{\text{SCC}})^\text T$一条边。然后$(v_j, v_i)$是边缘在$(G^\text T)^{\text{SCC}}$。因此，存在$x \in C_j$并且$y \in C_i$使得$(x, y)$是的$G^\text T$边，这意味着$(y, x)$是的$G$边。由于组件被保留，这意味着它$(v_i, v_j)$是中的$G^{\text{SCC}}$一条边。对于相反的含义，我们简单地注意到，对于我们拥有的$(G^\text T)^{\text T} = G$任何图$G$。</p>
<h2 id="22-5-5"><a href="#22-5-5" class="headerlink" title="22.5-5"></a>22.5-5</h2><blockquote>
<p>给出了$O(V + E)$计算有向图$G = (V, E)$的分量图的时间算法。确保算法生成的组件图中的两个顶点之间最多有一条边。</p>
</blockquote>
<p>首先执行STRONGLY-CONNECTED-COMPONENTS过程，然后在[1，k]中为每个节点分配一个值，即生成的k个强连通分量。第k个强连通分支中所有节点的值为k。然后遍历每个节点i，对于Adj[i]的每个节点j，如果k[i]和k[j]之前没有边，则相加。</p>
<h2 id="22-5-6"><a href="#22-5-6" class="headerlink" title="22.5-6"></a>22.5-6</h2><blockquote>
<p>给定一个有向图$G = (V, E)$，解释如何创建另一个图$G’ = (V, E’)$，使得（A）$G’$具有与$G$相同的强连通分支，（B）$G’$具有与$G$相同的分支图，并且（C）$E’$尽可能小。描述一个快速算法来计算$G’$。</p>
</blockquote>
<ol>
<li>先对原图G生成k个联通分量和一个SCC子图.</li>
<li>遍历k个所有的联通分量. 对每个联通分量,必然有一个能够到所有点的回路,只添加该回路到新的图.假设第i个联通分量有5个节点a,b,c,d,e,我们只需要添加边a-&gt;b,b-&gt;c,c-&gt;d,d-&gt;e,e-&gt;a即可.</li>
<li>选SCC子图的边,加到新的图. 节点可以任意选择.</li>
</ol>
<h2 id="22-5-7"><a href="#22-5-7" class="headerlink" title="22.5-7"></a>22.5-7</h2><blockquote>
<p>一个有向图$G = (V, E)$是**<em>半连接的</em>**如果，对于所有的顶点$u, v \in V$对，我们有$u \leadsto v$或$v \leadsto u$。给出了判断是否$G$为半连通的有效算法。证明你的算法是正确的，并分析它的运行时间。</p>
</blockquote>
<p>算法：</p>
<ol>
<li>快跑$\text{STRONG-CONNECTED-COMPONENTS}(G)$。</li>
<li>将每个强连通分支作为一个虚拟顶点，创建一个新的虚拟图$G’$。</li>
<li>快跑$\text{TOPOLOGICAL-SORT}(G’)$。</li>
<li>检查对于拓扑排序中的$G’$所有连续顶点$(v_i, v_{i + 1})$，图$G’$中是否存在边$(v_i, v_{i + 1})$。如果是，则原图是半连通的。否则，它就不是。</li>
</ol>
<p>证明：</p>
<p>很容易证明这$G’$是一个 DAG.考虑中的$G’$连续顶点$v_i$和$v_{i + 1}$。如果没有从$v_i$到$v_{i + 1}$的边，我们也可以得出结论，没有从$v_{i + 1}$到$v_i$的路径，因为$v_i$之后$v_{i + 1}$完成了。根据的定义$G’$，我们得出结论，不存在从表示为$v_i$的中$G’$的$G$任何顶点到表示为的$v_{i + 1}$顶点的路径。因此，$G$不是半连接的。如果在所有连续的顶点之间存在一条边，则我们声称在任意两个顶点之间存在一条边。因此，$G$是半连通的。</p>
<p>运行时间：$O(V + E)$。</p>
<blockquote>
<p>让 $G = (V, E)$ 是一个无向连通图，其权重函数为 $w： E \rightarrow \mathbb R$，并假设 $|E| \ge |V|$ 且所有边的权重都不同。</p>
<p>我们定义一棵次优最小生成树如下。让 $mathcal T$ 是 $G$ 所有生成树的集合，让 $T’$ 是 $G$ 的最小生成树。那么**<em>次优最小生成树</em>**就是一棵生成树$T$，使得$W(T) = \min_{T’’ \in \mathcal T - \{T’\}} \（w（T’’））$.</p>
<p><strong>a.</strong> 证明最小生成树是唯一的，但是次优最小生成树不一定是唯一的。</p>
<p><strong>b.</strong> 让 $T$ 成为 $G$ 的最小生成树。证明 $G$ 包含在 T$ 中的边 $(u, v) 和不在 T$ 中的边 $(x, y) ，这样 $T - \{(u, v)\} \cup \{(x, y)\}$ 是G的次优最小生成树。</p>
<p><strong>c.</strong> 让 $T$ 是 $G$ 的一棵生成树，对于 V$ 中的任意两个顶点 $u，v，让 $max[u, v]$ 表示在 $T$ 中 $u$ 和 $v$ 之间唯一的简单路径上权重最大的一条边。描述一个$O(V^2)$时间的算法，在给定$T$的情况下，为V$中的所有$u, v计算$max[u, v]$。</p>
<p><strong>d.</strong> 给出计算 $G$ 的次优最小生成树的高效算法。</p>
</blockquote>
<p><strong>a.</strong> 为了说明次优最小生成树不一定是唯一的，我们来看看下面这个有四个顶点的示例图。假设顶点为 ${a, b, c, d}$, 边的权重如下：</p>
<p>$$<br>\begin{array}{c|c|c|c|c|}<br>  &amp; a &amp; b &amp; c &amp; d \\<br>\hline<br>a &amp; - &amp; 1 &amp; 4 &amp; 3 \\<br>\hline<br>b &amp; 1 &amp; - &amp; 5 &amp; 2 \\<br>\hline<br>c &amp; 4 &amp; 5 &amp; - &amp; 6 \\<br>\hline<br>d &amp; 3 &amp; 2 &amp; 6 &amp; - \\<br>\hline<br>\end{array}<br>$$</p>
<p>那么，最小生成树的权重为 $7$，但有两棵权重次优的生成树，权重为 $8$。</p>
<p><strong>b.</strong> 我们试图证明，有一条边的交换可以使我们的最小生成树降级为次优最小生成树。在获得次优最小生成树的过程中，必须有某个远离其余顶点的单个切点，而在该切点上添加的边并不轻，否则，我们找到的将是最小生成树，而不是次优最小生成树。我们将该切分所选的边称为次优最小生成树 $(x,y)$。现在，考虑同样的切分，只是看看在获得 $T$ 时所选择的边，称之为 $(u，v)$。那么，如果考虑 $T -\{(u, v)} \cup \{(x, y)}$，它将是一棵次优最小生成树。这是因为如果第二好的最小生成树也为另一条切分选择了一条非光边，那么它最终会比所有的最小生成树都要昂贵。这就意味着，我们需要在每条切线上都选择轻边。这意味着所有选择都与最小生成树一致。</p>
<p><strong>c.</strong> 我们在此给出一个动态编程解决方案。假设我们要为 $(u, v)$ 求解。首先，我们将确定在从 $u$ 到 $v$ 的简单路径上紧接着 $u$ 出现的顶点 $x$。然后，我们将使 $\max[u, v]$ 等于 $w((u, x))$ 和 $\max[w, v]$ 的最大值。最后，我们只考虑 $u$ 和 $v$ 相邻的情况，在这种情况下，最大权重边只是两者之间的一条边。如果我们能在恒定时间内找到 $x$，那么整个动态程序的运行时间就是 $O(V^2)$，因为这就是正在建立的表的大小。为了在恒定时间内找到 $x$，我们要对树进行预处理。我们首先选取一个任意根。然后，我们对塔尔扬的离线最小公祖算法进行预处理（见问题 21-3）。这需要的时间只比线性多一点，即 $O(|V|\alpha(|V|))$。计算出所有最小公祖后，我们就可以在恒定时间内，在稍后的某个时间点查找该结果。然后，为了找到我们应该选取的 $w$，我们首先要看 $u = \text{LCA}(u,v)$，如果没有，那么我们就选取树中 $u$ 的父节点。如果是，那么我们就把问题反过来，试着计算 $\max[v，u]$，我们保证不会出现 $v = \text{LCA}(v, u)$ 这种情况，因为我们知道 $u$ 是 $v$ 的祖先。</p>
<p><strong>d.</strong> 在此，我们提供了一种用时 $O(V^2)$的算法，并对是否存在线性时间解（即用时 $O(E+V)$的解）保持开放态度。首先，我们用 $O(E+V\lg(V))$的时间找到一棵最小生成树，其时间为 $O(V^2)$。然后，使用 c 部分的算法，找到双数组最大值。然后，我们在所有顶点 $u$, $v$ 对中取运行最小值 $w(u,v)-\max[u,v]$。如果 $u$ 和 $v$ 之间没有边，我们就认为权重是无限的。然后，对于这个差值最小的一对，我们加入这条边，并从最小生成树中删除从 $u$ 到 $v$ 的路径中权重为 $\max[u,v]$的一条边。</p>
<blockquote>
<p>对于一个非常稀疏的连通图 $G = (V，E)$，我们可以通过在运行 Prim 算法之前对 $G$ 进行预处理以减少顶点数量，从而进一步提高使用斐波那契堆的 Prim 算法的 $O(E + V\lg V)$ 运行时间。具体来说，我们为每个顶点$u$ 选择与$u$ 相连的最小权重边$(u, v)$，并将$(u, v)$ 放入正在构建的最小生成树中。然后，我们收缩所有选定的边（见第 B.4 节）。我们不是一条一条地收缩这些边，而是首先确定合并为同一个新顶点的顶点集。然后，我们创建一个图形，这个图形就是逐条收缩这些边的结果，但我们是根据边的端点所处的集合对边进行 “重命名”。原始图中的几条边可能会被重命名为相同的名称。在这种情况下，结果只有一条边，其权重是相应原始边权重的最小值。</p>
<p>最初，我们将正在构建的最小生成树 $T$ 设置为空，对于 E$ 中的每一条边 $(u，v)，我们初始化属性 $(u, v).orig = (u, v)$ 和 $(u, v).c = w(u，v)$。我们使用 $orig$ 属性来引用与收缩图中的边相关联的初始图中的边。$c$ 属性用于保存边的权重，当边被收缩时，我们会根据上述选择边权重的方案对其进行更新。存储过程 $text{MST-REDUCE}$接受输入 $G$ 和 $T$，并返回带有更新属性 $orig’$ 和 $c’$ 的收缩图 $G’$。程序还会将 $G$ 的边累加到最小生成树 $T$ 中。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MST-<span class="built_in">REDUCE</span>(G, T)</span><br><span class="line">    <span class="keyword">for</span> each v ∈ G.V</span><br><span class="line">        v.mark = <span class="literal">false</span></span><br><span class="line">        MAKE-<span class="built_in">SET</span>(v)</span><br><span class="line">    <span class="keyword">for</span> each u ∈ G.V</span><br><span class="line">        <span class="keyword">if</span> u.mark == <span class="literal">false</span></span><br><span class="line">            choose v ∈ G.Adj[u] such <span class="built_in">that</span> (u, v).c is minimized</span><br><span class="line">                <span class="built_in">UNION</span>(u, v)</span><br><span class="line">                T = T ∪ {(u, v).orig}</span><br><span class="line">                u.mark = v.mark = <span class="literal">true</span></span><br><span class="line">    G<span class="number">'.</span>V = {FIND-<span class="built_in">SET</span>(v): v ∈ G.V}</span><br><span class="line">    G<span class="number">'.</span>E = Ø</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">each</span> (x, y) ∈ G.E</span><br><span class="line">        u = FIND-<span class="built_in">SET</span>(x)</span><br><span class="line">        v = FIND-<span class="built_in">SET</span>(y)</span><br><span class="line">        <span class="keyword">if</span> (u, v) ∉ G<span class="number">'.</span>E</span><br><span class="line">             G<span class="number">'.</span>E = G<span class="number">'.</span>E ∪ {(u, v)}</span><br><span class="line">             (u, v).orig<span class="number">'</span> = (x, y).<span class="built_in">orig</span></span><br><span class="line">             (u, v).c<span class="number">'</span> = (x, y).c</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x, y).c &lt; (u, v).c<span class="number">'</span></span><br><span class="line">             (u, v).orig<span class="number">'</span> = (x, y).<span class="built_in">orig</span></span><br><span class="line">             (u, v).c<span class="number">'</span> = (x, y).c</span><br><span class="line">    construct adjacency lists G<span class="number">'.</span>Adj <span class="keyword">for</span> G<span class="number">'</span></span><br><span class="line">    <span class="keyword">return</span> G<span class="number">'</span> <span class="keyword">and</span> T</span><br></pre></td></tr></tbody></table></figure>

<p><strong>a.</strong> 让 $T$ 是 $text{MST-REDUCE}$ 返回的边的集合，让 $A$ 是调用 $\text{MST-PRIM}(G’,c’,r)$形成的图 $G’$ 的最小生成树，其中 $c’$ 是 $G’E$ 边上的权重属性，$r$ 是 $G’V$ 中的任意顶点。证明 $T \cup {(x,y).orig’: (x, y) \in A}$ 是 $G$ 的最小生成树。</p>
<p><strong>b.</strong> 论证 $|G’.V| \le |V| / 2$.</p>
<p><strong>c.</strong> 展示如何实现 $text{MST-REDUCE}$，使其在 $O(E)$ 时间内运行。($\textit{提示：}$ 使用简单的数据结构)</p>
<p>**d.**假设我们运行$\text{MST-REDUCE}$$的$k$个阶段，使用一个阶段产生的输出$G’$作为下一阶段的输入$G$，并在$T$中累积边。论证 $k$ 阶段的总体运行时间为 $O(kE)$。</p>
<p>**e.**假设在运行$k$阶段的$\text{MST-REDUCE}$后，如第(d)部分所示，我们通过调用$\text{MST-PRIM}(G’, c’, r)$来运行普里姆算法，其中$G’$的权重属性为$c’$，由最后一个阶段返回，而$r$是$G’.V$中的任意顶点。演示如何选择 $k$，从而使总体运行时间为 $O(E/lg/lg V)$。论证您所选择的 $k$ 能使整体渐近运行时间最小化。</p>
<p><strong>f.</strong> 对于 $|E|$（就 $|V|$而言）的哪些值，有预处理的 Prim 算法会渐进地击败无预处理的 Prim 算法？</p>
</blockquote>
<p>**我们将证明每一步添加的边都是安全的。考虑一个无标记顶点 $u$。设 $S = {u/}$，并让 $A$ 是目前树中的边集。那么剪切尊重 $A$，我们添加的下一条边是一条光边，所以对 $A$ 来说是安全的。因此，在我们运行 Prim 算法之前，$T$ 中的每一条边对$T$ 都是安全的。通常情况下，Prim’s 算法在此时添加的任何一条边都必须连接两棵已创建的树，而且会被选作最小边。此外，我们在任何两棵树之间都会选择一条边。因此，我们只有最小的边并不是问题。结果树一定是最小的。</p>
<p>**b.**我们通过对 $G$ 中顶点数量的归纳来论证。我们假设 $|V| &gt; 1$，否则 $text{MST-REDUCE}$ 将在第 6 行遇到错误，因为无法选择 $v$。让 $|V| = 2$。因为 $G$ 是连通的，所以 $u$ 和 $v$ 之间一定有一条边，而且这条边的权重是最小的。它们连接起来，$|G’.V| = 1 = |V| / 2$。</p>
<p>假设在 $|V| = n$ 的情况下，上述主张成立。让 $G$ 是一个有 $n + 1$ 个顶点的连通图。那么在第 4 行的 for 循环检查最终顶点 $v$ 之前，$G’.V \le n / 2$。如果 $v$ 已被标记，那么我们就完成了；如果 $v$ 没有被标记，那么我们将把它连接到其他顶点，由于 $v$ 是最后一个要处理的顶点，所以它必须被标记。</p>
<p>无论如何，$v$ 都无法为 $G’.V$ 带来额外的顶点。所以</p>
<p>$$|G’.V| \le n / 2 \le (n + 1) / 2.$$</p>
<p><strong>c.</strong> 与其使用第 21 章中的不相交集合结构，我们可以简单地使用数组来跟踪顶点所在的组件。假设 $A$ 是一个长度为 $|V|$ 的数组，如果 $v = \text{FIND-SET}(u)$，那么 $A[u] = v$。那么 $\text{FIND-SET}(u)$现在可以替换为 $A[u]$，$\text{UNION}(u, v)$ 可以替换为 $A[v]=A[u]$。由于这些操作的运行时间不变，因此运行时间为 $O(E)$。</p>
<p><strong>d.</strong> 输出中的边的数量是单调递减的，因此每次调用的时间为 $O(E)$。因此，$k$ 调用耗时为 $O(kE)$。</p>
<p>**e.**普里姆算法的运行时间为 $O(E+V/lg V)$。每次运行 $\text{MST-REDUCE}$，顶点数量至少会减少一半。因此，在调用 $k$ 后，顶点数量最多为 $|V| / 2^k$。我们需要最小化</p>
<p>$$E + V / 2^k\lg(V / 2^k) + kE = E + \frac{V\lg V}{2^k} - \frac{Vk}{2^k} + kE$$</p>
<p>与 $k$ 有关。如果我们选择 $k =\lg\lg V$，那么我们就能如愿以偿地实现 $O(E\lg\lg V)$ 的总体运行时间。</p>
<p>要看到这个 $k$ 值最小，请注意 $\frac{Vk}{2^k}$ 项总是小于 $kE$ 项，因为 $E\ge V$。随着 $k$ 的减小，$kE$ 的贡献会减小，而 $\frac{V\lg V}{2^k}$ 的贡献会增大。因此，我们需要找到 $k$ 的值，使它们在最坏的情况下（当 $E = V$ 时）大致相等。为此，我们设置 $\frac{\lg V}{2^k} = k$。要精确解决这个问题，需要用到兰伯特 W 函数，但最接近的基本函数是 $k = \lg\lg V$。</p>
<p><strong>f.</strong> 我们只需设置不等式</p>
<p>$$E\lg\lg V &lt; E + V\lg V$$</p>
<p>发现我们需要</p>
<p>$$E &lt; \frac{V\lg V}{\lg\lg V-1} = O(\frac{V\lg V}{\lg\lg V}).$$</p>
<blockquote>
<p>无向图 $G$ 的**<em>瓶颈生成树</em>** $T$ 是 $G$ 的生成树，其最大边的权重在 $G$ 的所有生成树中最小。我们说瓶颈生成树的值就是 $T$ 中最大边的权重。</p>
<p>**a.**论证最小生成树就是瓶颈生成树。</p>
<p>第（a）部分表明，找到一棵瓶颈生成树并不比找到一棵最小生成树难。在剩下的部分中，我们将展示如何在线性时间内找到一棵瓶颈生成树。</p>
<p><strong>b.</strong> 给定一个图 $G$ 和一个整数 $b$，给出一个线性时间算法，确定瓶颈生成树的值是否最多为 $b$。</p>
<p>**c.**将（b）部分的算法用作瓶颈生成树问题线性时间算法的子程序。($textit{提示:}$ 您可能想使用一个收缩边集的子程序，就像问题 23-2 中描述的 $\text{MST-REDUCE}$程序那样).</p>
</blockquote>
<p><strong>a.</strong> 发现每棵最小生成树也是一棵瓶颈生成树。假设 $T$ 是一棵最小生成树。假设其中有一条边 $(u, v)$ 的权重大于瓶颈生成树的权重。那么，让 $V_1$ 成为 $V$ 的顶点子集，这些顶点在 $T$ 中不经过 $v$ 就能从 $u$ 到达。对称定义 $V_2$。然后，考虑将 $V_1$ 与 $V_2$ 分割开的切口。在这条切线上，我们只能添加一条权重最小的边，因此我们知道在这条切线上没有权重小于 $w(u,v)$的边。</p>
<p>然而，我们知道有一条权重小于该权重的瓶颈生成树。这是一个矛盾，因为瓶颈生成树既然是生成树，就必须有一条边穿过这条切口。</p>
<p>**为此，我们首先处理整个图，删除权重大于 $b$ 的边。如果剩下的图是连通的，我们就可以任意选择其中的任意一棵树，它将是一棵权重最多为 $b$ 的瓶颈生成树。测试图的连通性可以在线性时间内完成，方法是先进行广度搜索，然后确保搜索结束时没有空白顶点。</p>
<p><strong>c.</strong> 写下所有顶点的边重。使用第 9.3 节中的算法，在 $O(E)$的时间内找出这个数字列表的中位数。然后，以该中值为输入，运行 b 部分的程序。那么有两种情况：</p>
<p>第一种情况是，存在一棵权重最多为中位数的瓶颈生成树。那么，只需丢弃权重大于中值的边，然后在这张新图上用一半的边重复程序即可。</p>
<p>其次，我们可以认为不存在权重至多为该权重的瓶颈生成树。然后，我们应该运行与问题 23-2 类似的程序，收缩所有权重至多等于中位数权重的边。这需要花费 $O(E)$，然后我们就可以在现在只有一半边的图上解决问题了。</p>
<p>请注意，两种情况都是 $O(E)$，而且每次递归都会将问题规模减半。因此，这种递归的解法是线性的。</p>
<blockquote>
<p>在这个问题中，我们给出了三种不同算法的伪代码。每种算法都将连通图和权重函数作为输入，并返回一组边 $T$。对于每种算法，要么证明 $T$ 是最小生成树，要么证明 $T$ 不是最小生成树。同时描述每种算法最有效的实现方式，无论它是否能计算出最小生成树。</p>
<p><strong>a.</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MAYBE-MST-<span class="built_in">A</span>(G, w)</span><br><span class="line">    sort the edges into nonincreasing order of edge weights w</span><br><span class="line">    T = E</span><br><span class="line">    <span class="keyword">for</span> each edge e, taken in nonincreasing order by weight</span><br><span class="line">        <span class="keyword">if</span> T - {e} is a connected graph</span><br><span class="line">            T = T - {e}</span><br><span class="line">    <span class="keyword">return</span> T</span><br></pre></td></tr></tbody></table></figure>

<p><strong>b.</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MAYBE-MST-<span class="built_in">B</span>(G, w)</span><br><span class="line">    T = Ø</span><br><span class="line">    <span class="keyword">for</span> each edge e, taken in arbitrary order</span><br><span class="line">        <span class="keyword">if</span> T ∪ {e} has no cycles</span><br><span class="line">            T = T ∪ {e}</span><br><span class="line">    <span class="keyword">return</span> T</span><br></pre></td></tr></tbody></table></figure>

<p><strong>c.</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAYBE-MST-<span class="built_in">C</span>(G, w)</span><br><span class="line">    T = Ø</span><br><span class="line">    <span class="keyword">for</span> each edge e, taken in arbitrary order</span><br><span class="line">        T = T ∪ {e}</span><br><span class="line">        <span class="keyword">if</span> T has a cycle c</span><br><span class="line">            let e<span class="number">'</span> be a maximum-weight edge on c</span><br><span class="line">            T = T - {e}</span><br><span class="line">    <span class="keyword">return</span> T</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p><strong>a.</strong> 这确实会返回一个 $\text{MST}$。为了说明这一点，我们将证明我们永远不会删除必须是最小生成树一部分的边。如果我们删除 $e$，那么 $e$ 就不可能是桥，这意味着 e 位于图的一个简单循环上。由于我们按非递增顺序删除边，循环上每条边的权重必须小于或等于 $e$。根据练习 23.1-5，$G$ 上有一棵删除了边 $e$ 的最小生成树。</p>
<p>要实现这一点，我们首先要在 $O(E \lg E)$ 时间内对边进行排序。对于每一条边，我们都需要检查 $T - {e}$ 是否相连，因此我们需要运行 $\text{DFS}$。每一次都需要 $O(V+E)$，因此对所有边进行检查需要 $O(E(V+E))$。这将主导运行时间，因此总时间为 $O(E^2)$。</p>
<p><strong>b.</strong> 这不会返回 ${MST}$。要了解这一点，让 $G$ 成为有 3 个顶点 $a$、$b$ 和 $c$ 的图。让权重分别为 3、2 和 1 美元的 eges 分别为 $(a,b)$、$(b,c)$ 和 $(c,a)$。如果算法按照列出的顺序检查这些边，则会选取最重的两条边，而不是最轻的两条边。</p>
<p>高效的实现方法是使用不相邻集合来跟踪相连的组件，如问题 23-2 中的 $\text{MST-REDUCE}$。试图在同一组件内联合将产生一个循环。由于我们对 $\text{MAKESET}$ 的调用次数为 $|V|$，对 $\text{FIND-SET}$ 和 $\text{UNION}$ 的调用次数最多为 3|E|$，因此运行时间为 $O(E\alpha(V))$。</p>
<p><strong>c.</strong> 这确实会返回一个 $\text{MST}$。要了解这一点，我们只需引用练习 23.1-5 中的结果即可。我们移除的边只是某个循环上权重最大的边，而且总是存在不包含这些边的最小生成树。此外，如果我们从每个循环中删除一条边，那么得到的图就不可能有任何循环，因此它一定是一棵树。</p>
<p>为了实现这一点，我们使用了第(b)部分中的方法，只不过现在我们还需要找到循环上的最大权重边。对于每一条引入循环的边，我们都可以执行 $\text{DFS}$来找到循环和最大权重边。由于此时的树最多只有一个循环，因此它最多有 $|V|$ 条边，所以我们可以在 $O(V)$ 内运行 $\text{DFS}$。因此运行时间为 $O(EV)$。</p>
<h2 id="23-1-1"><a href="#23-1-1" class="headerlink" title="23.1-1"></a>23.1-1</h2><blockquote>
<p>设$(u, v)$是连通图$G$中的最小权边。显示$(u, v)$属于的$G$某个最小生成树。</p>
</blockquote>
<p>在GENERIC-MST的第一步中，我们可以选择这样的切割，节点u在一边，节点v在另一边。（u，v）是通过这个切割的一条轻边。因此，添加（u，v）是安全的。</p>
<h2 id="23-1-2"><a href="#23-1-2" class="headerlink" title="23.1-2"></a>23.1-2</h2><blockquote>
<p>萨巴蒂尔教授猜想定理 23.1 的逆定理如下。设$G = (V, E)$是一个连通的无向图，其上$E$定义了一个实值权函数$w$。设$A$是包含在某个最小生成树$G$中的$E$子集，设$(S, V - S)$是该方面$A$的$G$任何切割，且设$(u, v)$是用于$A$交叉$(S, V - S)$的安全边。然后，$(u, v)$是一个光边的切割。通过举反例来证明教授的猜想是错误的。</p>
</blockquote>
<p>设$G$图$4$的顶点为：$u, v, w, z$。设图$(u, v), (u, w), (w, z)$的边的权$3$分别为、$1$和$2$。</p>
<p>假设$A$是集合$\{(u, w)\}$。让$S = A$。然后$S$清楚地尊重$A$。既然$G$是一棵树，它的最小生成树就是它本身，所以$A$它通常是最小生成树的一个子集。</p>
<p>此外，每个边缘都是安全的。特别是$(u, v)$，对于切割来说是安全的，但不是轻的边缘。因此，萨巴蒂尔教授的猜想是错误的。</p>
<h2 id="23-1-3"><a href="#23-1-3" class="headerlink" title="23.1-3"></a>23.1-3</h2><blockquote>
<p>证明如果一条边$(u, v)$包含在某个最小生成树中，则它是穿过图的某个割集的一条轻边。</p>
</blockquote>
<p>设$T_0$和$T_1$是通过从 A$\text{MST}$中删除边$(u, v)$而得到的两棵树。假设$V_0$和$V_1$分别是和$T_1$的$T_0$顶点。</p>
<p>考虑与$V_1$分离$V_0$的切口。假设有一个矛盾，即在这个切割中，有一些边的重量小于$(u, v)$。然后，我们可以通过添加该边来$T_1 \cup T_0$构造整个图的最小生成树。这将导致最小生成树的权重小于包含$(u, v)$的原始最小生成树。</p>
<h2 id="23-1-4"><a href="#23-1-4" class="headerlink" title="23.1-4"></a>23.1-4</h2><blockquote>
<p>给出一个简单的例子，一个连通图的边$\{(u, v):$集合存在一个割集$(S, V - S)$，使得$(u, v)$轻边交叉$(S, V - S)\}$不形成最小生成树。</p>
</blockquote>
<p>当三角形三条边权重相同时,每条边在某种 切割 中均是最轻,即结果中存在环,所以不是最小生成树.</p>
<p>例如，如果我们有一个三角形具有相同的重量。在每个切割中，将有两个相等的边e1和e2。如果我们选择e1进入MST，虽然e2也是一个轻量级的，但它不在MST中。</p>
<h2 id="23-1-5"><a href="#23-1-5" class="headerlink" title="23.1-5"></a>23.1-5</h2><blockquote>
<p>设$e$是连通图$G = (V, E)$的某个圈上的最大权边。证明存在的$G’ = (V, E - \{e\})$最小生成树也是的$G$最小生成树。也就是说，存在不包括$e$的$G$最小生成树。</p>
</blockquote>
<p>设$A$为任何切割，其在切割的一侧导致循环中的一些顶点，而在另一侧导致循环中的一些顶点。对于这些切口中的任何一个，我们都知道该切口的边缘$e$不是轻边缘。因为所有其他的切割都不会有边缘$e$穿过它，所以我们也不会有任何切割的边缘是轻的。这意味着我们认为 E 不安全。</p>
<h2 id="23-1-6"><a href="#23-1-6" class="headerlink" title="23.1-6"></a>23.1-6</h2><blockquote>
<p>证明一个图有唯一的最小生成树，如果对于图的每个割集，都有唯一的轻边穿过割集。给出一个反例，说明反之不成立。</p>
</blockquote>
<p>假设存在两个最小生成树 T 和 T’. 对任意一条边 e 属于 T, 如果从 T 中移除 e, 则 T 变得不连通, 形成 cut (S, V - S), 根据练习 23.1-3 可知, e 是穿过 cut(S, V - S) 最轻边. 假设边 x 属于 T’, 并穿过 cut (S, V - S), 则 x 同样是最轻边. 由于穿过 cut(S, V - S) 的最轻边唯一. 既 e 和 x 是同一条边. 所以 e 也属于 T’, 由于我们选择 e 是任意的, 所有在 T 中的边, 同样在 T’ 中. 即最小生成树唯一.</p>
<p>假设有两个MST，称为T和T ‘。对于T中的任何边e，如果我们从T中移除e，则T变得不连通，并且我们有一个割（S，V-S）。根据练习23.1-3，e是通过切割的光边（S，V-S）.如果边x在T’中且穿过切割（S，V-S），则x也是一个轻权。因为光边是独一无二的。所以e和x是同一条边，e也在T ‘中。因为我们随机选择e，在T中的所有边中，也在T ‘中。因此，MST是独一无二的。</p>
<p>将条件和结论调换则不成立, 如下.</p>
<p>如果相反，则不成立。看图片。</p>
<p><img src="https://github.com/gzc/CLRS/raw/master/C23-Minimum-Spanning-Trees/repo/s1/2.jpg" alt="img"></p>
<h2 id="23-1-7"><a href="#23-1-7" class="headerlink" title="23.1-7"></a>23.1-7</h2><blockquote>
<p>如果一个图的所有边权都是正的，那么任何连接所有顶点且总权最小的边子集一定是一棵树。给出一个例子来说明，如果我们允许某些权为非正数，则不能得出相同的结论。</p>
</blockquote>
<p>首先，我们证明了连接所有顶点的最小总权重的边子集是一棵树。为了看到这一点，假设没有，它有一个周期。这意味着移除此循环中的任何边将意味着剩余的边仍将连接所有顶点，但其总权重将小于被移除的边的权重。这将与顶点子集的总权重的最小值相矛盾。由于边的子集形成树，并且具有最小的总权重，因此它也必须是最小生成树。</p>
<p>如果我们允许负的边权，这个结论是不正确的，我们提供了一个构造。考虑所有边权重等于$-1$的图$K_3$。连接图的边的唯一最小权重集具有总权重$-3$，并且由所有边组成。这显然不是 A$\text{MST}$，因为它不是一棵树，这很容易看出，因为它比三个顶点的树多一条边。这个加权图中的任何一个$\text{MST}$都必须具有至少$-2$为的权重。</p>
<h2 id="23-1-8"><a href="#23-1-8" class="headerlink" title="23.1-8"></a>23.1-8</h2><blockquote>
<p>设$T$是图$G$的最小生成树，$L$是图的边权$T$的排序表。证明对于的$G$任何其他最小生成树$T’$，该列表$L$也是的边权重$T’$的排序列表。</p>
</blockquote>
<p>假设这$L’$是最小生成树的边权重的另一个排序列表。如果$L’ \ne L$，则在或$T’$中必须有第一条边$(u, v)$$T$，其权重小于另一组中的相应边$(x, y)$。不失一般性，假设$(u, v)$是在$T$。</p>
<p>设$C$是通过添加$(u, v)$到$L’$得到的图。那么我们一定引入了一个循环。如果在该圈上存在权大于$(u, v)$的边，则我们可以移除它以获得权严格小于的$T’$权的树$C’$，这与最小生成树的事实$T’$相矛盾。</p>
<p>因此，循环上的每条边的权重必须小于或等于$(u, v)$。假设每条边都具有严格较小的权。从$T$拆下$(u, v)$，将其分成两个组件。除了连接这些的圈之外，还必须存在一些边$(u, v)$，由于它具有较小的权重，我们可以使用该边来创建权重小于$T$的生成树，这是一个矛盾。因此，循环上的某些边具有与$(u, v)$相同的权重。将该边缘替换为$(u, v)$。相应的列表$L$和$L’$保持不变，因为我们换出了一条权重相等的边，但和$T’$共有的边$T$的数量增加了$1$。</p>
<p>如果我们以这种方式继续下去，最终它们必须有共同的边，这与它们的边权重在某些地方不同的事实相矛盾。因此，所有最小生成树都具有相同的边权重排序列表。</p>
<h2 id="23-1-9"><a href="#23-1-9" class="headerlink" title="23.1-9"></a>23.1-9</h2><blockquote>
<p>设$T$是一个图$G = (V, E)$的最小生成树，$V’$是的$V$一个子集。设$T’$为由$V’$导出的$T$子图，设$G’$为由$V’$导出的$G$子图。证明如果$T’$是连通的，则$T’$是的$G’$最小生成树。</p>
</blockquote>
<p>假设有一棵比$T’$这更便宜的生成树。也就是说，我们有一些$T’’$，所以$w(T’’) &lt; w(T’)$。然后，设$S$边在中$T$，但不在中$T’$。然后，我们可以通过考虑$S \cup T’’$来构造的$G$最小生成树。这是一个生成树，$T’’$因为$S \cup T’$它使所有的顶点$V’$都像$T’$这样连接起来。</p>
<p>然而，我们有</p>
<p>$$W（s\cup t ‘ ‘）=W（s）+W（t ‘ ‘） &lt;W（s）+W（t ‘）=W（S\cup t ‘）=w（t）。$$</p>
<p>这意味着我们刚刚找到了一个比最小生成树具有更低总权重的生成树。这是一个矛盾，所以我们假设有一个比$T’$更便宜的$V’$生成树一定是错误的。</p>
<h2 id="23-1-10"><a href="#23-1-10" class="headerlink" title="23.1-10"></a>23.1-10</h2><blockquote>
<p>给定一个图$G$和一个最小生成树$T$，假设我们减少其中一条边$T$的权重。显示$T$仍然是的$G$最小生成树。更正式地，设$T$是具有由权函数$w$给出的边权的$G$最小生成树。选择一条边$(x, y) \in T$和一个正数$k$，并定义权重函数$w’$</p>
<p>$$<br>w’(u, v) =<br>\begin{cases}<br>w(u, v)     &amp; \text{ if }(u, v) \ne (x, y), \\<br>w(x, y) - k &amp; \text{ if }(u, v) =   (x, y).<br>\end{cases}<br>$$</p>
<p>证明$T$是的最小生成树，$G$其边权由$w’$给出。</p>
</blockquote>
<p>我们通过切割来证明。最初，（x，y）是某个切割（V1，V2）中的轻边。减小（x，y），（x，y）的权重仍然是一个轻边。所以T是G的最小生成树，其边权由w′给出。</p>
<h2 id="23-1-11-star"><a href="#23-1-11-star" class="headerlink" title="23.1-11$\star$"></a>23.1-11$\star$</h2><blockquote>
<p>给定一个图$G$和一个最小生成树$T$，假设我们减少其中一条不在$T$的边的权重。给出了在修改图中求最小生成树的算法。</p>
</blockquote>
<p>如果我们将这个新减少的边添加到给定的树中，我们将创建一个循环。然后，如果我们沿着这个循环删除任何一条边，我们仍然会有一个生成树。这意味着我们沿着通过添加减少的边而形成的该循环查看所有权重，并且移除最大权重的循环中的边。这正是我们想要的，因为我们可能只想添加单个减少的边，然后，从那里我们将图改回树，使其总权重最小化。</p>
<h2 id="23-2-1"><a href="#23-2-1" class="headerlink" title="23.2-1"></a>23.2-1</h2><blockquote>
<p>Kruskal 的算法可以为相同的输入图$G$返回不同的生成树，这取决于当边按顺序排序时它如何打破联系。证明对于的$G$每个最小生成树$T$，有一种方法可以对克鲁斯卡尔算法中的$G$边进行排序，以便算法返回$T$。</p>
</blockquote>
<p>假设我们想要选择$T$作为我们的最小生成树。然后，为了使用 Kruskal 算法获得该树，我们将首先根据边的权重对边进行排序，然后将通过首先挑选包含在最小生成树中的边来解决边权重的关系，并将所有不$T$包含在最小生成树中的边视为稍大，即使它们具有相同的实际权重。</p>
<p>通过这种排序，我们仍然可以找到与所有最小生成树$w(T)$具有相同权重的树。然而，由于我们对中$T$的边进行了优先排序，我们将在其他最小生成树中的任何其他边上挑选它们。</p>
<h2 id="23-2-2"><a href="#23-2-2" class="headerlink" title="23.2-2"></a>23.2-2</h2><blockquote>
<p>假设我们将图$G = (V, E)$表示为邻接矩阵。对于这种情况，给出 Prim 算法的一个简单实现，它在$O(V^2)$时间上运行。</p>
</blockquote>
<p>在算法的每一步，我们将添加一条边，从目前为止创建的树中的一个顶点到不在树中的一个顶点，使得这条边具有最小权重。因此，对于不在树中的每个顶点，知道从该顶点到最小权重的树中的某个顶点的边将是有用的。我们将此信息存储在一个数组$A$中，其中$A[u] = (v, w)$如果$w$是的权重$(u, v)$，并且在到目前为止构建的树中从$u$到某个顶点$v$的边的权重中是最小的。我们将使用$A[u].1$访问$v$和$A[u].2$访问$w$。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PRIM-<span class="built_in">ADJ</span>(G, w, r)</span><br><span class="line">    initialize A with every entry = (NIL, ∞)</span><br><span class="line">    T = {r}</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to V</span><br><span class="line">        <span class="keyword">if</span> Adj[r, i] != <span class="number">0</span></span><br><span class="line">            A[i] = (r, <span class="built_in">w</span>(r, i))</span><br><span class="line">    <span class="keyword">for</span> each u in V - T</span><br><span class="line">        k = <span class="built_in">min</span>(A[i]<span class="number">.2</span>)</span><br><span class="line">        T = T ∪ {k}</span><br><span class="line">        k.π = A[k]<span class="number">.1</span></span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span> to V</span><br><span class="line">            <span class="keyword">if</span> Adf[k, i] != <span class="number">0</span> <span class="keyword">and</span> Adj[k, i] &lt; A[i]<span class="number">.2</span></span><br><span class="line">                A[i] = (k, Adj[k, i])</span><br></pre></td></tr></tbody></table></figure>

<h2 id="23-2-3"><a href="#23-2-3" class="headerlink" title="23.2-3"></a>23.2-3</h2><blockquote>
<p>对于稀疏图$G = (V, E)$，其中$|E| = \Theta(V)$，使用斐波那契堆实现 Prim 算法是否比二进制堆实现更快？对于一个稠密的图，在哪里$|E| = \Theta(V^2)$？斐波那契堆实现的大小$|E|$和$|V|$之间的关系如何才能比二进制堆实现更快？</p>
</blockquote>
<p>用二进制堆实现的 Prim 算法的运行时间为 $O((V+E)\lg V)$，在稀疏的情况下，运行时间仅为 $O(V\lg V)$。用斐波那契堆实现的算法是</p>
<p>$$O(E + V\lg V) = O(V + V\lg V) = O(V \lg V).$$</p>
<ul>
<li><p>在稀疏情况下，两种算法的渐进运行时间相同。</p>
</li>
<li><p>在密集的情况下。</p>
<ul>
<li><p>二进制堆实现的运行时间为</p>
<p>  $$O((V + E)\lg V) = O((V + V^2)\lg V) = O(V^2\lg V).$$</p>
</li>
<li><p>斐波纳契堆实现的运行时为</p>
<p>  $$O(E + V\lg V) = O(V^2 + V\lg V) = O(V^2).$$</p>
</li>
</ul>
<p>  因此，在密集情况下，斐波那契堆的实现速度会逐渐加快。</p>
</li>
<li><p>只要 $E = \omega(V)$，斐波那契堆实现的速度就会逐渐加快。假设我们有一个比线性增长更快的函数，比如 $f$，而 $E = f(V)$。</p>
</li>
<li><p>二进制堆实现的运行时间为</p>
<p>  $$O((V + E)\lg V) = O((V + f(V))\lg V) = O(f(V)\lg V).$$</p>
</li>
</ul>
<p>但是，斐波纳契堆实现的运行时将具有</p>
<p>$$O(E + V\lg V) = O(f(V) + V\lg V).$$</p>
<p>此运行时要么$O(f(V))$是或，要么$O(V\lg V)$取决于其$f(V)$增长速度是否$V\lg V$分别更快或更慢。</p>
<p>在这两种情况下，运行时都比$O(f(V)\lg V)$。</p>
<h2 id="23-2-4"><a href="#23-2-4" class="headerlink" title="23.2-4"></a>23.2-4</h2><blockquote>
<p>假设图中的所有边权都是从$1$到$|V|$范围内的整数。你能让克鲁斯卡尔的算法以多快的速度运行？如果对于某个常数$W$，边权重是从$1$到$W$范围内的整数呢？</p>
</blockquote>
<p>（已删除）</p>
<p>如果w是一个常数，我们可以使用计数排序</p>
<p>·对边排序：O（E lg E）时间。</p>
<p>· O（E）不交集森林上的运算，时间复杂度为O（Eα（V））。</p>
<p>排序占优势，因此总时间是O（E lg E）。当边落在范围1，. . .，|V|时间复杂度为O（V + E）时间复杂度为O（Eα（V））。如果边缘落在范围1，. . .，W对于任何常数W，我们仍然需要使用Ω（E）时间进行排序，并且总运行时间不能进一步提高。</p>
<h2 id="23-2-5"><a href="#23-2-5" class="headerlink" title="23.2-5"></a>23.2-5</h2><blockquote>
<p>假设图中的所有边权都是从$1$到$|V|$范围内的整数。你能让普里姆的算法运行多快？如果对于某个常数$W$，边权重是从$1$到$W$范围内的整数呢？</p>
</blockquote>
<p>对于第一种情况，我们可以使用 Van Emde Boas 树来改进时间限制$O(E \lg \lg V)$。与 Fibonacci 堆实现相比，该方法仅对稀疏图的渐近运行时间有所改善，而不能多项式地改善运行时间。这种实现的优点是它可以具有较低的开销。</p>
<p>对于第二种情况，我们可以使用双链表的集合，每个双链表对应于一个边权。这提高了到$O(E)$的界限。</p>
<h2 id="23-2-6-star"><a href="#23-2-6-star" class="headerlink" title="23.2-6$\star$"></a>23.2-6$\star$</h2><blockquote>
<p>假设图中的边权在半开区间$[0, 1)$上均匀分布。克鲁斯卡尔算法和普里姆算法，哪种算法能让你跑得更快？</p>
</blockquote>
<p>对于从均匀分布中提取的输入，我将使用 Kruskal 算法的桶排序，用于按权重对边进行预期线性时间排序。这将达到预期的运行时间$O(E\alpha(V))$。</p>
<h2 id="23-2-7-star"><a href="#23-2-7-star" class="headerlink" title="23.2-7$\star$"></a>23.2-7$\star$</h2><blockquote>
<p>假设已经计算了一个图$G$的最小生成树。如果我们添加一个新的顶点和关联边，$G$我们更新最小生成树的速度有多快？</p>
</blockquote>
<p>如果只有一条边,只需要将这个顶点和这条边加进去.</p>
<p>如果有k(k &gt; 1)条边,那么需要删去k-1条边.</p>
<p>假设新节点是v,那么从v必然有一些回路. 遍历k-1次,每次都能找到一个回路,从该回路中删除一条权值最大的边.</p>
<p>如果只有一条边，只需添加此边。</p>
<p>如果有k（k &gt; 1）条边，则需要移除k-1条边。我们可以通过Union-Find找到循环，并删除并集中最重的边。该算法需要（k-1）遍。</p>
<h2 id="23-2-8"><a href="#23-2-8" class="headerlink" title="23.2-8"></a>23.2-8</h2><blockquote>
<p>波登教授提出了一种新的分治算法来计算最小生成树，该算法如下。给定一个图$G = (V, E)$，将顶点集$V$划分为两个集合$V_1$和$V_2$，使得$|V_1|$和$|V_2|$最多$1$相差。设$E_1$为仅在中的$V_1$顶点上关联的边的集合，设$E_2$为仅在中的$V_2$顶点上关联的边的集合。递归求解两个子图$G_1 = (V_1, E_1)$和$G_2 = (V_2, E_2)$上的最小生成树问题。最后，选择穿过切口$(V_1, V_2)$的最小权重边$E$，并使用该边将生成的两个最小生成树合并为一个生成树。</p>
<p>要么论证该算法正确计算了的$G$最小生成树，要么提供一个该算法失败的例子。</p>
</blockquote>
<p>算法失败。假设$E = \{(u, v), (u, w), (v, w)\}$，和$(u, w)$的$(u, v)$权为$1$，的$(v, w)$权为$1000$，将集合划分为两个集合$V_1 = \{u\}$和$V_2 = \{v, w\}$。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">liwuxuan</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.liwuxuanplus.com/2023/11/01/suan-fa-dao-lun-di-22-zhang-he-di-23-zhang-da-an/">https://www.liwuxuanplus.com/2023/11/01/suan-fa-dao-lun-di-22-zhang-he-di-23-zhang-da-an/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">liwuxuan</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '5fd2a6d26796e3d5c7a9',
        clientSecret: '622e3f8606462480a293aa2e5eaa426e552f3f5b',
        repo: 'talk',
        owner: 'liwuxuan',
        admin: "liwuxuan",
        id: '2023-11-01T22-25-20',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/valine/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'duBrbZAVJEShhsZDeYpCpMOU-gzGzoHsz',
        appKey: 'SCsTlP7tTIKaC4JsVlvokiah',
        serverURLs: 'https://dubrbzav.lc-cn-n1-shared.com',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>

<!--酷Q推送-->


    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/03/23/yun-ji-suan-shi-yan-bao-gao-3/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/medias/featureimages/23.jpg" class="responsive-img" alt="云计算实验报告3">
                        
                        <span class="card-title">云计算实验报告3</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-03-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            liwuxuan
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">
                        <span class="chip bg-color">云计算实验报告</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/10/20/shan-dong-da-xue-hui-bian-shi-yan-yi/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/medias/featureimages/17.jpg" class="responsive-img" alt="山东大学汇编实验一">
                        
                        <span class="card-title">山东大学汇编实验一</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-10-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            liwuxuan
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C/">
                        <span class="chip bg-color">汇编实验</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: MySite<br />'
            + '文章作者: liwuxuan<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, h5, h6, h7'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2024</span>
            
            <a href="/about" target="_blank">liwuxuan</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">49.6k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "9";
                        var startDate = "27";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">














</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/others/star.js"><\/script>');
            }
        </script>
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: "d7ce1149"
        });
        daovoice('update');
    </script>
    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="https://cdn.jsdelivr.net/gh/liwuxuan/liwuxuan.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
